import 'package:meta/meta.dart';

/// Provides APIs for creating and managing Amazon Forecast resources.
class ForecastqueryApi {
  final _client;
  ForecastqueryApi(client)
      : _client = client.configured('forecastquery', serializer: 'json');

  /// Retrieves a forecast filtered by the supplied criteria.
  ///
  /// The criteria is a key-value pair. The key is either `item_id` (or the
  /// equivalent non-timestamp, non-target field) from the `TARGET_TIME_SERIES`
  /// dataset, or one of the forecast dimensions specified as part of the
  /// `FeaturizationConfig` object.
  ///
  /// By default, the complete date range of the filtered forecast is returned.
  /// Optionally, you can request a specific date range within the forecast.
  ///
  ///
  ///
  /// The forecasts generated by Amazon Forecast are in the same timezone as the
  /// dataset that was used to create the predictor.
  ///
  /// [forecastArn]: The Amazon Resource Name (ARN) of the forecast to query.
  ///
  /// [startDate]: The start date for the forecast. Specify the date using this
  /// format: yyyy-MM-dd'T'HH:mm:ss'Z' (ISO 8601 format) For example,
  /// "1970-01-01T00:00:00Z."
  ///
  /// [endDate]: The end date for the forecast. Specify the date using this
  /// format: yyyy-MM-dd'T'HH:mm:ss'Z' (ISO 8601 format). For example,
  /// "1970-01-01T00:00:00Z."
  ///
  /// [filters]: The filtering criteria to apply when retrieving the forecast.
  /// For example:
  ///
  /// *   To get a forecast for a specific item specify the following:
  ///
  ///      `{"item_id" : "client_1"}`
  ///
  ///
  /// *   To get a forecast for a specific item sold in a specific location,
  /// specify the following:
  ///
  ///      `{"item_id" : "client_1", "location" : "ny"}`
  ///
  ///
  /// *   To get a forecast for all blue items sold in a specific location,
  /// specify the following:
  ///
  ///      `{ "location" : "ny", "color":"blue"}`
  ///
  ///
  /// To get the full forecast, use the operation.
  ///
  /// [nextToken]: If the result of the previous request was truncated, the
  /// response includes a `NextToken`. To retrieve the next set of results, use
  /// the token in the next request. Tokens expire after 24 hours.
  Future<QueryForecastResponse> queryForecast(
      {@required String forecastArn,
      String startDate,
      String endDate,
      @required Map<String, String> filters,
      String nextToken}) async {
    var response_ = await _client.send('QueryForecast', {
      'ForecastArn': forecastArn,
      if (startDate != null) 'StartDate': startDate,
      if (endDate != null) 'EndDate': endDate,
      'Filters': filters,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return QueryForecastResponse.fromJson(response_);
  }
}

/// The forecast value for a specific date. Part of the Forecast object.
class DataPoint {
  /// The timestamp of the specific forecast.
  final String timestamp;

  /// The forecast value.
  final double value;

  DataPoint({
    this.timestamp,
    this.value,
  });
  static DataPoint fromJson(Map<String, dynamic> json) => DataPoint(
        timestamp:
            json.containsKey('Timestamp') ? json['Timestamp'] as String : null,
        value: json.containsKey('Value') ? json['Value'] as double : null,
      );
}

/// Provides information about a forecast. Returned as part of the QueryForecast
/// response.
class Forecast {
  /// The forecast.
  ///
  /// The _string_ of the string to array map is one of the following values:
  ///
  /// *   mean
  ///
  /// *   p10
  ///
  /// *   p50
  ///
  /// *   p90
  final Map<String, List<DataPoint>> predictions;

  Forecast({
    this.predictions,
  });
  static Forecast fromJson(Map<String, dynamic> json) => Forecast(
        predictions: json.containsKey('Predictions')
            ? (json['Predictions'] as Map).map((k, v) => MapEntry(k as String,
                (v as List).map((e) => DataPoint.fromJson(e)).toList()))
            : null,
      );
}

class QueryForecastResponse {
  /// The forecast.
  final Forecast forecast;

  QueryForecastResponse({
    this.forecast,
  });
  static QueryForecastResponse fromJson(Map<String, dynamic> json) =>
      QueryForecastResponse(
        forecast: json.containsKey('Forecast')
            ? Forecast.fromJson(json['Forecast'])
            : null,
      );
}
