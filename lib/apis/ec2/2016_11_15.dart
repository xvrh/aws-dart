import 'package:meta/meta.dart';
import 'dart:typed_data';

/// Amazon Elastic Compute Cloud
///
/// Amazon Elastic Compute Cloud (Amazon EC2) provides secure and resizable
/// computing capacity in the AWS cloud. Using Amazon EC2 eliminates the need to
/// invest in hardware up front, so you can develop and deploy applications
/// faster.
///
/// To learn more, see the following resources:
///
/// *   Amazon EC2: [AmazonEC2 product page](http://aws.amazon.com/ec2),
/// [Amazon EC2 documentation](http://aws.amazon.com/documentation/ec2)
///
/// *   Amazon EBS: [Amazon EBS product page](http://aws.amazon.com/ebs),
/// [Amazon EBS documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AmazonEBS.html)
///
/// *   Amazon VPC: [Amazon VPC product page](http://aws.amazon.com/vpc),
/// [Amazon VPC documentation](http://aws.amazon.com/documentation/vpc)
///
/// *   AWS VPN: [AWS VPN product page](http://aws.amazon.com/vpn),
/// [AWS VPN documentation](http://aws.amazon.com/documentation/vpn)
class Ec2Api {
  final _client;
  Ec2Api(client) : _client = client.configured('EC2', serializer: 'ec2');

  /// Accepts the Convertible Reserved Instance exchange quote described in the
  /// GetReservedInstancesExchangeQuote call.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [reservedInstanceIds]: The IDs of the Convertible Reserved Instances to
  /// exchange for another Convertible Reserved Instance of the same or higher
  /// value.
  ///
  /// [targetConfigurations]: The configuration of the target Convertible
  /// Reserved Instance to exchange for your current Convertible Reserved
  /// Instances.
  Future<AcceptReservedInstancesExchangeQuoteResult>
      acceptReservedInstancesExchangeQuote(List<String> reservedInstanceIds,
          {bool dryRun,
          List<TargetConfigurationRequest> targetConfigurations}) async {
    var response_ = await _client.send('AcceptReservedInstancesExchangeQuote', {
      if (dryRun != null) 'DryRun': dryRun,
      'ReservedInstanceIds': reservedInstanceIds,
      if (targetConfigurations != null)
        'TargetConfigurations': targetConfigurations,
    });
    return AcceptReservedInstancesExchangeQuoteResult.fromJson(response_);
  }

  /// Accepts a request to attach a VPC to a transit gateway.
  ///
  /// The VPC attachment must be in the `pendingAcceptance` state. Use
  /// DescribeTransitGatewayVpcAttachments to view your pending VPC attachment
  /// requests. Use RejectTransitGatewayVpcAttachment to reject a VPC attachment
  /// request.
  ///
  /// [transitGatewayAttachmentId]: The ID of the attachment.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<AcceptTransitGatewayVpcAttachmentResult>
      acceptTransitGatewayVpcAttachment(String transitGatewayAttachmentId,
          {bool dryRun}) async {
    var response_ = await _client.send('AcceptTransitGatewayVpcAttachment', {
      'TransitGatewayAttachmentId': transitGatewayAttachmentId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return AcceptTransitGatewayVpcAttachmentResult.fromJson(response_);
  }

  /// Accepts one or more interface VPC endpoint connection requests to your VPC
  /// endpoint service.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [serviceId]: The ID of the endpoint service.
  ///
  /// [vpcEndpointIds]: The IDs of one or more interface VPC endpoints.
  Future<AcceptVpcEndpointConnectionsResult> acceptVpcEndpointConnections(
      {bool dryRun,
      @required String serviceId,
      @required List<String> vpcEndpointIds}) async {
    var response_ = await _client.send('AcceptVpcEndpointConnections', {
      if (dryRun != null) 'DryRun': dryRun,
      'ServiceId': serviceId,
      'VpcEndpointIds': vpcEndpointIds,
    });
    return AcceptVpcEndpointConnectionsResult.fromJson(response_);
  }

  /// Accept a VPC peering connection request. To accept a request, the VPC
  /// peering connection must be in the `pending-acceptance` state, and you must
  /// be the owner of the peer VPC. Use DescribeVpcPeeringConnections to view
  /// your outstanding VPC peering connection requests.
  ///
  /// For an inter-Region VPC peering connection request, you must accept the
  /// VPC peering connection in the Region of the accepter VPC.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [vpcPeeringConnectionId]: The ID of the VPC peering connection. You must
  /// specify this parameter in the request.
  Future<AcceptVpcPeeringConnectionResult> acceptVpcPeeringConnection(
      {bool dryRun, String vpcPeeringConnectionId}) async {
    var response_ = await _client.send('AcceptVpcPeeringConnection', {
      if (dryRun != null) 'DryRun': dryRun,
      if (vpcPeeringConnectionId != null)
        'VpcPeeringConnectionId': vpcPeeringConnectionId,
    });
    return AcceptVpcPeeringConnectionResult.fromJson(response_);
  }

  /// Advertises an IPv4 address range that is provisioned for use with your AWS
  /// resources through bring your own IP addresses (BYOIP).
  ///
  /// You can perform this operation at most once every 10 seconds, even if you
  /// specify different address ranges each time.
  ///
  /// We recommend that you stop advertising the BYOIP CIDR from other locations
  /// when you advertise it from AWS. To minimize down time, you can configure
  /// your AWS resources to use an address from a BYOIP CIDR before it is
  /// advertised, and then simultaneously stop advertising it from the current
  /// location and start advertising it through AWS.
  ///
  /// It can take a few minutes before traffic to the specified addresses starts
  /// routing to AWS because of BGP propagation delays.
  ///
  /// To stop advertising the BYOIP CIDR, use WithdrawByoipCidr.
  ///
  /// [cidr]: The IPv4 address range, in CIDR notation. This must be the exact
  /// range that you provisioned. You can't advertise only a portion of the
  /// provisioned range.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<AdvertiseByoipCidrResult> advertiseByoipCidr(String cidr,
      {bool dryRun}) async {
    var response_ = await _client.send('AdvertiseByoipCidr', {
      'Cidr': cidr,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return AdvertiseByoipCidrResult.fromJson(response_);
  }

  /// Allocates an Elastic IP address to your AWS account. After you allocate
  /// the Elastic IP address you can associate it with an instance or network
  /// interface. After you release an Elastic IP address, it is released to the
  /// IP address pool and can be allocated to a different AWS account.
  ///
  /// You can allocate an Elastic IP address from an address pool owned by AWS
  /// or from an address pool created from a public IPv4 address range that you
  /// have brought to AWS for use with your AWS resources using bring your own
  /// IP addresses (BYOIP). For more information, see
  /// [Bring Your Own IP Addresses (BYOIP)](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-byoip.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [EC2-VPC] If you release an Elastic IP address, you might be able to
  /// recover it. You cannot recover an Elastic IP address that you released
  /// after it is allocated to another AWS account. You cannot recover an
  /// Elastic IP address for EC2-Classic. To attempt to recover an Elastic IP
  /// address that you released, specify it in this operation.
  ///
  /// An Elastic IP address is for use either in the EC2-Classic platform or in
  /// a VPC. By default, you can allocate 5 Elastic IP addresses for EC2-Classic
  /// per Region and 5 Elastic IP addresses for EC2-VPC per Region.
  ///
  /// For more information, see
  /// [Elastic IP Addresses](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [domain]: Set to `vpc` to allocate the address for use with instances in a
  /// VPC.
  ///
  /// Default: The address is for use with instances in EC2-Classic.
  ///
  /// [address]: [EC2-VPC] The Elastic IP address to recover or an IPv4 address
  /// from an address pool.
  ///
  /// [publicIpv4Pool]: The ID of an address pool that you own. Use this
  /// parameter to let Amazon EC2 select an address from the address pool. To
  /// specify a specific address from the address pool, use the `Address`
  /// parameter instead.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<AllocateAddressResult> allocateAddress(
      {String domain,
      String address,
      String publicIpv4Pool,
      bool dryRun}) async {
    var response_ = await _client.send('AllocateAddress', {
      if (domain != null) 'Domain': domain,
      if (address != null) 'Address': address,
      if (publicIpv4Pool != null) 'PublicIpv4Pool': publicIpv4Pool,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return AllocateAddressResult.fromJson(response_);
  }

  /// Allocates a Dedicated Host to your account. At a minimum, specify the
  /// instance size type, Availability Zone, and quantity of hosts to allocate.
  ///
  /// [autoPlacement]: Indicates whether the host accepts any untargeted
  /// instance launches that match its instance type configuration, or if it
  /// only accepts Host tenancy instance launches that specify its unique host
  /// ID. For more information, see
  /// [Understanding Instance Placement and Host Affinity](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-dedicated-hosts-work.html#dedicated-hosts-understanding)
  /// in the _Amazon EC2 User Guide for Linux Instances_.
  ///
  /// Default: `on`
  ///
  /// [availabilityZone]: The Availability Zone in which to allocate the
  /// Dedicated Host.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that you provide to
  /// ensure the idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// [instanceType]: Specifies the instance type for which to configure your
  /// Dedicated Hosts. When you specify the instance type, that is the only
  /// instance type that you can launch onto that host.
  ///
  /// [quantity]: The number of Dedicated Hosts to allocate to your account with
  /// these parameters.
  ///
  /// [tagSpecifications]: The tags to apply to the Dedicated Host during
  /// creation.
  ///
  /// [hostRecovery]: Indicates whether to enable or disable host recovery for
  /// the Dedicated Host. Host recovery is disabled by default. For more
  /// information, see
  /// [Host Recovery](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-recovery.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// Default: `off`
  Future<AllocateHostsResult> allocateHosts(
      {String autoPlacement,
      @required String availabilityZone,
      String clientToken,
      @required String instanceType,
      @required int quantity,
      List<TagSpecification> tagSpecifications,
      String hostRecovery}) async {
    var response_ = await _client.send('AllocateHosts', {
      if (autoPlacement != null) 'AutoPlacement': autoPlacement,
      'AvailabilityZone': availabilityZone,
      if (clientToken != null) 'ClientToken': clientToken,
      'InstanceType': instanceType,
      'Quantity': quantity,
      if (tagSpecifications != null) 'TagSpecifications': tagSpecifications,
      if (hostRecovery != null) 'HostRecovery': hostRecovery,
    });
    return AllocateHostsResult.fromJson(response_);
  }

  /// Applies a security group to the association between the target network and
  /// the Client VPN endpoint. This action replaces the existing security groups
  /// with the specified security groups.
  ///
  /// [clientVpnEndpointId]: The ID of the Client VPN endpoint.
  ///
  /// [vpcId]: The ID of the VPC in which the associated target network is
  /// located.
  ///
  /// [securityGroupIds]: The IDs of the security groups to apply to the
  /// associated target network. Up to 5 security groups can be applied to an
  /// associated target network.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ApplySecurityGroupsToClientVpnTargetNetworkResult>
      applySecurityGroupsToClientVpnTargetNetwork(
          {@required String clientVpnEndpointId,
          @required String vpcId,
          @required List<String> securityGroupIds,
          bool dryRun}) async {
    var response_ =
        await _client.send('ApplySecurityGroupsToClientVpnTargetNetwork', {
      'ClientVpnEndpointId': clientVpnEndpointId,
      'VpcId': vpcId,
      'SecurityGroupIds': securityGroupIds,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ApplySecurityGroupsToClientVpnTargetNetworkResult.fromJson(
        response_);
  }

  /// Assigns one or more IPv6 addresses to the specified network interface. You
  /// can specify one or more specific IPv6 addresses, or you can specify the
  /// number of IPv6 addresses to be automatically assigned from within the
  /// subnet's IPv6 CIDR block range. You can assign as many IPv6 addresses to a
  /// network interface as you can assign private IPv4 addresses, and the limit
  /// varies per instance type. For information, see
  /// [IP Addresses Per Network Interface Per Instance Type](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html#AvailableIpPerENI)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [ipv6AddressCount]: The number of IPv6 addresses to assign to the network
  /// interface. Amazon EC2 automatically selects the IPv6 addresses from the
  /// subnet range. You can't use this option if specifying specific IPv6
  /// addresses.
  ///
  /// [ipv6Addresses]: One or more specific IPv6 addresses to be assigned to the
  /// network interface. You can't use this option if you're specifying a number
  /// of IPv6 addresses.
  ///
  /// [networkInterfaceId]: The ID of the network interface.
  Future<AssignIpv6AddressesResult> assignIpv6Addresses(
      String networkInterfaceId,
      {int ipv6AddressCount,
      List<String> ipv6Addresses}) async {
    var response_ = await _client.send('AssignIpv6Addresses', {
      if (ipv6AddressCount != null) 'Ipv6AddressCount': ipv6AddressCount,
      if (ipv6Addresses != null) 'Ipv6Addresses': ipv6Addresses,
      'NetworkInterfaceId': networkInterfaceId,
    });
    return AssignIpv6AddressesResult.fromJson(response_);
  }

  /// Assigns one or more secondary private IP addresses to the specified
  /// network interface.
  ///
  /// You can specify one or more specific secondary IP addresses, or you can
  /// specify the number of secondary IP addresses to be automatically assigned
  /// within the subnet's CIDR block range. The number of secondary IP addresses
  /// that you can assign to an instance varies by instance type. For
  /// information about instance types, see
  /// [Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_. For more information
  /// about Elastic IP addresses, see
  /// [Elastic IP Addresses](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// When you move a secondary private IP address to another network interface,
  /// any Elastic IP address that is associated with the IP address is also
  /// moved.
  ///
  /// Remapping an IP address is an asynchronous operation. When you move an IP
  /// address from one network interface to another, check
  /// `network/interfaces/macs/mac/local-ipv4s` in the instance metadata to
  /// confirm that the remapping is complete.
  ///
  /// [allowReassignment]: Indicates whether to allow an IP address that is
  /// already assigned to another network interface or instance to be reassigned
  /// to the specified network interface.
  ///
  /// [networkInterfaceId]: The ID of the network interface.
  ///
  /// [privateIpAddresses]: One or more IP addresses to be assigned as a
  /// secondary private IP address to the network interface. You can't specify
  /// this parameter when also specifying a number of secondary IP addresses.
  ///
  /// If you don't specify an IP address, Amazon EC2 automatically selects an IP
  /// address within the subnet range.
  ///
  /// [secondaryPrivateIpAddressCount]: The number of secondary IP addresses to
  /// assign to the network interface. You can't specify this parameter when
  /// also specifying private IP addresses.
  Future<AssignPrivateIpAddressesResult> assignPrivateIpAddresses(
      String networkInterfaceId,
      {bool allowReassignment,
      List<String> privateIpAddresses,
      int secondaryPrivateIpAddressCount}) async {
    var response_ = await _client.send('AssignPrivateIpAddresses', {
      if (allowReassignment != null) 'AllowReassignment': allowReassignment,
      'NetworkInterfaceId': networkInterfaceId,
      if (privateIpAddresses != null) 'PrivateIpAddresses': privateIpAddresses,
      if (secondaryPrivateIpAddressCount != null)
        'SecondaryPrivateIpAddressCount': secondaryPrivateIpAddressCount,
    });
    return AssignPrivateIpAddressesResult.fromJson(response_);
  }

  /// Associates an Elastic IP address with an instance or a network interface.
  /// Before you can use an Elastic IP address, you must allocate it to your
  /// account.
  ///
  /// An Elastic IP address is for use in either the EC2-Classic platform or in
  /// a VPC. For more information, see
  /// [Elastic IP Addresses](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [EC2-Classic, VPC in an EC2-VPC-only account] If the Elastic IP address is
  /// already associated with a different instance, it is disassociated from
  /// that instance and associated with the specified instance. If you associate
  /// an Elastic IP address with an instance that has an existing Elastic IP
  /// address, the existing address is disassociated from the instance, but
  /// remains allocated to your account.
  ///
  /// [VPC in an EC2-Classic account] If you don't specify a private IP address,
  /// the Elastic IP address is associated with the primary IP address. If the
  /// Elastic IP address is already associated with a different instance or a
  /// network interface, you get an error unless you allow reassociation. You
  /// cannot associate an Elastic IP address with an instance or network
  /// interface that has an existing Elastic IP address.
  ///
  ///
  ///
  /// This is an idempotent operation. If you perform the operation more than
  /// once, Amazon EC2 doesn't return an error, and you may be charged for each
  /// time the Elastic IP address is remapped to the same instance. For more
  /// information, see the _Elastic IP Addresses_ section of
  /// [Amazon EC2 Pricing](http://aws.amazon.com/ec2/pricing/).
  ///
  /// [allocationId]: [EC2-VPC] The allocation ID. This is required for EC2-VPC.
  ///
  /// [instanceId]: The ID of the instance. This is required for EC2-Classic.
  /// For EC2-VPC, you can specify either the instance ID or the network
  /// interface ID, but not both. The operation fails if you specify an instance
  /// ID unless exactly one network interface is attached.
  ///
  /// [publicIp]: The Elastic IP address to associate with the instance. This is
  /// required for EC2-Classic.
  ///
  /// [allowReassociation]: [EC2-VPC] For a VPC in an EC2-Classic account,
  /// specify true to allow an Elastic IP address that is already associated
  /// with an instance or network interface to be reassociated with the
  /// specified instance or network interface. Otherwise, the operation fails.
  /// In a VPC in an EC2-VPC-only account, reassociation is automatic, therefore
  /// you can specify false to ensure the operation fails if the Elastic IP
  /// address is already associated with another resource.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [networkInterfaceId]: [EC2-VPC] The ID of the network interface. If the
  /// instance has more than one network interface, you must specify a network
  /// interface ID.
  ///
  /// For EC2-VPC, you can specify either the instance ID or the network
  /// interface ID, but not both.
  ///
  /// [privateIpAddress]: [EC2-VPC] The primary or secondary private IP address
  /// to associate with the Elastic IP address. If no private IP address is
  /// specified, the Elastic IP address is associated with the primary private
  /// IP address.
  Future<AssociateAddressResult> associateAddress(
      {String allocationId,
      String instanceId,
      String publicIp,
      bool allowReassociation,
      bool dryRun,
      String networkInterfaceId,
      String privateIpAddress}) async {
    var response_ = await _client.send('AssociateAddress', {
      if (allocationId != null) 'AllocationId': allocationId,
      if (instanceId != null) 'InstanceId': instanceId,
      if (publicIp != null) 'PublicIp': publicIp,
      if (allowReassociation != null) 'AllowReassociation': allowReassociation,
      if (dryRun != null) 'DryRun': dryRun,
      if (networkInterfaceId != null) 'NetworkInterfaceId': networkInterfaceId,
      if (privateIpAddress != null) 'PrivateIpAddress': privateIpAddress,
    });
    return AssociateAddressResult.fromJson(response_);
  }

  /// Associates a target network with a Client VPN endpoint. A target network
  /// is a subnet in a VPC. You can associate multiple subnets from the same VPC
  /// with a Client VPN endpoint. You can associate only one subnet in each
  /// Availability Zone. We recommend that you associate at least two subnets to
  /// provide Availability Zone redundancy.
  ///
  /// [clientVpnEndpointId]: The ID of the Client VPN endpoint.
  ///
  /// [subnetId]: The ID of the subnet to associate with the Client VPN
  /// endpoint.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that you provide to
  /// ensure the idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<AssociateClientVpnTargetNetworkResult> associateClientVpnTargetNetwork(
      {@required String clientVpnEndpointId,
      @required String subnetId,
      String clientToken,
      bool dryRun}) async {
    var response_ = await _client.send('AssociateClientVpnTargetNetwork', {
      'ClientVpnEndpointId': clientVpnEndpointId,
      'SubnetId': subnetId,
      if (clientToken != null) 'ClientToken': clientToken,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return AssociateClientVpnTargetNetworkResult.fromJson(response_);
  }

  /// Associates a set of DHCP options (that you've previously created) with the
  /// specified VPC, or associates no DHCP options with the VPC.
  ///
  /// After you associate the options with the VPC, any existing instances and
  /// all new instances that you launch in that VPC use the options. You don't
  /// need to restart or relaunch the instances. They automatically pick up the
  /// changes within a few hours, depending on how frequently the instance
  /// renews its DHCP lease. You can explicitly renew the lease using the
  /// operating system on the instance.
  ///
  /// For more information, see
  /// [DHCP Options Sets](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_DHCP_Options.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [dhcpOptionsId]: The ID of the DHCP options set, or `default` to associate
  /// no DHCP options with the VPC.
  ///
  /// [vpcId]: The ID of the VPC.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> associateDhcpOptions(
      {@required String dhcpOptionsId,
      @required String vpcId,
      bool dryRun}) async {
    await _client.send('AssociateDhcpOptions', {
      'DhcpOptionsId': dhcpOptionsId,
      'VpcId': vpcId,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Associates an IAM instance profile with a running or stopped instance. You
  /// cannot associate more than one IAM instance profile with an instance.
  ///
  /// [iamInstanceProfile]: The IAM instance profile.
  ///
  /// [instanceId]: The ID of the instance.
  Future<AssociateIamInstanceProfileResult> associateIamInstanceProfile(
      {@required IamInstanceProfileSpecification iamInstanceProfile,
      @required String instanceId}) async {
    var response_ = await _client.send('AssociateIamInstanceProfile', {
      'IamInstanceProfile': iamInstanceProfile,
      'InstanceId': instanceId,
    });
    return AssociateIamInstanceProfileResult.fromJson(response_);
  }

  /// Associates a subnet with a route table. The subnet and route table must be
  /// in the same VPC. This association causes traffic originating from the
  /// subnet to be routed according to the routes in the route table. The action
  /// returns an association ID, which you need in order to disassociate the
  /// route table from the subnet later. A route table can be associated with
  /// multiple subnets.
  ///
  /// For more information, see
  /// [Route Tables](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Route_Tables.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [routeTableId]: The ID of the route table.
  ///
  /// [subnetId]: The ID of the subnet.
  Future<AssociateRouteTableResult> associateRouteTable(
      {bool dryRun,
      @required String routeTableId,
      @required String subnetId}) async {
    var response_ = await _client.send('AssociateRouteTable', {
      if (dryRun != null) 'DryRun': dryRun,
      'RouteTableId': routeTableId,
      'SubnetId': subnetId,
    });
    return AssociateRouteTableResult.fromJson(response_);
  }

  /// Associates a CIDR block with your subnet. You can only associate a single
  /// IPv6 CIDR block with your subnet. An IPv6 CIDR block must have a prefix
  /// length of /64.
  ///
  /// [ipv6CidrBlock]: The IPv6 CIDR block for your subnet. The subnet must have
  /// a /64 prefix length.
  ///
  /// [subnetId]: The ID of your subnet.
  Future<AssociateSubnetCidrBlockResult> associateSubnetCidrBlock(
      {@required String ipv6CidrBlock, @required String subnetId}) async {
    var response_ = await _client.send('AssociateSubnetCidrBlock', {
      'Ipv6CidrBlock': ipv6CidrBlock,
      'SubnetId': subnetId,
    });
    return AssociateSubnetCidrBlockResult.fromJson(response_);
  }

  /// Associates the specified attachment with the specified transit gateway
  /// route table. You can associate only one route table with an attachment.
  ///
  /// [transitGatewayRouteTableId]: The ID of the transit gateway route table.
  ///
  /// [transitGatewayAttachmentId]: The ID of the attachment.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<AssociateTransitGatewayRouteTableResult>
      associateTransitGatewayRouteTable(
          {@required String transitGatewayRouteTableId,
          @required String transitGatewayAttachmentId,
          bool dryRun}) async {
    var response_ = await _client.send('AssociateTransitGatewayRouteTable', {
      'TransitGatewayRouteTableId': transitGatewayRouteTableId,
      'TransitGatewayAttachmentId': transitGatewayAttachmentId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return AssociateTransitGatewayRouteTableResult.fromJson(response_);
  }

  /// Associates a CIDR block with your VPC. You can associate a secondary IPv4
  /// CIDR block, or you can associate an Amazon-provided IPv6 CIDR block. The
  /// IPv6 CIDR block size is fixed at /56.
  ///
  /// For more information about associating CIDR blocks with your VPC and
  /// applicable restrictions, see
  /// [VPC and Subnet Sizing](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#VPC_Sizing)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [amazonProvidedIpv6CidrBlock]: Requests an Amazon-provided IPv6 CIDR block
  /// with a /56 prefix length for the VPC. You cannot specify the range of IPv6
  /// addresses, or the size of the CIDR block.
  ///
  /// [cidrBlock]: An IPv4 CIDR block to associate with the VPC.
  ///
  /// [vpcId]: The ID of the VPC.
  Future<AssociateVpcCidrBlockResult> associateVpcCidrBlock(String vpcId,
      {bool amazonProvidedIpv6CidrBlock, String cidrBlock}) async {
    var response_ = await _client.send('AssociateVpcCidrBlock', {
      if (amazonProvidedIpv6CidrBlock != null)
        'AmazonProvidedIpv6CidrBlock': amazonProvidedIpv6CidrBlock,
      if (cidrBlock != null) 'CidrBlock': cidrBlock,
      'VpcId': vpcId,
    });
    return AssociateVpcCidrBlockResult.fromJson(response_);
  }

  /// Links an EC2-Classic instance to a ClassicLink-enabled VPC through one or
  /// more of the VPC's security groups. You cannot link an EC2-Classic instance
  /// to more than one VPC at a time. You can only link an instance that's in
  /// the `running` state. An instance is automatically unlinked from a VPC when
  /// it's stopped - you can link it to the VPC again when you restart it.
  ///
  /// After you've linked an instance, you cannot change the VPC security groups
  /// that are associated with it. To change the security groups, you must first
  /// unlink the instance, and then link it again.
  ///
  /// Linking your instance to a VPC is sometimes referred to as _attaching_
  /// your instance.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [groups]: The ID of one or more of the VPC's security groups. You cannot
  /// specify security groups from a different VPC.
  ///
  /// [instanceId]: The ID of an EC2-Classic instance to link to the
  /// ClassicLink-enabled VPC.
  ///
  /// [vpcId]: The ID of a ClassicLink-enabled VPC.
  Future<AttachClassicLinkVpcResult> attachClassicLinkVpc(
      {bool dryRun,
      @required List<String> groups,
      @required String instanceId,
      @required String vpcId}) async {
    var response_ = await _client.send('AttachClassicLinkVpc', {
      if (dryRun != null) 'DryRun': dryRun,
      'Groups': groups,
      'InstanceId': instanceId,
      'VpcId': vpcId,
    });
    return AttachClassicLinkVpcResult.fromJson(response_);
  }

  /// Attaches an internet gateway to a VPC, enabling connectivity between the
  /// internet and the VPC. For more information about your VPC and internet
  /// gateway, see the
  /// [Amazon Virtual Private Cloud User Guide](https://docs.aws.amazon.com/vpc/latest/userguide/).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [internetGatewayId]: The ID of the internet gateway.
  ///
  /// [vpcId]: The ID of the VPC.
  Future<void> attachInternetGateway(
      {bool dryRun,
      @required String internetGatewayId,
      @required String vpcId}) async {
    await _client.send('AttachInternetGateway', {
      if (dryRun != null) 'DryRun': dryRun,
      'InternetGatewayId': internetGatewayId,
      'VpcId': vpcId,
    });
  }

  /// Attaches a network interface to an instance.
  ///
  /// [deviceIndex]: The index of the device for the network interface
  /// attachment.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [instanceId]: The ID of the instance.
  ///
  /// [networkInterfaceId]: The ID of the network interface.
  Future<AttachNetworkInterfaceResult> attachNetworkInterface(
      {@required int deviceIndex,
      bool dryRun,
      @required String instanceId,
      @required String networkInterfaceId}) async {
    var response_ = await _client.send('AttachNetworkInterface', {
      'DeviceIndex': deviceIndex,
      if (dryRun != null) 'DryRun': dryRun,
      'InstanceId': instanceId,
      'NetworkInterfaceId': networkInterfaceId,
    });
    return AttachNetworkInterfaceResult.fromJson(response_);
  }

  /// Attaches an EBS volume to a running or stopped instance and exposes it to
  /// the instance with the specified device name.
  ///
  /// Encrypted EBS volumes must be attached to instances that support Amazon
  /// EBS encryption. For more information, see
  /// [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// After you attach an EBS volume, you must make it available. For more
  /// information, see
  /// [Making an EBS Volume Available For Use](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-using-volumes.html).
  ///
  /// If a volume has an AWS Marketplace product code:
  ///
  /// *   The volume can be attached only to a stopped instance.
  ///
  /// *   AWS Marketplace product codes are copied from the volume to the
  /// instance.
  ///
  /// *   You must be subscribed to the product.
  ///
  /// *   The instance type and operating system of the instance must support
  /// the product. For example, you can't detach a volume from a Windows
  /// instance and attach it to a Linux instance.
  ///
  ///
  /// For more information, see
  /// [Attaching Amazon EBS Volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-attaching-volume.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [device]: The device name (for example, `/dev/sdh` or `xvdh`).
  ///
  /// [instanceId]: The ID of the instance.
  ///
  /// [volumeId]: The ID of the EBS volume. The volume and instance must be
  /// within the same Availability Zone.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<VolumeAttachment> attachVolume(
      {@required String device,
      @required String instanceId,
      @required String volumeId,
      bool dryRun}) async {
    var response_ = await _client.send('AttachVolume', {
      'Device': device,
      'InstanceId': instanceId,
      'VolumeId': volumeId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return VolumeAttachment.fromJson(response_);
  }

  /// Attaches a virtual private gateway to a VPC. You can attach one virtual
  /// private gateway to one VPC at a time.
  ///
  /// For more information, see
  /// [AWS Site-to-Site VPN](https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html)
  /// in the _AWS Site-to-Site VPN User Guide_.
  ///
  /// [vpcId]: The ID of the VPC.
  ///
  /// [vpnGatewayId]: The ID of the virtual private gateway.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<AttachVpnGatewayResult> attachVpnGateway(
      {@required String vpcId,
      @required String vpnGatewayId,
      bool dryRun}) async {
    var response_ = await _client.send('AttachVpnGateway', {
      'VpcId': vpcId,
      'VpnGatewayId': vpnGatewayId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return AttachVpnGatewayResult.fromJson(response_);
  }

  /// Adds an ingress authorization rule to a Client VPN endpoint. Ingress
  /// authorization rules act as firewall rules that grant access to networks.
  /// You must configure ingress authorization rules to enable clients to access
  /// resources in AWS or on-premises networks.
  ///
  /// [clientVpnEndpointId]: The ID of the Client VPN endpoint.
  ///
  /// [targetNetworkCidr]: The IPv4 address range, in CIDR notation, of the
  /// network for which access is being authorized.
  ///
  /// [accessGroupId]: The ID of the Active Directory group to grant access.
  ///
  /// [authorizeAllGroups]: Indicates whether to grant access to all clients.
  /// Use `true` to grant all clients who successfully establish a VPN
  /// connection access to the network.
  ///
  /// [description]: A brief description of the authorization rule.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that you provide to
  /// ensure the idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<AuthorizeClientVpnIngressResult> authorizeClientVpnIngress(
      {@required String clientVpnEndpointId,
      @required String targetNetworkCidr,
      String accessGroupId,
      bool authorizeAllGroups,
      String description,
      String clientToken,
      bool dryRun}) async {
    var response_ = await _client.send('AuthorizeClientVpnIngress', {
      'ClientVpnEndpointId': clientVpnEndpointId,
      'TargetNetworkCidr': targetNetworkCidr,
      if (accessGroupId != null) 'AccessGroupId': accessGroupId,
      if (authorizeAllGroups != null) 'AuthorizeAllGroups': authorizeAllGroups,
      if (description != null) 'Description': description,
      if (clientToken != null) 'ClientToken': clientToken,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return AuthorizeClientVpnIngressResult.fromJson(response_);
  }

  /// [VPC only] Adds the specified egress rules to a security group for use
  /// with a VPC.
  ///
  /// An outbound rule permits instances to send traffic to the specified IPv4
  /// or IPv6 CIDR address ranges, or to the instances associated with the
  /// specified destination security groups.
  ///
  /// You specify a protocol for each rule (for example, TCP). For the TCP and
  /// UDP protocols, you must also specify the destination port or port range.
  /// For the ICMP protocol, you must also specify the ICMP type and code. You
  /// can use -1 for the type or code to mean all types or all codes.
  ///
  /// Rule changes are propagated to affected instances as quickly as possible.
  /// However, a small delay might occur.
  ///
  /// For more information about VPC security group limits, see
  /// [Amazon VPC Limits](https://docs.aws.amazon.com/vpc/latest/userguide/amazon-vpc-limits.html).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [groupId]: The ID of the security group.
  ///
  /// [ipPermissions]: The sets of IP permissions. You can't specify a
  /// destination security group and a CIDR IP address range in the same set of
  /// permissions.
  ///
  /// [cidrIp]: Not supported. Use a set of IP permissions to specify the CIDR.
  ///
  /// [fromPort]: Not supported. Use a set of IP permissions to specify the
  /// port.
  ///
  /// [ipProtocol]: Not supported. Use a set of IP permissions to specify the
  /// protocol name or number.
  ///
  /// [toPort]: Not supported. Use a set of IP permissions to specify the port.
  ///
  /// [sourceSecurityGroupName]: Not supported. Use a set of IP permissions to
  /// specify a destination security group.
  ///
  /// [sourceSecurityGroupOwnerId]: Not supported. Use a set of IP permissions
  /// to specify a destination security group.
  Future<void> authorizeSecurityGroupEgress(String groupId,
      {bool dryRun,
      List<IpPermission> ipPermissions,
      String cidrIp,
      int fromPort,
      String ipProtocol,
      int toPort,
      String sourceSecurityGroupName,
      String sourceSecurityGroupOwnerId}) async {
    await _client.send('AuthorizeSecurityGroupEgress', {
      if (dryRun != null) 'DryRun': dryRun,
      'GroupId': groupId,
      if (ipPermissions != null) 'IpPermissions': ipPermissions,
      if (cidrIp != null) 'CidrIp': cidrIp,
      if (fromPort != null) 'FromPort': fromPort,
      if (ipProtocol != null) 'IpProtocol': ipProtocol,
      if (toPort != null) 'ToPort': toPort,
      if (sourceSecurityGroupName != null)
        'SourceSecurityGroupName': sourceSecurityGroupName,
      if (sourceSecurityGroupOwnerId != null)
        'SourceSecurityGroupOwnerId': sourceSecurityGroupOwnerId,
    });
  }

  /// Adds the specified ingress rules to a security group.
  ///
  /// An inbound rule permits instances to receive traffic from the specified
  /// IPv4 or IPv6 CIDR address ranges, or from the instances associated with
  /// the specified destination security groups.
  ///
  /// You specify a protocol for each rule (for example, TCP). For TCP and UDP,
  /// you must also specify the destination port or port range. For ICMP/ICMPv6,
  /// you must also specify the ICMP/ICMPv6 type and code. You can use -1 to
  /// mean all types or all codes.
  ///
  /// Rule changes are propagated to instances within the security group as
  /// quickly as possible. However, a small delay might occur.
  ///
  /// For more information about VPC security group limits, see
  /// [Amazon VPC Limits](https://docs.aws.amazon.com/vpc/latest/userguide/amazon-vpc-limits.html).
  ///
  /// [cidrIp]: The IPv4 address range, in CIDR format. You can't specify this
  /// parameter when specifying a source security group. To specify an IPv6
  /// address range, use a set of IP permissions.
  ///
  /// Alternatively, use a set of IP permissions to specify multiple rules and a
  /// description for the rule.
  ///
  /// [fromPort]: The start of port range for the TCP and UDP protocols, or an
  /// ICMP type number. For the ICMP type number, use `-1` to specify all types.
  /// If you specify all ICMP types, you must specify all codes.
  ///
  /// Alternatively, use a set of IP permissions to specify multiple rules and a
  /// description for the rule.
  ///
  /// [groupId]: The ID of the security group. You must specify either the
  /// security group ID or the security group name in the request. For security
  /// groups in a nondefault VPC, you must specify the security group ID.
  ///
  /// [groupName]: [EC2-Classic, default VPC] The name of the security group.
  /// You must specify either the security group ID or the security group name
  /// in the request.
  ///
  /// [ipPermissions]: The sets of IP permissions.
  ///
  /// [ipProtocol]: The IP protocol name (`tcp`, `udp`, `icmp`) or number (see
  /// [Protocol Numbers](http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)).
  /// To specify `icmpv6`, use a set of IP permissions.
  ///
  /// [VPC only] Use `-1` to specify all protocols. If you specify `-1` or a
  /// protocol other than `tcp`, `udp`, or `icmp`, traffic on all ports is
  /// allowed, regardless of any ports you specify.
  ///
  /// Alternatively, use a set of IP permissions to specify multiple rules and a
  /// description for the rule.
  ///
  /// [sourceSecurityGroupName]: [EC2-Classic, default VPC] The name of the
  /// source security group. You can't specify this parameter in combination
  /// with the following parameters: the CIDR IP address range, the start of the
  /// port range, the IP protocol, and the end of the port range. Creates rules
  /// that grant full ICMP, UDP, and TCP access. To create a rule with a
  /// specific IP protocol and port range, use a set of IP permissions instead.
  /// For EC2-VPC, the source security group must be in the same VPC.
  ///
  /// [sourceSecurityGroupOwnerId]: [nondefault VPC] The AWS account ID for the
  /// source security group, if the source security group is in a different
  /// account. You can't specify this parameter in combination with the
  /// following parameters: the CIDR IP address range, the IP protocol, the
  /// start of the port range, and the end of the port range. Creates rules that
  /// grant full ICMP, UDP, and TCP access. To create a rule with a specific IP
  /// protocol and port range, use a set of IP permissions instead.
  ///
  /// [toPort]: The end of port range for the TCP and UDP protocols, or an ICMP
  /// code number. For the ICMP code number, use `-1` to specify all codes. If
  /// you specify all ICMP types, you must specify all codes.
  ///
  /// Alternatively, use a set of IP permissions to specify multiple rules and a
  /// description for the rule.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> authorizeSecurityGroupIngress(
      {String cidrIp,
      int fromPort,
      String groupId,
      String groupName,
      List<IpPermission> ipPermissions,
      String ipProtocol,
      String sourceSecurityGroupName,
      String sourceSecurityGroupOwnerId,
      int toPort,
      bool dryRun}) async {
    await _client.send('AuthorizeSecurityGroupIngress', {
      if (cidrIp != null) 'CidrIp': cidrIp,
      if (fromPort != null) 'FromPort': fromPort,
      if (groupId != null) 'GroupId': groupId,
      if (groupName != null) 'GroupName': groupName,
      if (ipPermissions != null) 'IpPermissions': ipPermissions,
      if (ipProtocol != null) 'IpProtocol': ipProtocol,
      if (sourceSecurityGroupName != null)
        'SourceSecurityGroupName': sourceSecurityGroupName,
      if (sourceSecurityGroupOwnerId != null)
        'SourceSecurityGroupOwnerId': sourceSecurityGroupOwnerId,
      if (toPort != null) 'ToPort': toPort,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Bundles an Amazon instance store-backed Windows instance.
  ///
  /// During bundling, only the root device volume (C:) is bundled. Data on
  /// other instance store volumes is not preserved.
  ///
  ///
  ///
  /// This action is not applicable for Linux/Unix instances or Windows
  /// instances that are backed by Amazon EBS.
  ///
  /// [instanceId]: The ID of the instance to bundle.
  ///
  /// Type: String
  ///
  /// Default: None
  ///
  /// Required: Yes
  ///
  /// [storage]: The bucket in which to store the AMI. You can specify a bucket
  /// that you already own or a new bucket that Amazon EC2 creates on your
  /// behalf. If you specify a bucket that belongs to someone else, Amazon EC2
  /// returns an error.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<BundleInstanceResult> bundleInstance(
      {@required String instanceId,
      @required Storage storage,
      bool dryRun}) async {
    var response_ = await _client.send('BundleInstance', {
      'InstanceId': instanceId,
      'Storage': storage,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return BundleInstanceResult.fromJson(response_);
  }

  /// Cancels a bundling operation for an instance store-backed Windows
  /// instance.
  ///
  /// [bundleId]: The ID of the bundle task.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CancelBundleTaskResult> cancelBundleTask(String bundleId,
      {bool dryRun}) async {
    var response_ = await _client.send('CancelBundleTask', {
      'BundleId': bundleId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CancelBundleTaskResult.fromJson(response_);
  }

  /// Cancels the specified Capacity Reservation, releases the reserved
  /// capacity, and changes the Capacity Reservation's state to `cancelled`.
  ///
  /// Instances running in the reserved capacity continue running until you stop
  /// them. Stopped instances that target the Capacity Reservation can no longer
  /// launch. Modify these instances to either target a different Capacity
  /// Reservation, launch On-Demand Instance capacity, or run in any open
  /// Capacity Reservation that has matching attributes and sufficient capacity.
  ///
  /// [capacityReservationId]: The ID of the Capacity Reservation to be
  /// cancelled.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CancelCapacityReservationResult> cancelCapacityReservation(
      String capacityReservationId,
      {bool dryRun}) async {
    var response_ = await _client.send('CancelCapacityReservation', {
      'CapacityReservationId': capacityReservationId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CancelCapacityReservationResult.fromJson(response_);
  }

  /// Cancels an active conversion task. The task can be the import of an
  /// instance or volume. The action removes all artifacts of the conversion,
  /// including a partially uploaded volume or instance. If the conversion is
  /// complete or is in the process of transferring the final disk image, the
  /// command fails and returns an exception.
  ///
  /// For more information, see
  /// [Importing a Virtual Machine Using the Amazon EC2 CLI](https://docs.aws.amazon.com/AWSEC2/latest/CommandLineReference/ec2-cli-vmimport-export.html).
  ///
  /// [conversionTaskId]: The ID of the conversion task.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [reasonMessage]: The reason for canceling the conversion task.
  Future<void> cancelConversionTask(String conversionTaskId,
      {bool dryRun, String reasonMessage}) async {
    await _client.send('CancelConversionTask', {
      'ConversionTaskId': conversionTaskId,
      if (dryRun != null) 'DryRun': dryRun,
      if (reasonMessage != null) 'ReasonMessage': reasonMessage,
    });
  }

  /// Cancels an active export task. The request removes all artifacts of the
  /// export, including any partially-created Amazon S3 objects. If the export
  /// task is complete or is in the process of transferring the final disk
  /// image, the command fails and returns an error.
  ///
  /// [exportTaskId]: The ID of the export task. This is the ID returned by
  /// `CreateInstanceExportTask`.
  Future<void> cancelExportTask(String exportTaskId) async {
    await _client.send('CancelExportTask', {
      'ExportTaskId': exportTaskId,
    });
  }

  /// Cancels an in-process import virtual machine or import snapshot task.
  ///
  /// [cancelReason]: The reason for canceling the task.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [importTaskId]: The ID of the import image or import snapshot task to be
  /// canceled.
  Future<CancelImportTaskResult> cancelImportTask(
      {String cancelReason, bool dryRun, String importTaskId}) async {
    var response_ = await _client.send('CancelImportTask', {
      if (cancelReason != null) 'CancelReason': cancelReason,
      if (dryRun != null) 'DryRun': dryRun,
      if (importTaskId != null) 'ImportTaskId': importTaskId,
    });
    return CancelImportTaskResult.fromJson(response_);
  }

  /// Cancels the specified Reserved Instance listing in the Reserved Instance
  /// Marketplace.
  ///
  /// For more information, see
  /// [Reserved Instance Marketplace](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-market-general.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [reservedInstancesListingId]: The ID of the Reserved Instance listing.
  Future<CancelReservedInstancesListingResult> cancelReservedInstancesListing(
      String reservedInstancesListingId) async {
    var response_ = await _client.send('CancelReservedInstancesListing', {
      'ReservedInstancesListingId': reservedInstancesListingId,
    });
    return CancelReservedInstancesListingResult.fromJson(response_);
  }

  /// Cancels the specified Spot Fleet requests.
  ///
  /// After you cancel a Spot Fleet request, the Spot Fleet launches no new Spot
  /// Instances. You must specify whether the Spot Fleet should also terminate
  /// its Spot Instances. If you terminate the instances, the Spot Fleet request
  /// enters the `cancelled_terminating` state. Otherwise, the Spot Fleet
  /// request enters the `cancelled_running` state and the instances continue to
  /// run until they are interrupted or you terminate them manually.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [spotFleetRequestIds]: The IDs of the Spot Fleet requests.
  ///
  /// [terminateInstances]: Indicates whether to terminate instances for a Spot
  /// Fleet request if it is canceled successfully.
  Future<CancelSpotFleetRequestsResponse> cancelSpotFleetRequests(
      {bool dryRun,
      @required List<String> spotFleetRequestIds,
      @required bool terminateInstances}) async {
    var response_ = await _client.send('CancelSpotFleetRequests', {
      if (dryRun != null) 'DryRun': dryRun,
      'SpotFleetRequestIds': spotFleetRequestIds,
      'TerminateInstances': terminateInstances,
    });
    return CancelSpotFleetRequestsResponse.fromJson(response_);
  }

  /// Cancels one or more Spot Instance requests.
  ///
  ///
  ///
  /// Canceling a Spot Instance request does not terminate running Spot
  /// Instances associated with the request.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [spotInstanceRequestIds]: One or more Spot Instance request IDs.
  Future<CancelSpotInstanceRequestsResult> cancelSpotInstanceRequests(
      List<String> spotInstanceRequestIds,
      {bool dryRun}) async {
    var response_ = await _client.send('CancelSpotInstanceRequests', {
      if (dryRun != null) 'DryRun': dryRun,
      'SpotInstanceRequestIds': spotInstanceRequestIds,
    });
    return CancelSpotInstanceRequestsResult.fromJson(response_);
  }

  /// Determines whether a product code is associated with an instance. This
  /// action can only be used by the owner of the product code. It is useful
  /// when a product code owner must verify whether another user's instance is
  /// eligible for support.
  ///
  /// [instanceId]: The ID of the instance.
  ///
  /// [productCode]: The product code. This must be a product code that you own.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ConfirmProductInstanceResult> confirmProductInstance(
      {@required String instanceId,
      @required String productCode,
      bool dryRun}) async {
    var response_ = await _client.send('ConfirmProductInstance', {
      'InstanceId': instanceId,
      'ProductCode': productCode,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ConfirmProductInstanceResult.fromJson(response_);
  }

  /// Copies the specified Amazon FPGA Image (AFI) to the current Region.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [sourceFpgaImageId]: The ID of the source AFI.
  ///
  /// [description]: The description for the new AFI.
  ///
  /// [name]: The name for the new AFI. The default is the name of the source
  /// AFI.
  ///
  /// [sourceRegion]: The Region that contains the source AFI.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that you provide to
  /// ensure the idempotency of the request. For more information, see
  /// [Ensuring Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
  Future<CopyFpgaImageResult> copyFpgaImage(
      {bool dryRun,
      @required String sourceFpgaImageId,
      String description,
      String name,
      @required String sourceRegion,
      String clientToken}) async {
    var response_ = await _client.send('CopyFpgaImage', {
      if (dryRun != null) 'DryRun': dryRun,
      'SourceFpgaImageId': sourceFpgaImageId,
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
      'SourceRegion': sourceRegion,
      if (clientToken != null) 'ClientToken': clientToken,
    });
    return CopyFpgaImageResult.fromJson(response_);
  }

  /// Initiates the copy of an AMI from the specified source Region to the
  /// current Region. You specify the destination Region by using its endpoint
  /// when making the request.
  ///
  /// Copies of encrypted backing snapshots for the AMI are encrypted. Copies of
  /// unencrypted backing snapshots remain unencrypted, unless you set
  /// `Encrypted` during the copy operation. You cannot create an unencrypted
  /// copy of an encrypted backing snapshot.
  ///
  /// For more information about the prerequisites and limits when copying an
  /// AMI, see
  /// [Copying an AMI](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/CopyingAMIs.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [clientToken]: Unique, case-sensitive identifier you provide to ensure
  /// idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [description]: A description for the new AMI in the destination Region.
  ///
  /// [encrypted]: Specifies whether the destination snapshots of the copied
  /// image should be encrypted. You can encrypt a copy of an unencrypted
  /// snapshot, but you cannot create an unencrypted copy of an encrypted
  /// snapshot. The default CMK for EBS is used unless you specify a non-default
  /// AWS Key Management Service (AWS KMS) CMK using `KmsKeyId`. For more
  /// information, see
  /// [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [kmsKeyId]: An identifier for the AWS Key Management Service (AWS KMS)
  /// customer master key (CMK) to use when creating the encrypted volume. This
  /// parameter is only required if you want to use a non-default CMK; if this
  /// parameter is not specified, the default CMK for EBS is used. If a
  /// `KmsKeyId` is specified, the `Encrypted` flag must also be set.
  ///
  /// To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name,
  /// or alias ARN. When using an alias name, prefix it with "alias/". For
  /// example:
  ///
  /// *   Key ID: `1234abcd-12ab-34cd-56ef-1234567890ab`
  ///
  /// *   Key ARN:
  /// `arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab`
  ///
  /// *   Alias name: `alias/ExampleAlias`
  ///
  /// *   Alias ARN: `arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias`
  ///
  ///
  /// AWS parses `KmsKeyId` asynchronously, meaning that the action you call may
  /// appear to complete even though you provided an invalid identifier. This
  /// action will eventually report failure.
  ///
  /// The specified CMK must exist in the Region that the snapshot is being
  /// copied to.
  ///
  /// [name]: The name of the new AMI in the destination Region.
  ///
  /// [sourceImageId]: The ID of the AMI to copy.
  ///
  /// [sourceRegion]: The name of the Region that contains the AMI to copy.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CopyImageResult> copyImage(
      {String clientToken,
      String description,
      bool encrypted,
      String kmsKeyId,
      @required String name,
      @required String sourceImageId,
      @required String sourceRegion,
      bool dryRun}) async {
    var response_ = await _client.send('CopyImage', {
      if (clientToken != null) 'ClientToken': clientToken,
      if (description != null) 'Description': description,
      if (encrypted != null) 'Encrypted': encrypted,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      'Name': name,
      'SourceImageId': sourceImageId,
      'SourceRegion': sourceRegion,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CopyImageResult.fromJson(response_);
  }

  /// Copies a point-in-time snapshot of an EBS volume and stores it in Amazon
  /// S3. You can copy the snapshot within the same Region or from one Region to
  /// another. You can use the snapshot to create EBS volumes or Amazon Machine
  /// Images (AMIs).
  ///
  /// Copies of encrypted EBS snapshots remain encrypted. Copies of unencrypted
  /// snapshots remain unencrypted, unless you enable encryption for the
  /// snapshot copy operation. By default, encrypted snapshot copies use the
  /// default AWS Key Management Service (AWS KMS) customer master key (CMK);
  /// however, you can specify a different CMK.
  ///
  /// To copy an encrypted snapshot that has been shared from another account,
  /// you must have permissions for the CMK used to encrypt the snapshot.
  ///
  /// Snapshots created by copying another snapshot have an arbitrary volume ID
  /// that should not be used for any purpose.
  ///
  /// For more information, see
  /// [Copying an Amazon EBS Snapshot](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-copy-snapshot.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [description]: A description for the EBS snapshot.
  ///
  /// [destinationRegion]: The destination Region to use in the `PresignedUrl`
  /// parameter of a snapshot copy operation. This parameter is only valid for
  /// specifying the destination Region in a `PresignedUrl` parameter, where it
  /// is required.
  ///
  /// The snapshot copy is sent to the regional endpoint that you sent the HTTP
  /// request to (for example, `ec2.us-east-1.amazonaws.com`). With the AWS CLI,
  /// this is specified using the `--region` parameter or the default Region in
  /// your AWS configuration file.
  ///
  /// [encrypted]: To encrypt a copy of an unencrypted snapshot if encryption by
  /// default is not enabled, enable encryption using this parameter. Otherwise,
  /// omit this parameter. Encrypted snapshots are encrypted, even if you omit
  /// this parameter and encryption by default is not enabled. You cannot set
  /// this parameter to false. For more information, see
  /// [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [kmsKeyId]: The identifier of the AWS Key Management Service (AWS KMS)
  /// customer master key (CMK) to use for Amazon EBS encryption. If this
  /// parameter is not specified, your AWS managed CMK for EBS is used. If
  /// `KmsKeyId` is specified, the encrypted state must be `true`.
  ///
  /// You can specify the CMK using any of the following:
  ///
  /// *   Key ID. For example, key/1234abcd-12ab-34cd-56ef-1234567890ab.
  ///
  /// *   Key alias. For example, alias/ExampleAlias.
  ///
  /// *   Key ARN. For example,
  /// arn:aws:kms:_us-east-1_:_012345678910_:key/_abcd1234-a123-456a-a12b-a123b4cd56ef_.
  ///
  /// *   Alias ARN. For example,
  /// arn:aws:kms:_us-east-1_:_012345678910_:alias/_ExampleAlias_.
  ///
  ///
  /// AWS authenticates the CMK asynchronously. Therefore, if you specify an ID,
  /// alias, or ARN that is not valid, the action can appear to complete, but
  /// eventually fails.
  ///
  /// [presignedUrl]: When you copy an encrypted source snapshot using the
  /// Amazon EC2 Query API, you must supply a pre-signed URL. This parameter is
  /// optional for unencrypted snapshots. For more information, see
  /// [Query Requests](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Query-Requests.html).
  ///
  /// The `PresignedUrl` should use the snapshot source endpoint, the
  /// `CopySnapshot` action, and include the `SourceRegion`, `SourceSnapshotId`,
  /// and `DestinationRegion` parameters. The `PresignedUrl` must be signed
  /// using AWS Signature Version 4. Because EBS snapshots are stored in Amazon
  /// S3, the signing algorithm for this parameter uses the same logic that is
  /// described in
  /// [Authenticating Requests by Using Query Parameters (AWS Signature Version 4)](https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html)
  /// in the _Amazon Simple Storage Service API Reference_. An invalid or
  /// improperly signed `PresignedUrl` will cause the copy operation to fail
  /// asynchronously, and the snapshot will move to an `error` state.
  ///
  /// [sourceRegion]: The ID of the Region that contains the snapshot to be
  /// copied.
  ///
  /// [sourceSnapshotId]: The ID of the EBS snapshot to copy.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CopySnapshotResult> copySnapshot(
      {String description,
      String destinationRegion,
      bool encrypted,
      String kmsKeyId,
      String presignedUrl,
      @required String sourceRegion,
      @required String sourceSnapshotId,
      bool dryRun}) async {
    var response_ = await _client.send('CopySnapshot', {
      if (description != null) 'Description': description,
      if (destinationRegion != null) 'DestinationRegion': destinationRegion,
      if (encrypted != null) 'Encrypted': encrypted,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      if (presignedUrl != null) 'PresignedUrl': presignedUrl,
      'SourceRegion': sourceRegion,
      'SourceSnapshotId': sourceSnapshotId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CopySnapshotResult.fromJson(response_);
  }

  /// Creates a new Capacity Reservation with the specified attributes.
  ///
  /// Capacity Reservations enable you to reserve capacity for your Amazon EC2
  /// instances in a specific Availability Zone for any duration. This gives you
  /// the flexibility to selectively add capacity reservations and still get the
  /// Regional RI discounts for that usage. By creating Capacity Reservations,
  /// you ensure that you always have access to Amazon EC2 capacity when you
  /// need it, for as long as you need it. For more information, see
  /// [Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-capacity-reservations.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// Your request to create a Capacity Reservation could fail if Amazon EC2
  /// does not have sufficient capacity to fulfill the request. If your request
  /// fails due to Amazon EC2 capacity constraints, either try again at a later
  /// time, try in a different Availability Zone, or request a smaller capacity
  /// reservation. If your application is flexible across instance types and
  /// sizes, try to create a Capacity Reservation with different instance
  /// attributes.
  ///
  /// Your request could also fail if the requested quantity exceeds your
  /// On-Demand Instance limit for the selected instance type. If your request
  /// fails due to limit constraints, increase your On-Demand Instance limit for
  /// the required instance type and try again. For more information about
  /// increasing your instance limits, see
  /// [Amazon EC2 Service Limits](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-resource-limits.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that you provide to
  /// ensure the idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// Constraint: Maximum 64 ASCII characters.
  ///
  /// [instanceType]: The instance type for which to reserve capacity. For more
  /// information, see
  /// [Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [instancePlatform]: The type of operating system for which to reserve
  /// capacity.
  ///
  /// [availabilityZone]: The Availability Zone in which to create the Capacity
  /// Reservation.
  ///
  /// [availabilityZoneId]: The ID of the Availability Zone in which to create
  /// the Capacity Reservation.
  ///
  /// [tenancy]: Indicates the tenancy of the Capacity Reservation. A Capacity
  /// Reservation can have one of the following tenancy settings:
  ///
  /// *    `default` - The Capacity Reservation is created on hardware that is
  /// shared with other AWS accounts.
  ///
  /// *    `dedicated` - The Capacity Reservation is created on single-tenant
  /// hardware that is dedicated to a single AWS account.
  ///
  /// [instanceCount]: The number of instances for which to reserve capacity.
  ///
  /// [ebsOptimized]: Indicates whether the Capacity Reservation supports
  /// EBS-optimized instances. This optimization provides dedicated throughput
  /// to Amazon EBS and an optimized configuration stack to provide optimal I/O
  /// performance. This optimization isn't available with all instance types.
  /// Additional usage charges apply when using an EBS- optimized instance.
  ///
  /// [ephemeralStorage]: Indicates whether the Capacity Reservation supports
  /// instances with temporary, block-level storage.
  ///
  /// [endDate]: The date and time at which the Capacity Reservation expires.
  /// When a Capacity Reservation expires, the reserved capacity is released and
  /// you can no longer launch instances into it. The Capacity Reservation's
  /// state changes to `expired` when it reaches its end date and time.
  ///
  /// You must provide an `EndDate` value if `EndDateType` is `limited`. Omit
  /// `EndDate` if `EndDateType` is `unlimited`.
  ///
  /// If the `EndDateType` is `limited`, the Capacity Reservation is cancelled
  /// within an hour from the specified time. For example, if you specify
  /// 5/31/2019, 13:30:55, the Capacity Reservation is guaranteed to end between
  /// 13:30:55 and 14:30:55 on 5/31/2019.
  ///
  /// [endDateType]: Indicates the way in which the Capacity Reservation ends. A
  /// Capacity Reservation can have one of the following end types:
  ///
  /// *    `unlimited` - The Capacity Reservation remains active until you
  /// explicitly cancel it. Do not provide an `EndDate` if the `EndDateType` is
  /// `unlimited`.
  ///
  /// *    `limited` - The Capacity Reservation expires automatically at a
  /// specified date and time. You must provide an `EndDate` value if the
  /// `EndDateType` value is `limited`.
  ///
  /// [instanceMatchCriteria]: Indicates the type of instance launches that the
  /// Capacity Reservation accepts. The options include:
  ///
  /// *    `open` - The Capacity Reservation automatically matches all instances
  /// that have matching attributes (instance type, platform, and Availability
  /// Zone). Instances that have matching attributes run in the Capacity
  /// Reservation automatically without specifying any additional parameters.
  ///
  /// *    `targeted` - The Capacity Reservation only accepts instances that
  /// have matching attributes (instance type, platform, and Availability Zone),
  /// and explicitly target the Capacity Reservation. This ensures that only
  /// permitted instances can use the reserved capacity.
  ///
  ///
  /// Default: `open`
  ///
  /// [tagSpecifications]: The tags to apply to the Capacity Reservation during
  /// launch.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CreateCapacityReservationResult> createCapacityReservation(
      {String clientToken,
      @required String instanceType,
      @required String instancePlatform,
      String availabilityZone,
      String availabilityZoneId,
      String tenancy,
      @required int instanceCount,
      bool ebsOptimized,
      bool ephemeralStorage,
      DateTime endDate,
      String endDateType,
      String instanceMatchCriteria,
      List<TagSpecification> tagSpecifications,
      bool dryRun}) async {
    var response_ = await _client.send('CreateCapacityReservation', {
      if (clientToken != null) 'ClientToken': clientToken,
      'InstanceType': instanceType,
      'InstancePlatform': instancePlatform,
      if (availabilityZone != null) 'AvailabilityZone': availabilityZone,
      if (availabilityZoneId != null) 'AvailabilityZoneId': availabilityZoneId,
      if (tenancy != null) 'Tenancy': tenancy,
      'InstanceCount': instanceCount,
      if (ebsOptimized != null) 'EbsOptimized': ebsOptimized,
      if (ephemeralStorage != null) 'EphemeralStorage': ephemeralStorage,
      if (endDate != null) 'EndDate': endDate,
      if (endDateType != null) 'EndDateType': endDateType,
      if (instanceMatchCriteria != null)
        'InstanceMatchCriteria': instanceMatchCriteria,
      if (tagSpecifications != null) 'TagSpecifications': tagSpecifications,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CreateCapacityReservationResult.fromJson(response_);
  }

  /// Creates a Client VPN endpoint. A Client VPN endpoint is the resource you
  /// create and configure to enable and manage client VPN sessions. It is the
  /// destination endpoint at which all client VPN sessions are terminated.
  ///
  /// [clientCidrBlock]: The IPv4 address range, in CIDR notation, from which to
  /// assign client IP addresses. The address range cannot overlap with the
  /// local CIDR of the VPC in which the associated subnet is located, or the
  /// routes that you add manually. The address range cannot be changed after
  /// the Client VPN endpoint has been created. The CIDR block should be /22 or
  /// greater.
  ///
  /// [serverCertificateArn]: The ARN of the server certificate. For more
  /// information, see the
  /// [AWS Certificate Manager User Guide](https://docs.aws.amazon.com/acm/latest/userguide/).
  ///
  /// [authenticationOptions]: Information about the authentication method to be
  /// used to authenticate clients.
  ///
  /// [connectionLogOptions]: Information about the client connection logging
  /// options.
  ///
  /// If you enable client connection logging, data about client connections is
  /// sent to a Cloudwatch Logs log stream. The following information is logged:
  ///
  /// *   Client connection requests
  ///
  /// *   Client connection results (successful and unsuccessful)
  ///
  /// *   Reasons for unsuccessful client connection requests
  ///
  /// *   Client connection termination time
  ///
  /// [dnsServers]: Information about the DNS servers to be used for DNS
  /// resolution. A Client VPN endpoint can have up to two DNS servers. If no
  /// DNS server is specified, the DNS address configured on the device is used
  /// for the DNS server.
  ///
  /// [transportProtocol]: The transport protocol to be used by the VPN session.
  ///
  /// Default value: `udp`
  ///
  /// [description]: A brief description of the Client VPN endpoint.
  ///
  /// [splitTunnel]: Indicates whether split-tunnel is enabled on the AWS Client
  /// VPN endpoint.
  ///
  /// By default, split-tunnel on a VPN endpoint is disabled.
  ///
  /// For information about split-tunnel VPN endpoints, see
  /// [Split-Tunnel AWS Client VPN Endpoint](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html)
  /// in the _AWS Client VPN Administrator Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that you provide to
  /// ensure the idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// [tagSpecifications]: The tags to apply to the Client VPN endpoint during
  /// creation.
  Future<CreateClientVpnEndpointResult> createClientVpnEndpoint(
      {@required String clientCidrBlock,
      @required String serverCertificateArn,
      @required List<ClientVpnAuthenticationRequest> authenticationOptions,
      @required ConnectionLogOptions connectionLogOptions,
      List<String> dnsServers,
      String transportProtocol,
      String description,
      bool splitTunnel,
      bool dryRun,
      String clientToken,
      List<TagSpecification> tagSpecifications}) async {
    var response_ = await _client.send('CreateClientVpnEndpoint', {
      'ClientCidrBlock': clientCidrBlock,
      'ServerCertificateArn': serverCertificateArn,
      'AuthenticationOptions': authenticationOptions,
      'ConnectionLogOptions': connectionLogOptions,
      if (dnsServers != null) 'DnsServers': dnsServers,
      if (transportProtocol != null) 'TransportProtocol': transportProtocol,
      if (description != null) 'Description': description,
      if (splitTunnel != null) 'SplitTunnel': splitTunnel,
      if (dryRun != null) 'DryRun': dryRun,
      if (clientToken != null) 'ClientToken': clientToken,
      if (tagSpecifications != null) 'TagSpecifications': tagSpecifications,
    });
    return CreateClientVpnEndpointResult.fromJson(response_);
  }

  /// Adds a route to a network to a Client VPN endpoint. Each Client VPN
  /// endpoint has a route table that describes the available destination
  /// network routes. Each route in the route table specifies the path for trac
  /// to specic resources or networks.
  ///
  /// [clientVpnEndpointId]: The ID of the Client VPN endpoint to which to add
  /// the route.
  ///
  /// [destinationCidrBlock]: The IPv4 address range, in CIDR notation, of the
  /// route destination. For example:
  ///
  /// *   To add a route for Internet access, enter `0.0.0.0/0`
  ///
  /// *   To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR
  /// range
  ///
  /// *   To add a route for an on-premises network, enter the AWS Site-to-Site
  /// VPN connection's IPv4 CIDR range
  ///
  ///
  /// Route address ranges cannot overlap with the CIDR range specified for
  /// client allocation.
  ///
  /// [targetVpcSubnetId]: The ID of the subnet through which you want to route
  /// traffic. The specified subnet must be an existing target network of the
  /// Client VPN endpoint.
  ///
  /// [description]: A brief description of the route.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that you provide to
  /// ensure the idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CreateClientVpnRouteResult> createClientVpnRoute(
      {@required String clientVpnEndpointId,
      @required String destinationCidrBlock,
      @required String targetVpcSubnetId,
      String description,
      String clientToken,
      bool dryRun}) async {
    var response_ = await _client.send('CreateClientVpnRoute', {
      'ClientVpnEndpointId': clientVpnEndpointId,
      'DestinationCidrBlock': destinationCidrBlock,
      'TargetVpcSubnetId': targetVpcSubnetId,
      if (description != null) 'Description': description,
      if (clientToken != null) 'ClientToken': clientToken,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CreateClientVpnRouteResult.fromJson(response_);
  }

  /// Provides information to AWS about your VPN customer gateway device. The
  /// customer gateway is the appliance at your end of the VPN connection. (The
  /// device on the AWS side of the VPN connection is the virtual private
  /// gateway.) You must provide the Internet-routable IP address of the
  /// customer gateway's external interface. The IP address must be static and
  /// can be behind a device performing network address translation (NAT).
  ///
  /// For devices that use Border Gateway Protocol (BGP), you can also provide
  /// the device's BGP Autonomous System Number (ASN). You can use an existing
  /// ASN assigned to your network. If you don't have an ASN already, you can
  /// use a private ASN (in the 64512 - 65534 range).
  ///
  ///  Amazon EC2 supports all 2-byte ASN numbers in the range of 1 - 65534,
  /// with the exception of 7224, which is reserved in the `us-east-1` Region,
  /// and 9059, which is reserved in the `eu-west-1` Region.
  ///
  /// For more information, see
  /// [AWS Site-to-Site VPN](https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html)
  /// in the _AWS Site-to-Site VPN User Guide_.
  ///
  ///
  ///
  /// You cannot create more than one customer gateway with the same VPN type,
  /// IP address, and BGP ASN parameter values. If you run an identical request
  /// more than one time, the first request creates the customer gateway, and
  /// subsequent requests return information about the existing customer
  /// gateway. The subsequent requests do not create new customer gateway
  /// resources.
  ///
  /// [bgpAsn]: For devices that support BGP, the customer gateway's BGP ASN.
  ///
  /// Default: 65000
  ///
  /// [publicIp]: The Internet-routable IP address for the customer gateway's
  /// outside interface. The address must be static.
  ///
  /// [certificateArn]: The Amazon Resource Name (ARN) for the customer gateway
  /// certificate.
  ///
  /// [type]: The type of VPN connection that this customer gateway supports
  /// (`ipsec.1`).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CreateCustomerGatewayResult> createCustomerGateway(
      {@required int bgpAsn,
      String publicIp,
      String certificateArn,
      @required String type,
      bool dryRun}) async {
    var response_ = await _client.send('CreateCustomerGateway', {
      'BgpAsn': bgpAsn,
      if (publicIp != null) 'PublicIp': publicIp,
      if (certificateArn != null) 'CertificateArn': certificateArn,
      'Type': type,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CreateCustomerGatewayResult.fromJson(response_);
  }

  /// Creates a default subnet with a size `/20` IPv4 CIDR block in the
  /// specified Availability Zone in your default VPC. You can have only one
  /// default subnet per Availability Zone. For more information, see
  /// [Creating a Default Subnet](https://docs.aws.amazon.com/vpc/latest/userguide/default-vpc.html#create-default-subnet)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [availabilityZone]: The Availability Zone in which to create the default
  /// subnet.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CreateDefaultSubnetResult> createDefaultSubnet(String availabilityZone,
      {bool dryRun}) async {
    var response_ = await _client.send('CreateDefaultSubnet', {
      'AvailabilityZone': availabilityZone,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CreateDefaultSubnetResult.fromJson(response_);
  }

  /// Creates a default VPC with a size `/16` IPv4 CIDR block and a default
  /// subnet in each Availability Zone. For more information about the
  /// components of a default VPC, see
  /// [Default VPC and Default Subnets](https://docs.aws.amazon.com/vpc/latest/userguide/default-vpc.html)
  /// in the _Amazon Virtual Private Cloud User Guide_. You cannot specify the
  /// components of the default VPC yourself.
  ///
  /// If you deleted your previous default VPC, you can create a default VPC.
  /// You cannot have more than one default VPC per Region.
  ///
  /// If your account supports EC2-Classic, you cannot use this action to create
  /// a default VPC in a Region that supports EC2-Classic. If you want a default
  /// VPC in a Region that supports EC2-Classic, see "I really want a default
  /// VPC for my existing EC2 account. Is that possible?" in the
  /// [Default VPCs FAQ](http://aws.amazon.com/vpc/faqs/#Default_VPCs).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CreateDefaultVpcResult> createDefaultVpc({bool dryRun}) async {
    var response_ = await _client.send('CreateDefaultVpc', {
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CreateDefaultVpcResult.fromJson(response_);
  }

  /// Creates a set of DHCP options for your VPC. After creating the set, you
  /// must associate it with the VPC, causing all existing and new instances
  /// that you launch in the VPC to use this set of DHCP options. The following
  /// are the individual DHCP options you can specify. For more information
  /// about the options, see [RFC 2132](http://www.ietf.org/rfc/rfc2132.txt).
  ///
  /// *    `domain-name-servers` - The IP addresses of up to four domain name
  /// servers, or AmazonProvidedDNS. The default DHCP option set specifies
  /// AmazonProvidedDNS. If specifying more than one domain name server, specify
  /// the IP addresses in a single parameter, separated by commas. To have your
  /// instance receive a custom DNS hostname as specified in `domain-name`, you
  /// must set `domain-name-servers` to a custom DNS server.
  ///
  /// *    `domain-name` - If you're using AmazonProvidedDNS in `us-east-1`,
  /// specify `ec2.internal`. If you're using AmazonProvidedDNS in another
  /// Region, specify `region.compute.internal` (for example,
  /// `ap-northeast-1.compute.internal`). Otherwise, specify a domain name (for
  /// example, `MyCompany.com`). This value is used to complete unqualified DNS
  /// hostnames. **Important**: Some Linux operating systems accept multiple
  /// domain names separated by spaces. However, Windows and other Linux
  /// operating systems treat the value as a single domain, which results in
  /// unexpected behavior. If your DHCP options set is associated with a VPC
  /// that has instances with multiple operating systems, specify only one
  /// domain name.
  ///
  /// *    `ntp-servers` - The IP addresses of up to four Network Time Protocol
  /// (NTP) servers.
  ///
  /// *    `netbios-name-servers` - The IP addresses of up to four NetBIOS name
  /// servers.
  ///
  /// *    `netbios-node-type` - The NetBIOS node type (1, 2, 4, or 8). We
  /// recommend that you specify 2 (broadcast and multicast are not currently
  /// supported). For more information about these node types, see
  /// [RFC 2132](http://www.ietf.org/rfc/rfc2132.txt).
  ///
  ///
  /// Your VPC automatically starts out with a set of DHCP options that includes
  /// only a DNS server that we provide (AmazonProvidedDNS). If you create a set
  /// of options, and if your VPC has an internet gateway, make sure to set the
  /// `domain-name-servers` option either to `AmazonProvidedDNS` or to a domain
  /// name server of your choice. For more information, see
  /// [DHCP Options Sets](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_DHCP_Options.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [dhcpConfigurations]: A DHCP configuration option.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CreateDhcpOptionsResult> createDhcpOptions(
      List<NewDhcpConfiguration> dhcpConfigurations,
      {bool dryRun}) async {
    var response_ = await _client.send('CreateDhcpOptions', {
      'DhcpConfigurations': dhcpConfigurations,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CreateDhcpOptionsResult.fromJson(response_);
  }

  /// [IPv6 only] Creates an egress-only internet gateway for your VPC. An
  /// egress-only internet gateway is used to enable outbound communication over
  /// IPv6 from instances in your VPC to the internet, and prevents hosts
  /// outside of your VPC from initiating an IPv6 connection with your instance.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that you provide to
  /// ensure the idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [vpcId]: The ID of the VPC for which to create the egress-only internet
  /// gateway.
  Future<CreateEgressOnlyInternetGatewayResult> createEgressOnlyInternetGateway(
      String vpcId,
      {String clientToken,
      bool dryRun}) async {
    var response_ = await _client.send('CreateEgressOnlyInternetGateway', {
      if (clientToken != null) 'ClientToken': clientToken,
      if (dryRun != null) 'DryRun': dryRun,
      'VpcId': vpcId,
    });
    return CreateEgressOnlyInternetGatewayResult.fromJson(response_);
  }

  /// Launches an EC2 Fleet.
  ///
  /// You can create a single EC2 Fleet that includes multiple launch
  /// specifications that vary by instance type, AMI, Availability Zone, or
  /// subnet.
  ///
  /// For more information, see
  /// [Launching an EC2 Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [clientToken]: Unique, case-sensitive identifier you provide to ensure the
  /// idempotency of the request. For more information, see
  /// [Ensuring Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// [spotOptions]: Describes the configuration of Spot Instances in an EC2
  /// Fleet.
  ///
  /// [onDemandOptions]: Describes the configuration of On-Demand Instances in
  /// an EC2 Fleet.
  ///
  /// [excessCapacityTerminationPolicy]: Indicates whether running instances
  /// should be terminated if the total target capacity of the EC2 Fleet is
  /// decreased below the current size of the EC2 Fleet.
  ///
  /// [launchTemplateConfigs]: The configuration for the EC2 Fleet.
  ///
  /// [targetCapacitySpecification]: The number of units to request.
  ///
  /// [terminateInstancesWithExpiration]: Indicates whether running instances
  /// should be terminated when the EC2 Fleet expires.
  ///
  /// [type]: The type of the request. By default, the EC2 Fleet places an
  /// asynchronous request for your desired capacity, and maintains it by
  /// replenishing interrupted Spot Instances (`maintain`). A value of `instant`
  /// places a synchronous one-time request, and returns errors for any
  /// instances that could not be launched. A value of `request` places an
  /// asynchronous one-time request without maintaining capacity or submitting
  /// requests in alternative capacity pools if capacity is unavailable. For
  /// more information, see
  /// [EC2 Fleet Request Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-configuration-strategies.html#ec2-fleet-request-type)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [validFrom]: The start date and time of the request, in UTC format (for
  /// example, _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z). The default is to start
  /// fulfilling the request immediately.
  ///
  /// [validUntil]: The end date and time of the request, in UTC format (for
  /// example, _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z). At this point, no new EC2
  /// Fleet requests are placed or able to fulfill the request. If no value is
  /// specified, the request remains until you cancel it.
  ///
  /// [replaceUnhealthyInstances]: Indicates whether EC2 Fleet should replace
  /// unhealthy instances.
  ///
  /// [tagSpecifications]: The key-value pair for tagging the EC2 Fleet request
  /// on creation. The value for `ResourceType` must be `fleet`, otherwise the
  /// fleet request fails. To tag instances at launch, specify the tags in the
  /// [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template).
  /// For information about tagging after launch, see
  /// [Tagging Your Resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources).
  Future<CreateFleetResult> createFleet(
      {bool dryRun,
      String clientToken,
      SpotOptionsRequest spotOptions,
      OnDemandOptionsRequest onDemandOptions,
      String excessCapacityTerminationPolicy,
      @required List<FleetLaunchTemplateConfigRequest> launchTemplateConfigs,
      @required TargetCapacitySpecificationRequest targetCapacitySpecification,
      bool terminateInstancesWithExpiration,
      String type,
      DateTime validFrom,
      DateTime validUntil,
      bool replaceUnhealthyInstances,
      List<TagSpecification> tagSpecifications}) async {
    var response_ = await _client.send('CreateFleet', {
      if (dryRun != null) 'DryRun': dryRun,
      if (clientToken != null) 'ClientToken': clientToken,
      if (spotOptions != null) 'SpotOptions': spotOptions,
      if (onDemandOptions != null) 'OnDemandOptions': onDemandOptions,
      if (excessCapacityTerminationPolicy != null)
        'ExcessCapacityTerminationPolicy': excessCapacityTerminationPolicy,
      'LaunchTemplateConfigs': launchTemplateConfigs,
      'TargetCapacitySpecification': targetCapacitySpecification,
      if (terminateInstancesWithExpiration != null)
        'TerminateInstancesWithExpiration': terminateInstancesWithExpiration,
      if (type != null) 'Type': type,
      if (validFrom != null) 'ValidFrom': validFrom,
      if (validUntil != null) 'ValidUntil': validUntil,
      if (replaceUnhealthyInstances != null)
        'ReplaceUnhealthyInstances': replaceUnhealthyInstances,
      if (tagSpecifications != null) 'TagSpecifications': tagSpecifications,
    });
    return CreateFleetResult.fromJson(response_);
  }

  /// Creates one or more flow logs to capture information about IP traffic for
  /// a specific network interface, subnet, or VPC.
  ///
  /// Flow log data for a monitored network interface is recorded as flow log
  /// records, which are log events consisting of fields that describe the
  /// traffic flow. For more information, see
  /// [Flow Log Records](https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// When publishing to CloudWatch Logs, flow log records are published to a
  /// log group, and each network interface has a unique log stream in the log
  /// group. When publishing to Amazon S3, flow log records for all of the
  /// monitored network interfaces are published to a single log file object
  /// that is stored in the specified bucket.
  ///
  /// For more information, see
  /// [VPC Flow Logs](https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that you provide to
  /// ensure the idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
  ///
  /// [deliverLogsPermissionArn]: The ARN for the IAM role that permits Amazon
  /// EC2 to publish flow logs to a CloudWatch Logs log group in your account.
  ///
  /// If you specify `LogDestinationType` as `s3`, do not specify
  /// `DeliverLogsPermissionArn` or `LogGroupName`.
  ///
  /// [logGroupName]: The name of a new or existing CloudWatch Logs log group
  /// where Amazon EC2 publishes your flow logs.
  ///
  /// If you specify `LogDestinationType` as `s3`, do not specify
  /// `DeliverLogsPermissionArn` or `LogGroupName`.
  ///
  /// [resourceIds]: The ID of the subnet, network interface, or VPC for which
  /// you want to create a flow log.
  ///
  /// Constraints: Maximum of 1000 resources
  ///
  /// [resourceType]: The type of resource for which to create the flow log. For
  /// example, if you specified a VPC ID for the `ResourceId` property, specify
  /// `VPC` for this property.
  ///
  /// [trafficType]: The type of traffic to log. You can log traffic that the
  /// resource accepts or rejects, or all traffic.
  ///
  /// [logDestinationType]: Specifies the type of destination to which the flow
  /// log data is to be published. Flow log data can be published to CloudWatch
  /// Logs or Amazon S3. To publish flow log data to CloudWatch Logs, specify
  /// `cloud-watch-logs`. To publish flow log data to Amazon S3, specify `s3`.
  ///
  /// If you specify `LogDestinationType` as `s3`, do not specify
  /// `DeliverLogsPermissionArn` or `LogGroupName`.
  ///
  /// Default: `cloud-watch-logs`
  ///
  /// [logDestination]: Specifies the destination to which the flow log data is
  /// to be published. Flow log data can be published to a CloudWatch Logs log
  /// group or an Amazon S3 bucket. The value specified for this parameter
  /// depends on the value specified for `LogDestinationType`.
  ///
  /// If LogDestinationType is not specified or `cloud-watch-logs`, specify the
  /// Amazon Resource Name (ARN) of the CloudWatch Logs log group.
  ///
  /// If LogDestinationType is `s3`, specify the ARN of the Amazon S3 bucket.
  /// You can also specify a subfolder in the bucket. To specify a subfolder in
  /// the bucket, use the following ARN format: `bucket_ARN/subfolder_name/`.
  /// For example, to specify a subfolder named `my-logs` in a bucket named
  /// `my-bucket`, use the following ARN: `arn:aws:s3:::my-bucket/my-logs/`. You
  /// cannot use `AWSLogs` as a subfolder name. This is a reserved term.
  ///
  /// [logFormat]: The fields to include in the flow log record, in the order in
  /// which they should appear. For a list of available fields, see
  /// [Flow Log Records](https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records).
  /// If you omit this parameter, the flow log is created using the default
  /// format. If you specify this parameter, you must specify at least one
  /// field.
  ///
  /// Specify the fields using the `${field-id}` format, separated by spaces.
  /// For the AWS CLI, use single quotation marks (' ') to surround the
  /// parameter value.
  ///
  /// Only applicable to flow logs that are published to an Amazon S3 bucket.
  Future<CreateFlowLogsResult> createFlowLogs(
      {bool dryRun,
      String clientToken,
      String deliverLogsPermissionArn,
      String logGroupName,
      @required List<String> resourceIds,
      @required String resourceType,
      @required String trafficType,
      String logDestinationType,
      String logDestination,
      String logFormat}) async {
    var response_ = await _client.send('CreateFlowLogs', {
      if (dryRun != null) 'DryRun': dryRun,
      if (clientToken != null) 'ClientToken': clientToken,
      if (deliverLogsPermissionArn != null)
        'DeliverLogsPermissionArn': deliverLogsPermissionArn,
      if (logGroupName != null) 'LogGroupName': logGroupName,
      'ResourceIds': resourceIds,
      'ResourceType': resourceType,
      'TrafficType': trafficType,
      if (logDestinationType != null) 'LogDestinationType': logDestinationType,
      if (logDestination != null) 'LogDestination': logDestination,
      if (logFormat != null) 'LogFormat': logFormat,
    });
    return CreateFlowLogsResult.fromJson(response_);
  }

  /// Creates an Amazon FPGA Image (AFI) from the specified design checkpoint
  /// (DCP).
  ///
  /// The create operation is asynchronous. To verify that the AFI is ready for
  /// use, check the output logs.
  ///
  /// An AFI contains the FPGA bitstream that is ready to download to an FPGA.
  /// You can securely deploy an AFI on multiple FPGA-accelerated instances. For
  /// more information, see the
  /// [AWS FPGA Hardware Development Kit](https://github.com/aws/aws-fpga/).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [inputStorageLocation]: The location of the encrypted design checkpoint in
  /// Amazon S3. The input must be a tarball.
  ///
  /// [logsStorageLocation]: The location in Amazon S3 for the output logs.
  ///
  /// [description]: A description for the AFI.
  ///
  /// [name]: A name for the AFI.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that you provide to
  /// ensure the idempotency of the request. For more information, see
  /// [Ensuring Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
  Future<CreateFpgaImageResult> createFpgaImage(
      StorageLocation inputStorageLocation,
      {bool dryRun,
      StorageLocation logsStorageLocation,
      String description,
      String name,
      String clientToken}) async {
    var response_ = await _client.send('CreateFpgaImage', {
      if (dryRun != null) 'DryRun': dryRun,
      'InputStorageLocation': inputStorageLocation,
      if (logsStorageLocation != null)
        'LogsStorageLocation': logsStorageLocation,
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
      if (clientToken != null) 'ClientToken': clientToken,
    });
    return CreateFpgaImageResult.fromJson(response_);
  }

  /// Creates an Amazon EBS-backed AMI from an Amazon EBS-backed instance that
  /// is either running or stopped.
  ///
  /// If you customized your instance with instance store volumes or EBS volumes
  /// in addition to the root device volume, the new AMI contains block device
  /// mapping information for those volumes. When you launch an instance from
  /// this new AMI, the instance automatically launches with those additional
  /// volumes.
  ///
  /// For more information, see
  /// [Creating Amazon EBS-Backed Linux AMIs](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/creating-an-ami-ebs.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [blockDeviceMappings]: The block device mappings. This parameter cannot be
  /// used to modify the encryption status of existing volumes or snapshots. To
  /// create an AMI with encrypted snapshots, use the CopyImage action.
  ///
  /// [description]: A description for the new image.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [instanceId]: The ID of the instance.
  ///
  /// [name]: A name for the new image.
  ///
  /// Constraints: 3-128 alphanumeric characters, parentheses (()), square
  /// brackets ([]), spaces ( ), periods (.), slashes (/), dashes (-), single
  /// quotes ('), at-signs (@), or underscores(_)
  ///
  /// [noReboot]: By default, Amazon EC2 attempts to shut down and reboot the
  /// instance before creating the image. If the 'No Reboot' option is set,
  /// Amazon EC2 doesn't shut down the instance before creating the image. When
  /// this option is used, file system integrity on the created image can't be
  /// guaranteed.
  Future<CreateImageResult> createImage(
      {List<BlockDeviceMapping> blockDeviceMappings,
      String description,
      bool dryRun,
      @required String instanceId,
      @required String name,
      bool noReboot}) async {
    var response_ = await _client.send('CreateImage', {
      if (blockDeviceMappings != null)
        'BlockDeviceMappings': blockDeviceMappings,
      if (description != null) 'Description': description,
      if (dryRun != null) 'DryRun': dryRun,
      'InstanceId': instanceId,
      'Name': name,
      if (noReboot != null) 'NoReboot': noReboot,
    });
    return CreateImageResult.fromJson(response_);
  }

  /// Exports a running or stopped instance to an S3 bucket.
  ///
  /// For information about the supported operating systems, image formats, and
  /// known limitations for the types of instances you can export, see
  /// [Exporting an Instance as a VM Using VM Import/Export](https://docs.aws.amazon.com/vm-import/latest/userguide/vmexport.html)
  /// in the _VM Import/Export User Guide_.
  ///
  /// [description]: A description for the conversion task or the resource being
  /// exported. The maximum length is 255 bytes.
  ///
  /// [exportToS3Task]: The format and location for an instance export task.
  ///
  /// [instanceId]: The ID of the instance.
  ///
  /// [targetEnvironment]: The target virtualization environment.
  Future<CreateInstanceExportTaskResult> createInstanceExportTask(
      String instanceId,
      {String description,
      ExportToS3TaskSpecification exportToS3Task,
      String targetEnvironment}) async {
    var response_ = await _client.send('CreateInstanceExportTask', {
      if (description != null) 'Description': description,
      if (exportToS3Task != null) 'ExportToS3Task': exportToS3Task,
      'InstanceId': instanceId,
      if (targetEnvironment != null) 'TargetEnvironment': targetEnvironment,
    });
    return CreateInstanceExportTaskResult.fromJson(response_);
  }

  /// Creates an internet gateway for use with a VPC. After creating the
  /// internet gateway, you attach it to a VPC using AttachInternetGateway.
  ///
  /// For more information about your VPC and internet gateway, see the
  /// [Amazon Virtual Private Cloud User Guide](https://docs.aws.amazon.com/vpc/latest/userguide/).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CreateInternetGatewayResult> createInternetGateway(
      {bool dryRun}) async {
    var response_ = await _client.send('CreateInternetGateway', {
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CreateInternetGatewayResult.fromJson(response_);
  }

  /// Creates a 2048-bit RSA key pair with the specified name. Amazon EC2 stores
  /// the public key and displays the private key for you to save to a file. The
  /// private key is returned as an unencrypted PEM encoded PKCS#1 private key.
  /// If a key with the specified name already exists, Amazon EC2 returns an
  /// error.
  ///
  /// You can have up to five thousand key pairs per Region.
  ///
  /// The key pair returned to you is available only in the Region in which you
  /// create it. If you prefer, you can create your own key pair using a
  /// third-party tool and upload it to any Region using ImportKeyPair.
  ///
  /// For more information, see
  /// [Key Pairs](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [keyName]: A unique name for the key pair.
  ///
  /// Constraints: Up to 255 ASCII characters
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<KeyPair> createKeyPair(String keyName, {bool dryRun}) async {
    var response_ = await _client.send('CreateKeyPair', {
      'KeyName': keyName,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return KeyPair.fromJson(response_);
  }

  /// Creates a launch template. A launch template contains the parameters to
  /// launch an instance. When you launch an instance using RunInstances, you
  /// can specify a launch template instead of providing the launch parameters
  /// in the request.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [clientToken]: Unique, case-sensitive identifier you provide to ensure the
  /// idempotency of the request. For more information, see
  /// [Ensuring Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// Constraint: Maximum 128 ASCII characters.
  ///
  /// [launchTemplateName]: A name for the launch template.
  ///
  /// [versionDescription]: A description for the first version of the launch
  /// template.
  ///
  /// [launchTemplateData]: The information for the launch template.
  ///
  /// [tagSpecifications]: The tags to apply to the launch template during
  /// creation.
  Future<CreateLaunchTemplateResult> createLaunchTemplate(
      {bool dryRun,
      String clientToken,
      @required String launchTemplateName,
      String versionDescription,
      @required RequestLaunchTemplateData launchTemplateData,
      List<TagSpecification> tagSpecifications}) async {
    var response_ = await _client.send('CreateLaunchTemplate', {
      if (dryRun != null) 'DryRun': dryRun,
      if (clientToken != null) 'ClientToken': clientToken,
      'LaunchTemplateName': launchTemplateName,
      if (versionDescription != null) 'VersionDescription': versionDescription,
      'LaunchTemplateData': launchTemplateData,
      if (tagSpecifications != null) 'TagSpecifications': tagSpecifications,
    });
    return CreateLaunchTemplateResult.fromJson(response_);
  }

  /// Creates a new version for a launch template. You can specify an existing
  /// version of launch template from which to base the new version.
  ///
  /// Launch template versions are numbered in the order in which they are
  /// created. You cannot specify, change, or replace the numbering of launch
  /// template versions.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [clientToken]: Unique, case-sensitive identifier you provide to ensure the
  /// idempotency of the request. For more information, see
  /// [Ensuring Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// Constraint: Maximum 128 ASCII characters.
  ///
  /// [launchTemplateId]: The ID of the launch template. You must specify either
  /// the launch template ID or launch template name in the request.
  ///
  /// [launchTemplateName]: The name of the launch template. You must specify
  /// either the launch template ID or launch template name in the request.
  ///
  /// [sourceVersion]: The version number of the launch template version on
  /// which to base the new version. The new version inherits the same launch
  /// parameters as the source version, except for parameters that you specify
  /// in `LaunchTemplateData`. Snapshots applied to the block device mapping are
  /// ignored when creating a new version unless they are explicitly included.
  ///
  /// [versionDescription]: A description for the version of the launch
  /// template.
  ///
  /// [launchTemplateData]: The information for the launch template.
  Future<CreateLaunchTemplateVersionResult> createLaunchTemplateVersion(
      RequestLaunchTemplateData launchTemplateData,
      {bool dryRun,
      String clientToken,
      String launchTemplateId,
      String launchTemplateName,
      String sourceVersion,
      String versionDescription}) async {
    var response_ = await _client.send('CreateLaunchTemplateVersion', {
      if (dryRun != null) 'DryRun': dryRun,
      if (clientToken != null) 'ClientToken': clientToken,
      if (launchTemplateId != null) 'LaunchTemplateId': launchTemplateId,
      if (launchTemplateName != null) 'LaunchTemplateName': launchTemplateName,
      if (sourceVersion != null) 'SourceVersion': sourceVersion,
      if (versionDescription != null) 'VersionDescription': versionDescription,
      'LaunchTemplateData': launchTemplateData,
    });
    return CreateLaunchTemplateVersionResult.fromJson(response_);
  }

  /// Creates a NAT gateway in the specified public subnet. This action creates
  /// a network interface in the specified subnet with a private IP address from
  /// the IP address range of the subnet. Internet-bound traffic from a private
  /// subnet can be routed to the NAT gateway, therefore enabling instances in
  /// the private subnet to connect to the internet. For more information, see
  /// [NAT Gateways](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [allocationId]: The allocation ID of an Elastic IP address to associate
  /// with the NAT gateway. If the Elastic IP address is associated with another
  /// resource, you must first disassociate it.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that you provide to
  /// ensure the idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// Constraint: Maximum 64 ASCII characters.
  ///
  /// [subnetId]: The subnet in which to create the NAT gateway.
  Future<CreateNatGatewayResult> createNatGateway(
      {@required String allocationId,
      String clientToken,
      @required String subnetId}) async {
    var response_ = await _client.send('CreateNatGateway', {
      'AllocationId': allocationId,
      if (clientToken != null) 'ClientToken': clientToken,
      'SubnetId': subnetId,
    });
    return CreateNatGatewayResult.fromJson(response_);
  }

  /// Creates a network ACL in a VPC. Network ACLs provide an optional layer of
  /// security (in addition to security groups) for the instances in your VPC.
  ///
  /// For more information, see
  /// [Network ACLs](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_ACLs.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [vpcId]: The ID of the VPC.
  Future<CreateNetworkAclResult> createNetworkAcl(String vpcId,
      {bool dryRun}) async {
    var response_ = await _client.send('CreateNetworkAcl', {
      if (dryRun != null) 'DryRun': dryRun,
      'VpcId': vpcId,
    });
    return CreateNetworkAclResult.fromJson(response_);
  }

  /// Creates an entry (a rule) in a network ACL with the specified rule number.
  /// Each network ACL has a set of numbered ingress rules and a separate set of
  /// numbered egress rules. When determining whether a packet should be allowed
  /// in or out of a subnet associated with the ACL, we process the entries in
  /// the ACL according to the rule numbers, in ascending order. Each network
  /// ACL has a set of ingress rules and a separate set of egress rules.
  ///
  /// We recommend that you leave room between the rule numbers (for example,
  /// 100, 110, 120, ...), and not number them one right after the other (for
  /// example, 101, 102, 103, ...). This makes it easier to add a rule between
  /// existing ones without having to renumber the rules.
  ///
  /// After you add an entry, you can't modify it; you must either replace it,
  /// or create an entry and delete the old one.
  ///
  /// For more information about network ACLs, see
  /// [Network ACLs](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_ACLs.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [cidrBlock]: The IPv4 network range to allow or deny, in CIDR notation
  /// (for example `172.16.0.0/24`).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [egress]: Indicates whether this is an egress rule (rule is applied to
  /// traffic leaving the subnet).
  ///
  /// [icmpTypeCode]: ICMP protocol: The ICMP or ICMPv6 type and code. Required
  /// if specifying protocol 1 (ICMP) or protocol 58 (ICMPv6) with an IPv6 CIDR
  /// block.
  ///
  /// [ipv6CidrBlock]: The IPv6 network range to allow or deny, in CIDR notation
  /// (for example `2001:db8:1234:1a00::/64`).
  ///
  /// [networkAclId]: The ID of the network ACL.
  ///
  /// [portRange]: TCP or UDP protocols: The range of ports the rule applies to.
  /// Required if specifying protocol 6 (TCP) or 17 (UDP).
  ///
  /// [protocol]: The protocol number. A value of "-1" means all protocols. If
  /// you specify "-1" or a protocol number other than "6" (TCP), "17" (UDP), or
  /// "1" (ICMP), traffic on all ports is allowed, regardless of any ports or
  /// ICMP types or codes that you specify. If you specify protocol "58"
  /// (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and
  /// codes allowed, regardless of any that you specify. If you specify protocol
  /// "58" (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP
  /// type and code.
  ///
  /// [ruleAction]: Indicates whether to allow or deny the traffic that matches
  /// the rule.
  ///
  /// [ruleNumber]: The rule number for the entry (for example, 100). ACL
  /// entries are processed in ascending order by rule number.
  ///
  /// Constraints: Positive integer from 1 to 32766. The range 32767 to 65535 is
  /// reserved for internal use.
  Future<void> createNetworkAclEntry(
      {String cidrBlock,
      bool dryRun,
      @required bool egress,
      IcmpTypeCode icmpTypeCode,
      String ipv6CidrBlock,
      @required String networkAclId,
      PortRange portRange,
      @required String protocol,
      @required String ruleAction,
      @required int ruleNumber}) async {
    await _client.send('CreateNetworkAclEntry', {
      if (cidrBlock != null) 'CidrBlock': cidrBlock,
      if (dryRun != null) 'DryRun': dryRun,
      'Egress': egress,
      if (icmpTypeCode != null) 'IcmpTypeCode': icmpTypeCode,
      if (ipv6CidrBlock != null) 'Ipv6CidrBlock': ipv6CidrBlock,
      'NetworkAclId': networkAclId,
      if (portRange != null) 'PortRange': portRange,
      'Protocol': protocol,
      'RuleAction': ruleAction,
      'RuleNumber': ruleNumber,
    });
  }

  /// Creates a network interface in the specified subnet.
  ///
  /// For more information about network interfaces, see
  /// [Elastic Network Interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [description]: A description for the network interface.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [groups]: The IDs of one or more security groups.
  ///
  /// [ipv6AddressCount]: The number of IPv6 addresses to assign to a network
  /// interface. Amazon EC2 automatically selects the IPv6 addresses from the
  /// subnet range. You can't use this option if specifying specific IPv6
  /// addresses. If your subnet has the `AssignIpv6AddressOnCreation` attribute
  /// set to `true`, you can specify `0` to override this setting.
  ///
  /// [ipv6Addresses]: One or more specific IPv6 addresses from the IPv6 CIDR
  /// block range of your subnet. You can't use this option if you're specifying
  /// a number of IPv6 addresses.
  ///
  /// [privateIpAddress]: The primary private IPv4 address of the network
  /// interface. If you don't specify an IPv4 address, Amazon EC2 selects one
  /// for you from the subnet's IPv4 CIDR range. If you specify an IP address,
  /// you cannot indicate any IP addresses specified in `privateIpAddresses` as
  /// primary (only one IP address can be designated as primary).
  ///
  /// [privateIpAddresses]: One or more private IPv4 addresses.
  ///
  /// [secondaryPrivateIpAddressCount]: The number of secondary private IPv4
  /// addresses to assign to a network interface. When you specify a number of
  /// secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the
  /// subnet's IPv4 CIDR range. You can't specify this option and specify more
  /// than one private IP address using `privateIpAddresses`.
  ///
  /// The number of IP addresses you can assign to a network interface varies by
  /// instance type. For more information, see
  /// [IP Addresses Per ENI Per Instance Type](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html#AvailableIpPerENI)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [interfaceType]: Indicates the type of network interface. To create an
  /// Elastic Fabric Adapter (EFA), specify `efa`. For more information, see
  /// [Elastic Fabric Adapter](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [subnetId]: The ID of the subnet to associate with the network interface.
  Future<CreateNetworkInterfaceResult> createNetworkInterface(String subnetId,
      {String description,
      bool dryRun,
      List<String> groups,
      int ipv6AddressCount,
      List<InstanceIpv6Address> ipv6Addresses,
      String privateIpAddress,
      List<PrivateIpAddressSpecification> privateIpAddresses,
      int secondaryPrivateIpAddressCount,
      String interfaceType}) async {
    var response_ = await _client.send('CreateNetworkInterface', {
      if (description != null) 'Description': description,
      if (dryRun != null) 'DryRun': dryRun,
      if (groups != null) 'Groups': groups,
      if (ipv6AddressCount != null) 'Ipv6AddressCount': ipv6AddressCount,
      if (ipv6Addresses != null) 'Ipv6Addresses': ipv6Addresses,
      if (privateIpAddress != null) 'PrivateIpAddress': privateIpAddress,
      if (privateIpAddresses != null) 'PrivateIpAddresses': privateIpAddresses,
      if (secondaryPrivateIpAddressCount != null)
        'SecondaryPrivateIpAddressCount': secondaryPrivateIpAddressCount,
      if (interfaceType != null) 'InterfaceType': interfaceType,
      'SubnetId': subnetId,
    });
    return CreateNetworkInterfaceResult.fromJson(response_);
  }

  /// Grants an AWS-authorized account permission to attach the specified
  /// network interface to an instance in their account.
  ///
  /// You can grant permission to a single AWS account only, and only one
  /// account at a time.
  ///
  /// [networkInterfaceId]: The ID of the network interface.
  ///
  /// [awsAccountId]: The AWS account ID.
  ///
  /// [awsService]: The AWS service. Currently not supported.
  ///
  /// [permission]: The type of permission to grant.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CreateNetworkInterfacePermissionResult>
      createNetworkInterfacePermission(
          {@required String networkInterfaceId,
          String awsAccountId,
          String awsService,
          @required String permission,
          bool dryRun}) async {
    var response_ = await _client.send('CreateNetworkInterfacePermission', {
      'NetworkInterfaceId': networkInterfaceId,
      if (awsAccountId != null) 'AwsAccountId': awsAccountId,
      if (awsService != null) 'AwsService': awsService,
      'Permission': permission,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CreateNetworkInterfacePermissionResult.fromJson(response_);
  }

  /// Creates a placement group in which to launch instances. The strategy of
  /// the placement group determines how the instances are organized within the
  /// group.
  ///
  /// A `cluster` placement group is a logical grouping of instances within a
  /// single Availability Zone that benefit from low network latency, high
  /// network throughput. A `spread` placement group places instances on
  /// distinct hardware. A `partition` placement group places groups of
  /// instances in different partitions, where instances in one partition do not
  /// share the same hardware with instances in another partition.
  ///
  /// For more information, see
  /// [Placement Groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [groupName]: A name for the placement group. Must be unique within the
  /// scope of your account for the Region.
  ///
  /// Constraints: Up to 255 ASCII characters
  ///
  /// [strategy]: The placement strategy.
  ///
  /// [partitionCount]: The number of partitions. Valid only when **Strategy**
  /// is set to `partition`.
  Future<void> createPlacementGroup(
      {bool dryRun,
      String groupName,
      String strategy,
      int partitionCount}) async {
    await _client.send('CreatePlacementGroup', {
      if (dryRun != null) 'DryRun': dryRun,
      if (groupName != null) 'GroupName': groupName,
      if (strategy != null) 'Strategy': strategy,
      if (partitionCount != null) 'PartitionCount': partitionCount,
    });
  }

  /// Creates a listing for Amazon EC2 Standard Reserved Instances to be sold in
  /// the Reserved Instance Marketplace. You can submit one Standard Reserved
  /// Instance listing at a time. To get a list of your Standard Reserved
  /// Instances, you can use the DescribeReservedInstances operation.
  ///
  ///  Only Standard Reserved Instances can be sold in the Reserved Instance
  /// Marketplace. Convertible Reserved Instances cannot be sold.
  ///
  /// The Reserved Instance Marketplace matches sellers who want to resell
  /// Standard Reserved Instance capacity that they no longer need with buyers
  /// who want to purchase additional capacity. Reserved Instances bought and
  /// sold through the Reserved Instance Marketplace work like any other
  /// Reserved Instances.
  ///
  /// To sell your Standard Reserved Instances, you must first register as a
  /// seller in the Reserved Instance Marketplace. After completing the
  /// registration process, you can create a Reserved Instance Marketplace
  /// listing of some or all of your Standard Reserved Instances, and specify
  /// the upfront price to receive for them. Your Standard Reserved Instance
  /// listings then become available for purchase. To view the details of your
  /// Standard Reserved Instance listing, you can use the
  /// DescribeReservedInstancesListings operation.
  ///
  /// For more information, see
  /// [Reserved Instance Marketplace](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-market-general.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [clientToken]: Unique, case-sensitive identifier you provide to ensure
  /// idempotency of your listings. This helps avoid duplicate listings. For
  /// more information, see
  /// [Ensuring Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// [instanceCount]: The number of instances that are a part of a Reserved
  /// Instance account to be listed in the Reserved Instance Marketplace. This
  /// number should be less than or equal to the instance count associated with
  /// the Reserved Instance ID specified in this call.
  ///
  /// [priceSchedules]: A list specifying the price of the Standard Reserved
  /// Instance for each month remaining in the Reserved Instance term.
  ///
  /// [reservedInstancesId]: The ID of the active Standard Reserved Instance.
  Future<CreateReservedInstancesListingResult> createReservedInstancesListing(
      {@required String clientToken,
      @required int instanceCount,
      @required List<PriceScheduleSpecification> priceSchedules,
      @required String reservedInstancesId}) async {
    var response_ = await _client.send('CreateReservedInstancesListing', {
      'ClientToken': clientToken,
      'InstanceCount': instanceCount,
      'PriceSchedules': priceSchedules,
      'ReservedInstancesId': reservedInstancesId,
    });
    return CreateReservedInstancesListingResult.fromJson(response_);
  }

  /// Creates a route in a route table within a VPC.
  ///
  /// You must specify one of the following targets: internet gateway or virtual
  /// private gateway, NAT instance, NAT gateway, VPC peering connection,
  /// network interface, or egress-only internet gateway.
  ///
  /// When determining how to route traffic, we use the route with the most
  /// specific match. For example, traffic is destined for the IPv4 address
  /// `192.0.2.3`, and the route table includes the following two IPv4 routes:
  ///
  /// *    `192.0.2.0/24` (goes to some target A)
  ///
  /// *    `192.0.2.0/28` (goes to some target B)
  ///
  ///
  /// Both routes apply to the traffic destined for `192.0.2.3`. However, the
  /// second route in the list covers a smaller number of IP addresses and is
  /// therefore more specific, so we use that route to determine where to target
  /// the traffic.
  ///
  /// For more information about route tables, see
  /// [Route Tables](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Route_Tables.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [destinationCidrBlock]: The IPv4 CIDR address block used for the
  /// destination match. Routing decisions are based on the most specific match.
  ///
  /// [destinationIpv6CidrBlock]: The IPv6 CIDR block used for the destination
  /// match. Routing decisions are based on the most specific match.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [egressOnlyInternetGatewayId]: [IPv6 traffic only] The ID of an
  /// egress-only internet gateway.
  ///
  /// [gatewayId]: The ID of an internet gateway or virtual private gateway
  /// attached to your VPC.
  ///
  /// [instanceId]: The ID of a NAT instance in your VPC. The operation fails if
  /// you specify an instance ID unless exactly one network interface is
  /// attached.
  ///
  /// [natGatewayId]: [IPv4 traffic only] The ID of a NAT gateway.
  ///
  /// [transitGatewayId]: The ID of a transit gateway.
  ///
  /// [networkInterfaceId]: The ID of a network interface.
  ///
  /// [routeTableId]: The ID of the route table for the route.
  ///
  /// [vpcPeeringConnectionId]: The ID of a VPC peering connection.
  Future<CreateRouteResult> createRoute(String routeTableId,
      {String destinationCidrBlock,
      String destinationIpv6CidrBlock,
      bool dryRun,
      String egressOnlyInternetGatewayId,
      String gatewayId,
      String instanceId,
      String natGatewayId,
      String transitGatewayId,
      String networkInterfaceId,
      String vpcPeeringConnectionId}) async {
    var response_ = await _client.send('CreateRoute', {
      if (destinationCidrBlock != null)
        'DestinationCidrBlock': destinationCidrBlock,
      if (destinationIpv6CidrBlock != null)
        'DestinationIpv6CidrBlock': destinationIpv6CidrBlock,
      if (dryRun != null) 'DryRun': dryRun,
      if (egressOnlyInternetGatewayId != null)
        'EgressOnlyInternetGatewayId': egressOnlyInternetGatewayId,
      if (gatewayId != null) 'GatewayId': gatewayId,
      if (instanceId != null) 'InstanceId': instanceId,
      if (natGatewayId != null) 'NatGatewayId': natGatewayId,
      if (transitGatewayId != null) 'TransitGatewayId': transitGatewayId,
      if (networkInterfaceId != null) 'NetworkInterfaceId': networkInterfaceId,
      'RouteTableId': routeTableId,
      if (vpcPeeringConnectionId != null)
        'VpcPeeringConnectionId': vpcPeeringConnectionId,
    });
    return CreateRouteResult.fromJson(response_);
  }

  /// Creates a route table for the specified VPC. After you create a route
  /// table, you can add routes and associate the table with a subnet.
  ///
  /// For more information, see
  /// [Route Tables](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Route_Tables.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [vpcId]: The ID of the VPC.
  Future<CreateRouteTableResult> createRouteTable(String vpcId,
      {bool dryRun}) async {
    var response_ = await _client.send('CreateRouteTable', {
      if (dryRun != null) 'DryRun': dryRun,
      'VpcId': vpcId,
    });
    return CreateRouteTableResult.fromJson(response_);
  }

  /// Creates a security group.
  ///
  /// A security group acts as a virtual firewall for your instance to control
  /// inbound and outbound traffic. For more information, see
  /// [Amazon EC2 Security Groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_ and
  /// [Security Groups for Your VPC](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// When you create a security group, you specify a friendly name of your
  /// choice. You can have a security group for use in EC2-Classic with the same
  /// name as a security group for use in a VPC. However, you can't have two
  /// security groups for use in EC2-Classic with the same name or two security
  /// groups for use in a VPC with the same name.
  ///
  /// You have a default security group for use in EC2-Classic and a default
  /// security group for use in your VPC. If you don't specify a security group
  /// when you launch an instance, the instance is launched into the appropriate
  /// default security group. A default security group includes a default rule
  /// that grants instances unrestricted network access to each other.
  ///
  /// You can add or remove rules from your security groups using
  /// AuthorizeSecurityGroupIngress, AuthorizeSecurityGroupEgress,
  /// RevokeSecurityGroupIngress, and RevokeSecurityGroupEgress.
  ///
  /// For more information about VPC security group limits, see
  /// [Amazon VPC Limits](https://docs.aws.amazon.com/vpc/latest/userguide/amazon-vpc-limits.html).
  ///
  /// [description]: A description for the security group. This is informational
  /// only.
  ///
  /// Constraints: Up to 255 characters in length
  ///
  /// Constraints for EC2-Classic: ASCII characters
  ///
  /// Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
  ///
  /// [groupName]: The name of the security group.
  ///
  /// Constraints: Up to 255 characters in length. Cannot start with `sg-`.
  ///
  /// Constraints for EC2-Classic: ASCII characters
  ///
  /// Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
  ///
  /// [vpcId]: [EC2-VPC] The ID of the VPC. Required for EC2-VPC.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CreateSecurityGroupResult> createSecurityGroup(
      {@required String description,
      @required String groupName,
      String vpcId,
      bool dryRun}) async {
    var response_ = await _client.send('CreateSecurityGroup', {
      'Description': description,
      'GroupName': groupName,
      if (vpcId != null) 'VpcId': vpcId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CreateSecurityGroupResult.fromJson(response_);
  }

  /// Creates a snapshot of an EBS volume and stores it in Amazon S3. You can
  /// use snapshots for backups, to make copies of EBS volumes, and to save data
  /// before shutting down an instance.
  ///
  /// When a snapshot is created, any AWS Marketplace product codes that are
  /// associated with the source volume are propagated to the snapshot.
  ///
  /// You can take a snapshot of an attached volume that is in use. However,
  /// snapshots only capture data that has been written to your EBS volume at
  /// the time the snapshot command is issued; this may exclude any data that
  /// has been cached by any applications or the operating system. If you can
  /// pause any file systems on the volume long enough to take a snapshot, your
  /// snapshot should be complete. However, if you cannot pause all file writes
  /// to the volume, you should unmount the volume from within the instance,
  /// issue the snapshot command, and then remount the volume to ensure a
  /// consistent and complete snapshot. You may remount and use your volume
  /// while the snapshot status is `pending`.
  ///
  /// To create a snapshot for EBS volumes that serve as root devices, you
  /// should stop the instance before taking the snapshot.
  ///
  /// Snapshots that are taken from encrypted volumes are automatically
  /// encrypted. Volumes that are created from encrypted snapshots are also
  /// automatically encrypted. Your encrypted volumes and any associated
  /// snapshots always remain protected.
  ///
  /// You can tag your snapshots during creation. For more information, see
  /// [Tagging Your Amazon EC2 Resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// For more information, see
  /// [Amazon Elastic Block Store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AmazonEBS.html)
  /// and
  /// [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [description]: A description for the snapshot.
  ///
  /// [volumeId]: The ID of the EBS volume.
  ///
  /// [tagSpecifications]: The tags to apply to the snapshot during creation.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<Snapshot> createSnapshot(String volumeId,
      {String description,
      List<TagSpecification> tagSpecifications,
      bool dryRun}) async {
    var response_ = await _client.send('CreateSnapshot', {
      if (description != null) 'Description': description,
      'VolumeId': volumeId,
      if (tagSpecifications != null) 'TagSpecifications': tagSpecifications,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return Snapshot.fromJson(response_);
  }

  /// Creates crash-consistent snapshots of multiple EBS volumes and stores the
  /// data in S3. Volumes are chosen by specifying an instance. Any attached
  /// volumes will produce one snapshot each that is crash-consistent across the
  /// instance. Boot volumes can be excluded by changing the paramaters.
  ///
  /// [description]:  A description propagated to every snapshot specified by
  /// the instance.
  ///
  /// [instanceSpecification]: The instance to specify which volumes should be
  /// included in the snapshots.
  ///
  /// [tagSpecifications]: Tags to apply to every snapshot specified by the
  /// instance.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action
  /// without actually making the request. Provides an error response. If you
  /// have the required permissions, the error response is DryRunOperation.
  /// Otherwise, it is UnauthorizedOperation.
  ///
  /// [copyTagsFromSource]: Copies the tags from the specified volume to
  /// corresponding snapshot.
  Future<CreateSnapshotsResult> createSnapshots(
      InstanceSpecification instanceSpecification,
      {String description,
      List<TagSpecification> tagSpecifications,
      bool dryRun,
      String copyTagsFromSource}) async {
    var response_ = await _client.send('CreateSnapshots', {
      if (description != null) 'Description': description,
      'InstanceSpecification': instanceSpecification,
      if (tagSpecifications != null) 'TagSpecifications': tagSpecifications,
      if (dryRun != null) 'DryRun': dryRun,
      if (copyTagsFromSource != null) 'CopyTagsFromSource': copyTagsFromSource,
    });
    return CreateSnapshotsResult.fromJson(response_);
  }

  /// Creates a data feed for Spot Instances, enabling you to view Spot Instance
  /// usage logs. You can create one data feed per AWS account. For more
  /// information, see
  /// [Spot Instance Data Feed](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-data-feeds.html)
  /// in the _Amazon EC2 User Guide for Linux Instances_.
  ///
  /// [bucket]: The Amazon S3 bucket in which to store the Spot Instance data
  /// feed.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [prefix]: A prefix for the data feed file names.
  Future<CreateSpotDatafeedSubscriptionResult> createSpotDatafeedSubscription(
      String bucket,
      {bool dryRun,
      String prefix}) async {
    var response_ = await _client.send('CreateSpotDatafeedSubscription', {
      'Bucket': bucket,
      if (dryRun != null) 'DryRun': dryRun,
      if (prefix != null) 'Prefix': prefix,
    });
    return CreateSpotDatafeedSubscriptionResult.fromJson(response_);
  }

  /// Creates a subnet in an existing VPC.
  ///
  /// When you create each subnet, you provide the VPC ID and IPv4 CIDR block
  /// for the subnet. After you create a subnet, you can't change its CIDR
  /// block. The size of the subnet's IPv4 CIDR block can be the same as a VPC's
  /// IPv4 CIDR block, or a subset of a VPC's IPv4 CIDR block. If you create
  /// more than one subnet in a VPC, the subnets' CIDR blocks must not overlap.
  /// The smallest IPv4 subnet (and VPC) you can create uses a /28 netmask (16
  /// IPv4 addresses), and the largest uses a /16 netmask (65,536 IPv4
  /// addresses).
  ///
  /// If you've associated an IPv6 CIDR block with your VPC, you can create a
  /// subnet with an IPv6 CIDR block that uses a /64 prefix length.
  ///
  ///  AWS reserves both the first four and the last IPv4 address in each
  /// subnet's CIDR block. They're not available for use.
  ///
  /// If you add more than one subnet to a VPC, they're set up in a star
  /// topology with a logical router in the middle.
  ///
  /// If you launch an instance in a VPC using an Amazon EBS-backed AMI, the IP
  /// address doesn't change if you stop and restart the instance (unlike a
  /// similar instance launched outside a VPC, which gets a new IP address when
  /// restarted). It's therefore possible to have a subnet with no running
  /// instances (they're all stopped), but no remaining IP addresses available.
  ///
  /// For more information about subnets, see
  /// [Your VPC and Subnets](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [availabilityZone]: The Availability Zone for the subnet.
  ///
  /// Default: AWS selects one for you. If you create more than one subnet in
  /// your VPC, we may not necessarily select a different zone for each subnet.
  ///
  /// [availabilityZoneId]: The AZ ID of the subnet.
  ///
  /// [cidrBlock]: The IPv4 network range for the subnet, in CIDR notation. For
  /// example, `10.0.0.0/24`.
  ///
  /// [ipv6CidrBlock]: The IPv6 network range for the subnet, in CIDR notation.
  /// The subnet size must use a /64 prefix length.
  ///
  /// [vpcId]: The ID of the VPC.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CreateSubnetResult> createSubnet(
      {String availabilityZone,
      String availabilityZoneId,
      @required String cidrBlock,
      String ipv6CidrBlock,
      @required String vpcId,
      bool dryRun}) async {
    var response_ = await _client.send('CreateSubnet', {
      if (availabilityZone != null) 'AvailabilityZone': availabilityZone,
      if (availabilityZoneId != null) 'AvailabilityZoneId': availabilityZoneId,
      'CidrBlock': cidrBlock,
      if (ipv6CidrBlock != null) 'Ipv6CidrBlock': ipv6CidrBlock,
      'VpcId': vpcId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CreateSubnetResult.fromJson(response_);
  }

  /// Adds or overwrites the specified tags for the specified Amazon EC2
  /// resource or resources. Each resource can have a maximum of 50 tags. Each
  /// tag consists of a key and optional value. Tag keys must be unique per
  /// resource.
  ///
  /// For more information about tags, see
  /// [Tagging Your Resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_. For more information
  /// about creating IAM policies that control users' access to resources based
  /// on tags, see
  /// [Supported Resource-Level Permissions for Amazon EC2 API Actions](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-iam-actions-resources.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [resources]: The IDs of the resources, separated by spaces.
  ///
  /// Constraints: Up to 1000 resource IDs. We recommend breaking up this
  /// request into smaller batches.
  ///
  /// [tags]: The tags. The `value` parameter is required, but if you don't want
  /// the tag to have a value, specify the parameter with no value, and we set
  /// the value to an empty string.
  Future<void> createTags(
      {bool dryRun,
      @required List<String> resources,
      @required List<Tag> tags}) async {
    await _client.send('CreateTags', {
      if (dryRun != null) 'DryRun': dryRun,
      'Resources': resources,
      'Tags': tags,
    });
  }

  /// Creates a Traffic Mirror filter.
  ///
  /// A Traffic Mirror filter is a set of rules that defines the traffic to
  /// mirror.
  ///
  /// By default, no traffic is mirrored. To mirror traffic, use
  /// CreateTrafficMirrorFilterRule to add Traffic Mirror rules to the filter.
  /// The rules you add define what traffic gets mirrored. You can also use
  /// ModifyTrafficMirrorFilterNetworkServices to mirror supported network
  /// services.
  ///
  /// [description]: The description of the Traffic Mirror filter.
  ///
  /// [tagSpecifications]: The tags to assign to a Traffic Mirror filter.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that you provide to
  /// ensure the idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  Future<CreateTrafficMirrorFilterResult> createTrafficMirrorFilter(
      {String description,
      List<TagSpecification> tagSpecifications,
      bool dryRun,
      String clientToken}) async {
    var response_ = await _client.send('CreateTrafficMirrorFilter', {
      if (description != null) 'Description': description,
      if (tagSpecifications != null) 'TagSpecifications': tagSpecifications,
      if (dryRun != null) 'DryRun': dryRun,
      if (clientToken != null) 'ClientToken': clientToken,
    });
    return CreateTrafficMirrorFilterResult.fromJson(response_);
  }

  /// Creates a Traffic Mirror rule.
  ///
  /// A Traffic Mirror rule defines the Traffic Mirror source traffic to mirror.
  ///
  /// You need the Traffic Mirror filter ID when you create the rule.
  ///
  /// [trafficMirrorFilterId]: The ID of the filter that this rule is associated
  /// with.
  ///
  /// [trafficDirection]: The type of traffic (`ingress` | `egress`).
  ///
  /// [ruleNumber]: The number of the Traffic Mirror rule. This number must be
  /// unique for each Traffic Mirror rule in a given direction. The rules are
  /// processed in ascending order by rule number.
  ///
  /// [ruleAction]: The action to take (`accept` | `reject`) on the filtered
  /// traffic.
  ///
  /// [destinationPortRange]: The destination port range.
  ///
  /// [sourcePortRange]: The source port range.
  ///
  /// [protocol]: The protocol, for example UDP, to assign to the Traffic Mirror
  /// rule.
  ///
  /// For information about the protocol value, see
  /// [Protocol Numbers](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)
  /// on the Internet Assigned Numbers Authority (IANA) website.
  ///
  /// [destinationCidrBlock]: The destination CIDR block to assign to the
  /// Traffic Mirror rule.
  ///
  /// [sourceCidrBlock]: The source CIDR block to assign to the Traffic Mirror
  /// rule.
  ///
  /// [description]: The description of the Traffic Mirror rule.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that you provide to
  /// ensure the idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  Future<CreateTrafficMirrorFilterRuleResult> createTrafficMirrorFilterRule(
      {@required String trafficMirrorFilterId,
      @required String trafficDirection,
      @required int ruleNumber,
      @required String ruleAction,
      TrafficMirrorPortRangeRequest destinationPortRange,
      TrafficMirrorPortRangeRequest sourcePortRange,
      int protocol,
      @required String destinationCidrBlock,
      @required String sourceCidrBlock,
      String description,
      bool dryRun,
      String clientToken}) async {
    var response_ = await _client.send('CreateTrafficMirrorFilterRule', {
      'TrafficMirrorFilterId': trafficMirrorFilterId,
      'TrafficDirection': trafficDirection,
      'RuleNumber': ruleNumber,
      'RuleAction': ruleAction,
      if (destinationPortRange != null)
        'DestinationPortRange': destinationPortRange,
      if (sourcePortRange != null) 'SourcePortRange': sourcePortRange,
      if (protocol != null) 'Protocol': protocol,
      'DestinationCidrBlock': destinationCidrBlock,
      'SourceCidrBlock': sourceCidrBlock,
      if (description != null) 'Description': description,
      if (dryRun != null) 'DryRun': dryRun,
      if (clientToken != null) 'ClientToken': clientToken,
    });
    return CreateTrafficMirrorFilterRuleResult.fromJson(response_);
  }

  /// Creates a Traffic Mirror session.
  ///
  /// A Traffic Mirror session actively copies packets from a Traffic Mirror
  /// source to a Traffic Mirror target. Create a filter, and then assign it to
  /// the session to define a subset of the traffic to mirror, for example all
  /// TCP traffic.
  ///
  /// The Traffic Mirror source and the Traffic Mirror target (monitoring
  /// appliances) can be in the same VPC, or in a different VPC connected via
  /// VPC peering or a transit gateway.
  ///
  /// By default, no traffic is mirrored. Use CreateTrafficMirrorFilter to
  /// create filter rules that specify the traffic to mirror.
  ///
  /// [networkInterfaceId]: The ID of the source network interface.
  ///
  /// [trafficMirrorTargetId]: The ID of the Traffic Mirror target.
  ///
  /// [trafficMirrorFilterId]: The ID of the Traffic Mirror filter.
  ///
  /// [packetLength]: The number of bytes in each packet to mirror. These are
  /// bytes after the VXLAN header. Do not specify this parameter when you want
  /// to mirror the entire packet. To mirror a subset of the packet, set this to
  /// the length (in bytes) that you want to mirror. For example, if you set
  /// this value to 1network0, then the first 100 bytes that meet the filter
  /// criteria are copied to the target.
  ///
  /// If you do not want to mirror the entire packet, use the `PacketLength`
  /// parameter to specify the number of bytes in each packet to mirror.
  ///
  /// [sessionNumber]: The session number determines the order in which sessions
  /// are evaluated when an interface is used by multiple sessions. The first
  /// session with a matching filter is the one that mirrors the packets.
  ///
  /// Valid values are 1-32766.
  ///
  /// [virtualNetworkId]: The VXLAN ID for the Traffic Mirror session. For more
  /// information about the VXLAN protocol, see
  /// [RFC 7348](https://tools.ietf.org/html/rfc7348). If you do not specify a
  /// `VirtualNetworkId`, an account-wide unique id is chosen at random.
  ///
  /// [description]: The description of the Traffic Mirror session.
  ///
  /// [tagSpecifications]: The tags to assign to a Traffic Mirror session.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that you provide to
  /// ensure the idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  Future<CreateTrafficMirrorSessionResult> createTrafficMirrorSession(
      {@required String networkInterfaceId,
      @required String trafficMirrorTargetId,
      @required String trafficMirrorFilterId,
      int packetLength,
      @required int sessionNumber,
      int virtualNetworkId,
      String description,
      List<TagSpecification> tagSpecifications,
      bool dryRun,
      String clientToken}) async {
    var response_ = await _client.send('CreateTrafficMirrorSession', {
      'NetworkInterfaceId': networkInterfaceId,
      'TrafficMirrorTargetId': trafficMirrorTargetId,
      'TrafficMirrorFilterId': trafficMirrorFilterId,
      if (packetLength != null) 'PacketLength': packetLength,
      'SessionNumber': sessionNumber,
      if (virtualNetworkId != null) 'VirtualNetworkId': virtualNetworkId,
      if (description != null) 'Description': description,
      if (tagSpecifications != null) 'TagSpecifications': tagSpecifications,
      if (dryRun != null) 'DryRun': dryRun,
      if (clientToken != null) 'ClientToken': clientToken,
    });
    return CreateTrafficMirrorSessionResult.fromJson(response_);
  }

  /// Creates a target for your Traffic Mirror session.
  ///
  /// A Traffic Mirror target is the destination for mirrored traffic. The
  /// Traffic Mirror source and the Traffic Mirror target (monitoring
  /// appliances) can be in the same VPC, or in different VPCs connected via VPC
  /// peering or a transit gateway.
  ///
  /// A Traffic Mirror target can be a network interface, or a Network Load
  /// Balancer.
  ///
  /// To use the target in a Traffic Mirror session, use
  /// CreateTrafficMirrorSession.
  ///
  /// [networkInterfaceId]: The network interface ID that is associated with the
  /// target.
  ///
  /// [networkLoadBalancerArn]: The Amazon Resource Name (ARN) of the Network
  /// Load Balancer that is associated with the target.
  ///
  /// [description]: The description of the Traffic Mirror target.
  ///
  /// [tagSpecifications]: The tags to assign to the Traffic Mirror target.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that you provide to
  /// ensure the idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  Future<CreateTrafficMirrorTargetResult> createTrafficMirrorTarget(
      {String networkInterfaceId,
      String networkLoadBalancerArn,
      String description,
      List<TagSpecification> tagSpecifications,
      bool dryRun,
      String clientToken}) async {
    var response_ = await _client.send('CreateTrafficMirrorTarget', {
      if (networkInterfaceId != null) 'NetworkInterfaceId': networkInterfaceId,
      if (networkLoadBalancerArn != null)
        'NetworkLoadBalancerArn': networkLoadBalancerArn,
      if (description != null) 'Description': description,
      if (tagSpecifications != null) 'TagSpecifications': tagSpecifications,
      if (dryRun != null) 'DryRun': dryRun,
      if (clientToken != null) 'ClientToken': clientToken,
    });
    return CreateTrafficMirrorTargetResult.fromJson(response_);
  }

  /// Creates a transit gateway.
  ///
  /// You can use a transit gateway to interconnect your virtual private clouds
  /// (VPC) and on-premises networks. After the transit gateway enters the
  /// `available` state, you can attach your VPCs and VPN connections to the
  /// transit gateway.
  ///
  /// To attach your VPCs, use CreateTransitGatewayVpcAttachment.
  ///
  /// To attach a VPN connection, use CreateCustomerGateway to create a customer
  /// gateway and specify the ID of the customer gateway and the ID of the
  /// transit gateway in a call to CreateVpnConnection.
  ///
  /// When you create a transit gateway, we create a default transit gateway
  /// route table and use it as the default association route table and the
  /// default propagation route table. You can use
  /// CreateTransitGatewayRouteTable to create additional transit gateway route
  /// tables. If you disable automatic route propagation, we do not create a
  /// default transit gateway route table. You can use
  /// EnableTransitGatewayRouteTablePropagation to propagate routes from a
  /// resource attachment to a transit gateway route table. If you disable
  /// automatic associations, you can use AssociateTransitGatewayRouteTable to
  /// associate a resource attachment with a transit gateway route table.
  ///
  /// [description]: A description of the transit gateway.
  ///
  /// [options]: The transit gateway options.
  ///
  /// [tagSpecifications]: The tags to apply to the transit gateway.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CreateTransitGatewayResult> createTransitGateway(
      {String description,
      TransitGatewayRequestOptions options,
      List<TagSpecification> tagSpecifications,
      bool dryRun}) async {
    var response_ = await _client.send('CreateTransitGateway', {
      if (description != null) 'Description': description,
      if (options != null) 'Options': options,
      if (tagSpecifications != null) 'TagSpecifications': tagSpecifications,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CreateTransitGatewayResult.fromJson(response_);
  }

  /// Creates a static route for the specified transit gateway route table.
  ///
  /// [destinationCidrBlock]: The CIDR range used for destination matches.
  /// Routing decisions are based on the most specific match.
  ///
  /// [transitGatewayRouteTableId]: The ID of the transit gateway route table.
  ///
  /// [transitGatewayAttachmentId]: The ID of the attachment.
  ///
  /// [blackhole]: Indicates whether to drop traffic that matches this route.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CreateTransitGatewayRouteResult> createTransitGatewayRoute(
      {@required String destinationCidrBlock,
      @required String transitGatewayRouteTableId,
      String transitGatewayAttachmentId,
      bool blackhole,
      bool dryRun}) async {
    var response_ = await _client.send('CreateTransitGatewayRoute', {
      'DestinationCidrBlock': destinationCidrBlock,
      'TransitGatewayRouteTableId': transitGatewayRouteTableId,
      if (transitGatewayAttachmentId != null)
        'TransitGatewayAttachmentId': transitGatewayAttachmentId,
      if (blackhole != null) 'Blackhole': blackhole,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CreateTransitGatewayRouteResult.fromJson(response_);
  }

  /// Creates a route table for the specified transit gateway.
  ///
  /// [transitGatewayId]: The ID of the transit gateway.
  ///
  /// [tagSpecifications]: The tags to apply to the transit gateway route table.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CreateTransitGatewayRouteTableResult> createTransitGatewayRouteTable(
      String transitGatewayId,
      {List<TagSpecification> tagSpecifications,
      bool dryRun}) async {
    var response_ = await _client.send('CreateTransitGatewayRouteTable', {
      'TransitGatewayId': transitGatewayId,
      if (tagSpecifications != null) 'TagSpecifications': tagSpecifications,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CreateTransitGatewayRouteTableResult.fromJson(response_);
  }

  /// Attaches the specified VPC to the specified transit gateway.
  ///
  /// If you attach a VPC with a CIDR range that overlaps the CIDR range of a
  /// VPC that is already attached, the new VPC CIDR range is not propagated to
  /// the default propagation route table.
  ///
  /// To send VPC traffic to an attached transit gateway, add a route to the VPC
  /// route table using CreateRoute.
  ///
  /// [transitGatewayId]: The ID of the transit gateway.
  ///
  /// [vpcId]: The ID of the VPC.
  ///
  /// [subnetIds]: The IDs of one or more subnets. You can specify only one
  /// subnet per Availability Zone. You must specify at least one subnet, but we
  /// recommend that you specify two subnets for better availability. The
  /// transit gateway uses one IP address from each specified subnet.
  ///
  /// [options]: The VPC attachment options.
  ///
  /// [tagSpecifications]: The tags to apply to the VPC attachment.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CreateTransitGatewayVpcAttachmentResult>
      createTransitGatewayVpcAttachment(
          {@required String transitGatewayId,
          @required String vpcId,
          @required List<String> subnetIds,
          CreateTransitGatewayVpcAttachmentRequestOptions options,
          List<TagSpecification> tagSpecifications,
          bool dryRun}) async {
    var response_ = await _client.send('CreateTransitGatewayVpcAttachment', {
      'TransitGatewayId': transitGatewayId,
      'VpcId': vpcId,
      'SubnetIds': subnetIds,
      if (options != null) 'Options': options,
      if (tagSpecifications != null) 'TagSpecifications': tagSpecifications,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CreateTransitGatewayVpcAttachmentResult.fromJson(response_);
  }

  /// Creates an EBS volume that can be attached to an instance in the same
  /// Availability Zone. The volume is created in the regional endpoint that you
  /// send the HTTP request to. For more information see
  /// [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
  ///
  /// You can create a new empty volume or restore a volume from an EBS
  /// snapshot. Any AWS Marketplace product codes from the snapshot are
  /// propagated to the volume.
  ///
  /// You can create encrypted volumes. Encrypted volumes must be attached to
  /// instances that support Amazon EBS encryption. Volumes that are created
  /// from encrypted snapshots are also automatically encrypted. For more
  /// information, see
  /// [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// You can tag your volumes during creation. For more information, see
  /// [Tagging Your Amazon EC2 Resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// For more information, see
  /// [Creating an Amazon EBS Volume](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-creating-volume.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [availabilityZone]: The Availability Zone in which to create the volume.
  ///
  /// [encrypted]: Specifies whether the volume should be encrypted. The effect
  /// of setting the encryption state to `true` depends on the volume origin
  /// (new or from a snapshot), starting encryption state, ownership, and
  /// whether encryption by default is enabled. For more information, see
  /// [Encryption by Default](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// Encrypted Amazon EBS volumes must be attached to instances that support
  /// Amazon EBS encryption. For more information, see
  /// [Supported Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances).
  ///
  /// [iops]: The number of I/O operations per second (IOPS) to provision for
  /// the volume, with a maximum ratio of 50 IOPS/GiB. Range is 100 to 64,000
  /// IOPS for volumes in most Regions. Maximum IOPS of 64,000 is guaranteed
  /// only on
  /// [Nitro-based instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances).
  /// Other instance families guarantee performance up to 32,000 IOPS. For more
  /// information, see
  /// [Amazon EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// This parameter is valid only for Provisioned IOPS SSD (io1) volumes.
  ///
  /// [kmsKeyId]: The identifier of the AWS Key Management Service (AWS KMS)
  /// customer master key (CMK) to use for Amazon EBS encryption. If this
  /// parameter is not specified, your AWS managed CMK for EBS is used. If
  /// `KmsKeyId` is specified, the encrypted state must be `true`.
  ///
  /// You can specify the CMK using any of the following:
  ///
  /// *   Key ID. For example, key/1234abcd-12ab-34cd-56ef-1234567890ab.
  ///
  /// *   Key alias. For example, alias/ExampleAlias.
  ///
  /// *   Key ARN. For example,
  /// arn:aws:kms:_us-east-1_:_012345678910_:key/_abcd1234-a123-456a-a12b-a123b4cd56ef_.
  ///
  /// *   Alias ARN. For example,
  /// arn:aws:kms:_us-east-1_:_012345678910_:alias/_ExampleAlias_.
  ///
  ///
  /// AWS authenticates the CMK asynchronously. Therefore, if you specify an ID,
  /// alias, or ARN that is not valid, the action can appear to complete, but
  /// eventually fails.
  ///
  /// [size]: The size of the volume, in GiBs.
  ///
  /// Constraints: 1-16,384 for `gp2`, 4-16,384 for `io1`, 500-16,384 for `st1`,
  /// 500-16,384 for `sc1`, and 1-1,024 for `standard`. If you specify a
  /// snapshot, the volume size must be equal to or larger than the snapshot
  /// size.
  ///
  /// Default: If you're creating the volume from a snapshot and don't specify a
  /// volume size, the default is the snapshot size.
  ///
  ///
  ///
  /// At least one of Size or SnapshotId is required.
  ///
  /// [snapshotId]: The snapshot from which to create the volume.
  ///
  ///
  ///
  /// At least one of Size or SnapshotId are required.
  ///
  /// [volumeType]: The volume type. This can be `gp2` for General Purpose SSD,
  /// `io1` for Provisioned IOPS SSD, `st1` for Throughput Optimized HDD, `sc1`
  /// for Cold HDD, or `standard` for Magnetic volumes.
  ///
  /// Default: `gp2`
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [tagSpecifications]: The tags to apply to the volume during creation.
  Future<Volume> createVolume(String availabilityZone,
      {bool encrypted,
      int iops,
      String kmsKeyId,
      int size,
      String snapshotId,
      String volumeType,
      bool dryRun,
      List<TagSpecification> tagSpecifications}) async {
    var response_ = await _client.send('CreateVolume', {
      'AvailabilityZone': availabilityZone,
      if (encrypted != null) 'Encrypted': encrypted,
      if (iops != null) 'Iops': iops,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      if (size != null) 'Size': size,
      if (snapshotId != null) 'SnapshotId': snapshotId,
      if (volumeType != null) 'VolumeType': volumeType,
      if (dryRun != null) 'DryRun': dryRun,
      if (tagSpecifications != null) 'TagSpecifications': tagSpecifications,
    });
    return Volume.fromJson(response_);
  }

  /// Creates a VPC with the specified IPv4 CIDR block. The smallest VPC you can
  /// create uses a /28 netmask (16 IPv4 addresses), and the largest uses a /16
  /// netmask (65,536 IPv4 addresses). For more information about how large to
  /// make your VPC, see
  /// [Your VPC and Subnets](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// You can optionally request an Amazon-provided IPv6 CIDR block for the VPC.
  /// The IPv6 CIDR block uses a /56 prefix length, and is allocated from
  /// Amazon's pool of IPv6 addresses. You cannot choose the IPv6 range for your
  /// VPC.
  ///
  /// By default, each instance you launch in the VPC has the default DHCP
  /// options, which include only a default DNS server that we provide
  /// (AmazonProvidedDNS). For more information, see
  /// [DHCP Options Sets](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_DHCP_Options.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// You can specify the instance tenancy value for the VPC when you create it.
  /// You can't change this value for the VPC after you create it. For more
  /// information, see
  /// [Dedicated Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-instance.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [cidrBlock]: The IPv4 network range for the VPC, in CIDR notation. For
  /// example, `10.0.0.0/16`.
  ///
  /// [amazonProvidedIpv6CidrBlock]: Requests an Amazon-provided IPv6 CIDR block
  /// with a /56 prefix length for the VPC. You cannot specify the range of IP
  /// addresses, or the size of the CIDR block.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [instanceTenancy]: The tenancy options for instances launched into the
  /// VPC. For `default`, instances are launched with shared tenancy by default.
  /// You can launch instances with any tenancy into a shared tenancy VPC. For
  /// `dedicated`, instances are launched as dedicated tenancy instances by
  /// default. You can only launch instances with a tenancy of `dedicated` or
  /// `host` into a dedicated tenancy VPC.
  ///
  ///  **Important:** The `host` value cannot be used with this parameter. Use
  /// the `default` or `dedicated` values only.
  ///
  /// Default: `default`
  Future<CreateVpcResult> createVpc(String cidrBlock,
      {bool amazonProvidedIpv6CidrBlock,
      bool dryRun,
      String instanceTenancy}) async {
    var response_ = await _client.send('CreateVpc', {
      'CidrBlock': cidrBlock,
      if (amazonProvidedIpv6CidrBlock != null)
        'AmazonProvidedIpv6CidrBlock': amazonProvidedIpv6CidrBlock,
      if (dryRun != null) 'DryRun': dryRun,
      if (instanceTenancy != null) 'InstanceTenancy': instanceTenancy,
    });
    return CreateVpcResult.fromJson(response_);
  }

  /// Creates a VPC endpoint for a specified service. An endpoint enables you to
  /// create a private connection between your VPC and the service. The service
  /// may be provided by AWS, an AWS Marketplace partner, or another AWS
  /// account. For more information, see
  /// [VPC Endpoints](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-endpoints.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// A `gateway` endpoint serves as a target for a route in your route table
  /// for traffic destined for the AWS service. You can specify an endpoint
  /// policy to attach to the endpoint that will control access to the service
  /// from your VPC. You can also specify the VPC route tables that use the
  /// endpoint.
  ///
  /// An `interface` endpoint is a network interface in your subnet that serves
  /// as an endpoint for communicating with the specified service. You can
  /// specify the subnets in which to create an endpoint, and the security
  /// groups to associate with the endpoint network interface.
  ///
  /// Use DescribeVpcEndpointServices to get a list of supported services.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [vpcEndpointType]: The type of endpoint.
  ///
  /// Default: Gateway
  ///
  /// [vpcId]: The ID of the VPC in which the endpoint will be used.
  ///
  /// [serviceName]: The service name. To get a list of available services, use
  /// the DescribeVpcEndpointServices request, or get the name from the service
  /// provider.
  ///
  /// [policyDocument]: A policy to attach to the endpoint that controls access
  /// to the service. The policy must be in valid JSON format. If this parameter
  /// is not specified, we attach a default policy that allows full access to
  /// the service.
  ///
  /// [routeTableIds]: (Gateway endpoint) One or more route table IDs.
  ///
  /// [subnetIds]: (Interface endpoint) The ID of one or more subnets in which
  /// to create an endpoint network interface.
  ///
  /// [securityGroupIds]: (Interface endpoint) The ID of one or more security
  /// groups to associate with the endpoint network interface.
  ///
  /// [clientToken]: Unique, case-sensitive identifier you provide to ensure the
  /// idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// [privateDnsEnabled]: (Interface endpoint) Indicate whether to associate a
  /// private hosted zone with the specified VPC. The private hosted zone
  /// contains a record set for the default public DNS name for the service for
  /// the Region (for example, `kinesis.us-east-1.amazonaws.com`) which resolves
  /// to the private IP addresses of the endpoint network interfaces in the VPC.
  /// This enables you to make requests to the default public DNS name for the
  /// service instead of the public DNS names that are automatically generated
  /// by the VPC endpoint service.
  ///
  /// To use a private hosted zone, you must set the following VPC attributes to
  /// `true`: `enableDnsHostnames` and `enableDnsSupport`. Use
  /// ModifyVpcAttribute to set the VPC attributes.
  ///
  /// Default: `true`
  Future<CreateVpcEndpointResult> createVpcEndpoint(
      {bool dryRun,
      String vpcEndpointType,
      @required String vpcId,
      @required String serviceName,
      String policyDocument,
      List<String> routeTableIds,
      List<String> subnetIds,
      List<String> securityGroupIds,
      String clientToken,
      bool privateDnsEnabled}) async {
    var response_ = await _client.send('CreateVpcEndpoint', {
      if (dryRun != null) 'DryRun': dryRun,
      if (vpcEndpointType != null) 'VpcEndpointType': vpcEndpointType,
      'VpcId': vpcId,
      'ServiceName': serviceName,
      if (policyDocument != null) 'PolicyDocument': policyDocument,
      if (routeTableIds != null) 'RouteTableIds': routeTableIds,
      if (subnetIds != null) 'SubnetIds': subnetIds,
      if (securityGroupIds != null) 'SecurityGroupIds': securityGroupIds,
      if (clientToken != null) 'ClientToken': clientToken,
      if (privateDnsEnabled != null) 'PrivateDnsEnabled': privateDnsEnabled,
    });
    return CreateVpcEndpointResult.fromJson(response_);
  }

  /// Creates a connection notification for a specified VPC endpoint or VPC
  /// endpoint service. A connection notification notifies you of specific
  /// endpoint events. You must create an SNS topic to receive notifications.
  /// For more information, see
  /// [Create a Topic](https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html)
  /// in the _Amazon Simple Notification Service Developer Guide_.
  ///
  /// You can create a connection notification for interface endpoints only.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [serviceId]: The ID of the endpoint service.
  ///
  /// [vpcEndpointId]: The ID of the endpoint.
  ///
  /// [connectionNotificationArn]: The ARN of the SNS topic for the
  /// notifications.
  ///
  /// [connectionEvents]: One or more endpoint events for which to receive
  /// notifications. Valid values are `Accept`, `Connect`, `Delete`, and
  /// `Reject`.
  ///
  /// [clientToken]: Unique, case-sensitive identifier you provide to ensure the
  /// idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  Future<CreateVpcEndpointConnectionNotificationResult>
      createVpcEndpointConnectionNotification(
          {bool dryRun,
          String serviceId,
          String vpcEndpointId,
          @required String connectionNotificationArn,
          @required List<String> connectionEvents,
          String clientToken}) async {
    var response_ =
        await _client.send('CreateVpcEndpointConnectionNotification', {
      if (dryRun != null) 'DryRun': dryRun,
      if (serviceId != null) 'ServiceId': serviceId,
      if (vpcEndpointId != null) 'VpcEndpointId': vpcEndpointId,
      'ConnectionNotificationArn': connectionNotificationArn,
      'ConnectionEvents': connectionEvents,
      if (clientToken != null) 'ClientToken': clientToken,
    });
    return CreateVpcEndpointConnectionNotificationResult.fromJson(response_);
  }

  /// Creates a VPC endpoint service configuration to which service consumers
  /// (AWS accounts, IAM users, and IAM roles) can connect. Service consumers
  /// can create an interface VPC endpoint to connect to your service.
  ///
  /// To create an endpoint service configuration, you must first create a
  /// Network Load Balancer for your service. For more information, see
  /// [VPC Endpoint Services](https://docs.aws.amazon.com/vpc/latest/userguide/endpoint-service.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [acceptanceRequired]: Indicate whether requests from service consumers to
  /// create an endpoint to your service must be accepted. To accept a request,
  /// use AcceptVpcEndpointConnections.
  ///
  /// [networkLoadBalancerArns]: The Amazon Resource Names (ARNs) of one or more
  /// Network Load Balancers for your service.
  ///
  /// [clientToken]: Unique, case-sensitive identifier you provide to ensure the
  /// idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
  Future<CreateVpcEndpointServiceConfigurationResult>
      createVpcEndpointServiceConfiguration(
          List<String> networkLoadBalancerArns,
          {bool dryRun,
          bool acceptanceRequired,
          String clientToken}) async {
    var response_ =
        await _client.send('CreateVpcEndpointServiceConfiguration', {
      if (dryRun != null) 'DryRun': dryRun,
      if (acceptanceRequired != null) 'AcceptanceRequired': acceptanceRequired,
      'NetworkLoadBalancerArns': networkLoadBalancerArns,
      if (clientToken != null) 'ClientToken': clientToken,
    });
    return CreateVpcEndpointServiceConfigurationResult.fromJson(response_);
  }

  /// Requests a VPC peering connection between two VPCs: a requester VPC that
  /// you own and an accepter VPC with which to create the connection. The
  /// accepter VPC can belong to another AWS account and can be in a different
  /// Region to the requester VPC. The requester VPC and accepter VPC cannot
  /// have overlapping CIDR blocks.
  ///
  ///  Limitations and rules apply to a VPC peering connection. For more
  /// information, see the
  /// [limitations](https://docs.aws.amazon.com/vpc/latest/peering/vpc-peering-basics.html#vpc-peering-limitations)
  /// section in the _VPC Peering Guide_.
  ///
  /// The owner of the accepter VPC must accept the peering request to activate
  /// the peering connection. The VPC peering connection request expires after 7
  /// days, after which it cannot be accepted or rejected.
  ///
  /// If you create a VPC peering connection request between VPCs with
  /// overlapping CIDR blocks, the VPC peering connection has a status of
  /// `failed`.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [peerOwnerId]: The AWS account ID of the owner of the accepter VPC.
  ///
  /// Default: Your AWS account ID
  ///
  /// [peerVpcId]: The ID of the VPC with which you are creating the VPC peering
  /// connection. You must specify this parameter in the request.
  ///
  /// [vpcId]: The ID of the requester VPC. You must specify this parameter in
  /// the request.
  ///
  /// [peerRegion]: The Region code for the accepter VPC, if the accepter VPC is
  /// located in a Region other than the Region in which you make the request.
  ///
  /// Default: The Region in which you make the request.
  Future<CreateVpcPeeringConnectionResult> createVpcPeeringConnection(
      {bool dryRun,
      String peerOwnerId,
      String peerVpcId,
      String vpcId,
      String peerRegion}) async {
    var response_ = await _client.send('CreateVpcPeeringConnection', {
      if (dryRun != null) 'DryRun': dryRun,
      if (peerOwnerId != null) 'PeerOwnerId': peerOwnerId,
      if (peerVpcId != null) 'PeerVpcId': peerVpcId,
      if (vpcId != null) 'VpcId': vpcId,
      if (peerRegion != null) 'PeerRegion': peerRegion,
    });
    return CreateVpcPeeringConnectionResult.fromJson(response_);
  }

  /// Creates a VPN connection between an existing virtual private gateway and a
  /// VPN customer gateway. The supported connection type is `ipsec.1`.
  ///
  /// The response includes information that you need to give to your network
  /// administrator to configure your customer gateway.
  ///
  ///  We strongly recommend that you use HTTPS when calling this operation
  /// because the response contains sensitive cryptographic information for
  /// configuring your customer gateway.
  ///
  /// If you decide to shut down your VPN connection for any reason and later
  /// create a new VPN connection, you must reconfigure your customer gateway
  /// with the new information returned from this call.
  ///
  /// This is an idempotent operation. If you perform the operation more than
  /// once, Amazon EC2 doesn't return an error.
  ///
  /// For more information, see
  /// [AWS Site-to-Site VPN](https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html)
  /// in the _AWS Site-to-Site VPN User Guide_.
  ///
  /// [customerGatewayId]: The ID of the customer gateway.
  ///
  /// [type]: The type of VPN connection (`ipsec.1`).
  ///
  /// [vpnGatewayId]: The ID of the virtual private gateway. If you specify a
  /// virtual private gateway, you cannot specify a transit gateway.
  ///
  /// [transitGatewayId]: The ID of the transit gateway. If you specify a
  /// transit gateway, you cannot specify a virtual private gateway.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [options]: The options for the VPN connection.
  Future<CreateVpnConnectionResult> createVpnConnection(
      {@required String customerGatewayId,
      @required String type,
      String vpnGatewayId,
      String transitGatewayId,
      bool dryRun,
      VpnConnectionOptionsSpecification options}) async {
    var response_ = await _client.send('CreateVpnConnection', {
      'CustomerGatewayId': customerGatewayId,
      'Type': type,
      if (vpnGatewayId != null) 'VpnGatewayId': vpnGatewayId,
      if (transitGatewayId != null) 'TransitGatewayId': transitGatewayId,
      if (dryRun != null) 'DryRun': dryRun,
      if (options != null) 'Options': options,
    });
    return CreateVpnConnectionResult.fromJson(response_);
  }

  /// Creates a static route associated with a VPN connection between an
  /// existing virtual private gateway and a VPN customer gateway. The static
  /// route allows traffic to be routed from the virtual private gateway to the
  /// VPN customer gateway.
  ///
  /// For more information, see
  /// [AWS Site-to-Site VPN](https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html)
  /// in the _AWS Site-to-Site VPN User Guide_.
  ///
  /// [destinationCidrBlock]: The CIDR block associated with the local subnet of
  /// the customer network.
  ///
  /// [vpnConnectionId]: The ID of the VPN connection.
  Future<void> createVpnConnectionRoute(
      {@required String destinationCidrBlock,
      @required String vpnConnectionId}) async {
    await _client.send('CreateVpnConnectionRoute', {
      'DestinationCidrBlock': destinationCidrBlock,
      'VpnConnectionId': vpnConnectionId,
    });
  }

  /// Creates a virtual private gateway. A virtual private gateway is the
  /// endpoint on the VPC side of your VPN connection. You can create a virtual
  /// private gateway before creating the VPC itself.
  ///
  /// For more information, see
  /// [AWS Site-to-Site VPN](https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html)
  /// in the _AWS Site-to-Site VPN User Guide_.
  ///
  /// [availabilityZone]: The Availability Zone for the virtual private gateway.
  ///
  /// [type]: The type of VPN connection this virtual private gateway supports.
  ///
  /// [amazonSideAsn]: A private Autonomous System Number (ASN) for the Amazon
  /// side of a BGP session. If you're using a 16-bit ASN, it must be in the
  /// 64512 to 65534 range. If you're using a 32-bit ASN, it must be in the
  /// 4200000000 to 4294967294 range.
  ///
  /// Default: 64512
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<CreateVpnGatewayResult> createVpnGateway(String type,
      {String availabilityZone, BigInt amazonSideAsn, bool dryRun}) async {
    var response_ = await _client.send('CreateVpnGateway', {
      if (availabilityZone != null) 'AvailabilityZone': availabilityZone,
      'Type': type,
      if (amazonSideAsn != null) 'AmazonSideAsn': amazonSideAsn,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return CreateVpnGatewayResult.fromJson(response_);
  }

  /// Deletes the specified Client VPN endpoint. You must disassociate all
  /// target networks before you can delete a Client VPN endpoint.
  ///
  /// [clientVpnEndpointId]: The ID of the Client VPN to be deleted.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DeleteClientVpnEndpointResult> deleteClientVpnEndpoint(
      String clientVpnEndpointId,
      {bool dryRun}) async {
    var response_ = await _client.send('DeleteClientVpnEndpoint', {
      'ClientVpnEndpointId': clientVpnEndpointId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DeleteClientVpnEndpointResult.fromJson(response_);
  }

  /// Deletes a route from a Client VPN endpoint. You can only delete routes
  /// that you manually added using the **CreateClientVpnRoute** action. You
  /// cannot delete routes that were automatically added when associating a
  /// subnet. To remove routes that have been automatically added, disassociate
  /// the target subnet from the Client VPN endpoint.
  ///
  /// [clientVpnEndpointId]: The ID of the Client VPN endpoint from which the
  /// route is to be deleted.
  ///
  /// [targetVpcSubnetId]: The ID of the target subnet used by the route.
  ///
  /// [destinationCidrBlock]: The IPv4 address range, in CIDR notation, of the
  /// route to be deleted.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DeleteClientVpnRouteResult> deleteClientVpnRoute(
      {@required String clientVpnEndpointId,
      String targetVpcSubnetId,
      @required String destinationCidrBlock,
      bool dryRun}) async {
    var response_ = await _client.send('DeleteClientVpnRoute', {
      'ClientVpnEndpointId': clientVpnEndpointId,
      if (targetVpcSubnetId != null) 'TargetVpcSubnetId': targetVpcSubnetId,
      'DestinationCidrBlock': destinationCidrBlock,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DeleteClientVpnRouteResult.fromJson(response_);
  }

  /// Deletes the specified customer gateway. You must delete the VPN connection
  /// before you can delete the customer gateway.
  ///
  /// [customerGatewayId]: The ID of the customer gateway.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> deleteCustomerGateway(String customerGatewayId,
      {bool dryRun}) async {
    await _client.send('DeleteCustomerGateway', {
      'CustomerGatewayId': customerGatewayId,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Deletes the specified set of DHCP options. You must disassociate the set
  /// of DHCP options before you can delete it. You can disassociate the set of
  /// DHCP options by associating either a new set of options or the default set
  /// of options with the VPC.
  ///
  /// [dhcpOptionsId]: The ID of the DHCP options set.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> deleteDhcpOptions(String dhcpOptionsId, {bool dryRun}) async {
    await _client.send('DeleteDhcpOptions', {
      'DhcpOptionsId': dhcpOptionsId,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Deletes an egress-only internet gateway.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [egressOnlyInternetGatewayId]: The ID of the egress-only internet gateway.
  Future<DeleteEgressOnlyInternetGatewayResult> deleteEgressOnlyInternetGateway(
      String egressOnlyInternetGatewayId,
      {bool dryRun}) async {
    var response_ = await _client.send('DeleteEgressOnlyInternetGateway', {
      if (dryRun != null) 'DryRun': dryRun,
      'EgressOnlyInternetGatewayId': egressOnlyInternetGatewayId,
    });
    return DeleteEgressOnlyInternetGatewayResult.fromJson(response_);
  }

  /// Deletes the specified EC2 Fleet.
  ///
  /// After you delete an EC2 Fleet, it launches no new instances. You must
  /// specify whether an EC2 Fleet should also terminate its instances. If you
  /// terminate the instances, the EC2 Fleet enters the `deleted_terminating`
  /// state. Otherwise, the EC2 Fleet enters the `deleted_running` state, and
  /// the instances continue to run until they are interrupted or you terminate
  /// them manually.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [fleetIds]: The IDs of the EC2 Fleets.
  ///
  /// [terminateInstances]: Indicates whether to terminate instances for an EC2
  /// Fleet if it is deleted successfully.
  Future<DeleteFleetsResult> deleteFleets(
      {bool dryRun,
      @required List<String> fleetIds,
      @required bool terminateInstances}) async {
    var response_ = await _client.send('DeleteFleets', {
      if (dryRun != null) 'DryRun': dryRun,
      'FleetIds': fleetIds,
      'TerminateInstances': terminateInstances,
    });
    return DeleteFleetsResult.fromJson(response_);
  }

  /// Deletes one or more flow logs.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [flowLogIds]: One or more flow log IDs.
  ///
  /// Constraint: Maximum of 1000 flow log IDs.
  Future<DeleteFlowLogsResult> deleteFlowLogs(List<String> flowLogIds,
      {bool dryRun}) async {
    var response_ = await _client.send('DeleteFlowLogs', {
      if (dryRun != null) 'DryRun': dryRun,
      'FlowLogIds': flowLogIds,
    });
    return DeleteFlowLogsResult.fromJson(response_);
  }

  /// Deletes the specified Amazon FPGA Image (AFI).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [fpgaImageId]: The ID of the AFI.
  Future<DeleteFpgaImageResult> deleteFpgaImage(String fpgaImageId,
      {bool dryRun}) async {
    var response_ = await _client.send('DeleteFpgaImage', {
      if (dryRun != null) 'DryRun': dryRun,
      'FpgaImageId': fpgaImageId,
    });
    return DeleteFpgaImageResult.fromJson(response_);
  }

  /// Deletes the specified internet gateway. You must detach the internet
  /// gateway from the VPC before you can delete it.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [internetGatewayId]: The ID of the internet gateway.
  Future<void> deleteInternetGateway(String internetGatewayId,
      {bool dryRun}) async {
    await _client.send('DeleteInternetGateway', {
      if (dryRun != null) 'DryRun': dryRun,
      'InternetGatewayId': internetGatewayId,
    });
  }

  /// Deletes the specified key pair, by removing the public key from Amazon
  /// EC2.
  ///
  /// [keyName]: The name of the key pair.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> deleteKeyPair(String keyName, {bool dryRun}) async {
    await _client.send('DeleteKeyPair', {
      'KeyName': keyName,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Deletes a launch template. Deleting a launch template deletes all of its
  /// versions.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [launchTemplateId]: The ID of the launch template. You must specify either
  /// the launch template ID or launch template name in the request.
  ///
  /// [launchTemplateName]: The name of the launch template. You must specify
  /// either the launch template ID or launch template name in the request.
  Future<DeleteLaunchTemplateResult> deleteLaunchTemplate(
      {bool dryRun, String launchTemplateId, String launchTemplateName}) async {
    var response_ = await _client.send('DeleteLaunchTemplate', {
      if (dryRun != null) 'DryRun': dryRun,
      if (launchTemplateId != null) 'LaunchTemplateId': launchTemplateId,
      if (launchTemplateName != null) 'LaunchTemplateName': launchTemplateName,
    });
    return DeleteLaunchTemplateResult.fromJson(response_);
  }

  /// Deletes one or more versions of a launch template. You cannot delete the
  /// default version of a launch template; you must first assign a different
  /// version as the default. If the default version is the only version for the
  /// launch template, you must delete the entire launch template using
  /// DeleteLaunchTemplate.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [launchTemplateId]: The ID of the launch template. You must specify either
  /// the launch template ID or launch template name in the request.
  ///
  /// [launchTemplateName]: The name of the launch template. You must specify
  /// either the launch template ID or launch template name in the request.
  ///
  /// [versions]: The version numbers of one or more launch template versions to
  /// delete.
  Future<DeleteLaunchTemplateVersionsResult> deleteLaunchTemplateVersions(
      List<String> versions,
      {bool dryRun,
      String launchTemplateId,
      String launchTemplateName}) async {
    var response_ = await _client.send('DeleteLaunchTemplateVersions', {
      if (dryRun != null) 'DryRun': dryRun,
      if (launchTemplateId != null) 'LaunchTemplateId': launchTemplateId,
      if (launchTemplateName != null) 'LaunchTemplateName': launchTemplateName,
      'Versions': versions,
    });
    return DeleteLaunchTemplateVersionsResult.fromJson(response_);
  }

  /// Deletes the specified NAT gateway. Deleting a NAT gateway disassociates
  /// its Elastic IP address, but does not release the address from your
  /// account. Deleting a NAT gateway does not delete any NAT gateway routes in
  /// your route tables.
  ///
  /// [natGatewayId]: The ID of the NAT gateway.
  Future<DeleteNatGatewayResult> deleteNatGateway(String natGatewayId) async {
    var response_ = await _client.send('DeleteNatGateway', {
      'NatGatewayId': natGatewayId,
    });
    return DeleteNatGatewayResult.fromJson(response_);
  }

  /// Deletes the specified network ACL. You can't delete the ACL if it's
  /// associated with any subnets. You can't delete the default network ACL.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [networkAclId]: The ID of the network ACL.
  Future<void> deleteNetworkAcl(String networkAclId, {bool dryRun}) async {
    await _client.send('DeleteNetworkAcl', {
      if (dryRun != null) 'DryRun': dryRun,
      'NetworkAclId': networkAclId,
    });
  }

  /// Deletes the specified ingress or egress entry (rule) from the specified
  /// network ACL.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [egress]: Indicates whether the rule is an egress rule.
  ///
  /// [networkAclId]: The ID of the network ACL.
  ///
  /// [ruleNumber]: The rule number of the entry to delete.
  Future<void> deleteNetworkAclEntry(
      {bool dryRun,
      @required bool egress,
      @required String networkAclId,
      @required int ruleNumber}) async {
    await _client.send('DeleteNetworkAclEntry', {
      if (dryRun != null) 'DryRun': dryRun,
      'Egress': egress,
      'NetworkAclId': networkAclId,
      'RuleNumber': ruleNumber,
    });
  }

  /// Deletes the specified network interface. You must detach the network
  /// interface before you can delete it.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [networkInterfaceId]: The ID of the network interface.
  Future<void> deleteNetworkInterface(String networkInterfaceId,
      {bool dryRun}) async {
    await _client.send('DeleteNetworkInterface', {
      if (dryRun != null) 'DryRun': dryRun,
      'NetworkInterfaceId': networkInterfaceId,
    });
  }

  /// Deletes a permission for a network interface. By default, you cannot
  /// delete the permission if the account for which you're removing the
  /// permission has attached the network interface to an instance. However, you
  /// can force delete the permission, regardless of any attachment.
  ///
  /// [networkInterfacePermissionId]: The ID of the network interface
  /// permission.
  ///
  /// [force]: Specify `true` to remove the permission even if the network
  /// interface is attached to an instance.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DeleteNetworkInterfacePermissionResult>
      deleteNetworkInterfacePermission(String networkInterfacePermissionId,
          {bool force, bool dryRun}) async {
    var response_ = await _client.send('DeleteNetworkInterfacePermission', {
      'NetworkInterfacePermissionId': networkInterfacePermissionId,
      if (force != null) 'Force': force,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DeleteNetworkInterfacePermissionResult.fromJson(response_);
  }

  /// Deletes the specified placement group. You must terminate all instances in
  /// the placement group before you can delete the placement group. For more
  /// information, see
  /// [Placement Groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [groupName]: The name of the placement group.
  Future<void> deletePlacementGroup(String groupName, {bool dryRun}) async {
    await _client.send('DeletePlacementGroup', {
      if (dryRun != null) 'DryRun': dryRun,
      'GroupName': groupName,
    });
  }

  /// Deletes the specified route from the specified route table.
  ///
  /// [destinationCidrBlock]: The IPv4 CIDR range for the route. The value you
  /// specify must match the CIDR for the route exactly.
  ///
  /// [destinationIpv6CidrBlock]: The IPv6 CIDR range for the route. The value
  /// you specify must match the CIDR for the route exactly.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [routeTableId]: The ID of the route table.
  Future<void> deleteRoute(String routeTableId,
      {String destinationCidrBlock,
      String destinationIpv6CidrBlock,
      bool dryRun}) async {
    await _client.send('DeleteRoute', {
      if (destinationCidrBlock != null)
        'DestinationCidrBlock': destinationCidrBlock,
      if (destinationIpv6CidrBlock != null)
        'DestinationIpv6CidrBlock': destinationIpv6CidrBlock,
      if (dryRun != null) 'DryRun': dryRun,
      'RouteTableId': routeTableId,
    });
  }

  /// Deletes the specified route table. You must disassociate the route table
  /// from any subnets before you can delete it. You can't delete the main route
  /// table.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [routeTableId]: The ID of the route table.
  Future<void> deleteRouteTable(String routeTableId, {bool dryRun}) async {
    await _client.send('DeleteRouteTable', {
      if (dryRun != null) 'DryRun': dryRun,
      'RouteTableId': routeTableId,
    });
  }

  /// Deletes a security group.
  ///
  /// If you attempt to delete a security group that is associated with an
  /// instance, or is referenced by another security group, the operation fails
  /// with `InvalidGroup.InUse` in EC2-Classic or `DependencyViolation` in
  /// EC2-VPC.
  ///
  /// [groupId]: The ID of the security group. Required for a nondefault VPC.
  ///
  /// [groupName]: [EC2-Classic, default VPC] The name of the security group.
  /// You can specify either the security group name or the security group ID.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> deleteSecurityGroup(
      {String groupId, String groupName, bool dryRun}) async {
    await _client.send('DeleteSecurityGroup', {
      if (groupId != null) 'GroupId': groupId,
      if (groupName != null) 'GroupName': groupName,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Deletes the specified snapshot.
  ///
  /// When you make periodic snapshots of a volume, the snapshots are
  /// incremental, and only the blocks on the device that have changed since
  /// your last snapshot are saved in the new snapshot. When you delete a
  /// snapshot, only the data not needed for any other snapshot is removed. So
  /// regardless of which prior snapshots have been deleted, all active
  /// snapshots will have access to all the information needed to restore the
  /// volume.
  ///
  /// You cannot delete a snapshot of the root device of an EBS volume used by a
  /// registered AMI. You must first de-register the AMI before you can delete
  /// the snapshot.
  ///
  /// For more information, see
  /// [Deleting an Amazon EBS Snapshot](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-deleting-snapshot.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [snapshotId]: The ID of the EBS snapshot.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> deleteSnapshot(String snapshotId, {bool dryRun}) async {
    await _client.send('DeleteSnapshot', {
      'SnapshotId': snapshotId,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Deletes the data feed for Spot Instances.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> deleteSpotDatafeedSubscription({bool dryRun}) async {
    await _client.send('DeleteSpotDatafeedSubscription', {
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Deletes the specified subnet. You must terminate all running instances in
  /// the subnet before you can delete the subnet.
  ///
  /// [subnetId]: The ID of the subnet.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> deleteSubnet(String subnetId, {bool dryRun}) async {
    await _client.send('DeleteSubnet', {
      'SubnetId': subnetId,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Deletes the specified set of tags from the specified set of resources.
  ///
  /// To list the current tags, use DescribeTags. For more information about
  /// tags, see
  /// [Tagging Your Resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [resources]: The IDs of the resources, separated by spaces.
  ///
  /// Constraints: Up to 1000 resource IDs. We recommend breaking up this
  /// request into smaller batches.
  ///
  /// [tags]: The tags to delete. Specify a tag key and an optional tag value to
  /// delete specific tags. If you specify a tag key without a tag value, we
  /// delete any tag with this key regardless of its value. If you specify a tag
  /// key with an empty string as the tag value, we delete the tag only if its
  /// value is an empty string.
  ///
  /// If you omit this parameter, we delete all user-defined tags for the
  /// specified resources. We do not delete AWS-generated tags (tags that have
  /// the `aws:` prefix).
  Future<void> deleteTags(List<String> resources,
      {bool dryRun, List<Tag> tags}) async {
    await _client.send('DeleteTags', {
      if (dryRun != null) 'DryRun': dryRun,
      'Resources': resources,
      if (tags != null) 'Tags': tags,
    });
  }

  /// Deletes the specified Traffic Mirror filter.
  ///
  /// You cannot delete a Traffic Mirror filter that is in use by a Traffic
  /// Mirror session.
  ///
  /// [trafficMirrorFilterId]: The ID of the Traffic Mirror filter.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DeleteTrafficMirrorFilterResult> deleteTrafficMirrorFilter(
      String trafficMirrorFilterId,
      {bool dryRun}) async {
    var response_ = await _client.send('DeleteTrafficMirrorFilter', {
      'TrafficMirrorFilterId': trafficMirrorFilterId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DeleteTrafficMirrorFilterResult.fromJson(response_);
  }

  /// Deletes the specified Traffic Mirror rule.
  ///
  /// [trafficMirrorFilterRuleId]: The ID of the Traffic Mirror rule.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DeleteTrafficMirrorFilterRuleResult> deleteTrafficMirrorFilterRule(
      String trafficMirrorFilterRuleId,
      {bool dryRun}) async {
    var response_ = await _client.send('DeleteTrafficMirrorFilterRule', {
      'TrafficMirrorFilterRuleId': trafficMirrorFilterRuleId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DeleteTrafficMirrorFilterRuleResult.fromJson(response_);
  }

  /// Deletes the specified Traffic Mirror session.
  ///
  /// [trafficMirrorSessionId]: The ID of the Traffic Mirror session.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DeleteTrafficMirrorSessionResult> deleteTrafficMirrorSession(
      String trafficMirrorSessionId,
      {bool dryRun}) async {
    var response_ = await _client.send('DeleteTrafficMirrorSession', {
      'TrafficMirrorSessionId': trafficMirrorSessionId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DeleteTrafficMirrorSessionResult.fromJson(response_);
  }

  /// Deletes the specified Traffic Mirror target.
  ///
  /// You cannot delete a Traffic Mirror target that is in use by a Traffic
  /// Mirror session.
  ///
  /// [trafficMirrorTargetId]: The ID of the Traffic Mirror target.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DeleteTrafficMirrorTargetResult> deleteTrafficMirrorTarget(
      String trafficMirrorTargetId,
      {bool dryRun}) async {
    var response_ = await _client.send('DeleteTrafficMirrorTarget', {
      'TrafficMirrorTargetId': trafficMirrorTargetId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DeleteTrafficMirrorTargetResult.fromJson(response_);
  }

  /// Deletes the specified transit gateway.
  ///
  /// [transitGatewayId]: The ID of the transit gateway.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DeleteTransitGatewayResult> deleteTransitGateway(
      String transitGatewayId,
      {bool dryRun}) async {
    var response_ = await _client.send('DeleteTransitGateway', {
      'TransitGatewayId': transitGatewayId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DeleteTransitGatewayResult.fromJson(response_);
  }

  /// Deletes the specified route from the specified transit gateway route
  /// table.
  ///
  /// [transitGatewayRouteTableId]: The ID of the transit gateway route table.
  ///
  /// [destinationCidrBlock]: The CIDR range for the route. This must match the
  /// CIDR for the route exactly.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DeleteTransitGatewayRouteResult> deleteTransitGatewayRoute(
      {@required String transitGatewayRouteTableId,
      @required String destinationCidrBlock,
      bool dryRun}) async {
    var response_ = await _client.send('DeleteTransitGatewayRoute', {
      'TransitGatewayRouteTableId': transitGatewayRouteTableId,
      'DestinationCidrBlock': destinationCidrBlock,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DeleteTransitGatewayRouteResult.fromJson(response_);
  }

  /// Deletes the specified transit gateway route table. You must disassociate
  /// the route table from any transit gateway route tables before you can
  /// delete it.
  ///
  /// [transitGatewayRouteTableId]: The ID of the transit gateway route table.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DeleteTransitGatewayRouteTableResult> deleteTransitGatewayRouteTable(
      String transitGatewayRouteTableId,
      {bool dryRun}) async {
    var response_ = await _client.send('DeleteTransitGatewayRouteTable', {
      'TransitGatewayRouteTableId': transitGatewayRouteTableId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DeleteTransitGatewayRouteTableResult.fromJson(response_);
  }

  /// Deletes the specified VPC attachment.
  ///
  /// [transitGatewayAttachmentId]: The ID of the attachment.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DeleteTransitGatewayVpcAttachmentResult>
      deleteTransitGatewayVpcAttachment(String transitGatewayAttachmentId,
          {bool dryRun}) async {
    var response_ = await _client.send('DeleteTransitGatewayVpcAttachment', {
      'TransitGatewayAttachmentId': transitGatewayAttachmentId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DeleteTransitGatewayVpcAttachmentResult.fromJson(response_);
  }

  /// Deletes the specified EBS volume. The volume must be in the `available`
  /// state (not attached to an instance).
  ///
  /// The volume can remain in the `deleting` state for several minutes.
  ///
  /// For more information, see
  /// [Deleting an Amazon EBS Volume](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-deleting-volume.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [volumeId]: The ID of the volume.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> deleteVolume(String volumeId, {bool dryRun}) async {
    await _client.send('DeleteVolume', {
      'VolumeId': volumeId,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Deletes the specified VPC. You must detach or delete all gateways and
  /// resources that are associated with the VPC before you can delete it. For
  /// example, you must terminate all instances running in the VPC, delete all
  /// security groups associated with the VPC (except the default one), delete
  /// all route tables associated with the VPC (except the default one), and so
  /// on.
  ///
  /// [vpcId]: The ID of the VPC.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> deleteVpc(String vpcId, {bool dryRun}) async {
    await _client.send('DeleteVpc', {
      'VpcId': vpcId,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Deletes one or more VPC endpoint connection notifications.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [connectionNotificationIds]: One or more notification IDs.
  Future<DeleteVpcEndpointConnectionNotificationsResult>
      deleteVpcEndpointConnectionNotifications(
          List<String> connectionNotificationIds,
          {bool dryRun}) async {
    var response_ =
        await _client.send('DeleteVpcEndpointConnectionNotifications', {
      if (dryRun != null) 'DryRun': dryRun,
      'ConnectionNotificationIds': connectionNotificationIds,
    });
    return DeleteVpcEndpointConnectionNotificationsResult.fromJson(response_);
  }

  /// Deletes one or more VPC endpoint service configurations in your account.
  /// Before you delete the endpoint service configuration, you must reject any
  /// `Available` or `PendingAcceptance` interface endpoint connections that are
  /// attached to the service.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [serviceIds]: The IDs of one or more services.
  Future<DeleteVpcEndpointServiceConfigurationsResult>
      deleteVpcEndpointServiceConfigurations(List<String> serviceIds,
          {bool dryRun}) async {
    var response_ =
        await _client.send('DeleteVpcEndpointServiceConfigurations', {
      if (dryRun != null) 'DryRun': dryRun,
      'ServiceIds': serviceIds,
    });
    return DeleteVpcEndpointServiceConfigurationsResult.fromJson(response_);
  }

  /// Deletes one or more specified VPC endpoints. Deleting a gateway endpoint
  /// also deletes the endpoint routes in the route tables that were associated
  /// with the endpoint. Deleting an interface endpoint deletes the endpoint
  /// network interfaces.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [vpcEndpointIds]: One or more VPC endpoint IDs.
  Future<DeleteVpcEndpointsResult> deleteVpcEndpoints(
      List<String> vpcEndpointIds,
      {bool dryRun}) async {
    var response_ = await _client.send('DeleteVpcEndpoints', {
      if (dryRun != null) 'DryRun': dryRun,
      'VpcEndpointIds': vpcEndpointIds,
    });
    return DeleteVpcEndpointsResult.fromJson(response_);
  }

  /// Deletes a VPC peering connection. Either the owner of the requester VPC or
  /// the owner of the accepter VPC can delete the VPC peering connection if
  /// it's in the `active` state. The owner of the requester VPC can delete a
  /// VPC peering connection in the `pending-acceptance` state. You cannot
  /// delete a VPC peering connection that's in the `failed` state.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [vpcPeeringConnectionId]: The ID of the VPC peering connection.
  Future<DeleteVpcPeeringConnectionResult> deleteVpcPeeringConnection(
      String vpcPeeringConnectionId,
      {bool dryRun}) async {
    var response_ = await _client.send('DeleteVpcPeeringConnection', {
      if (dryRun != null) 'DryRun': dryRun,
      'VpcPeeringConnectionId': vpcPeeringConnectionId,
    });
    return DeleteVpcPeeringConnectionResult.fromJson(response_);
  }

  /// Deletes the specified VPN connection.
  ///
  /// If you're deleting the VPC and its associated components, we recommend
  /// that you detach the virtual private gateway from the VPC and delete the
  /// VPC before deleting the VPN connection. If you believe that the tunnel
  /// credentials for your VPN connection have been compromised, you can delete
  /// the VPN connection and create a new one that has new keys, without needing
  /// to delete the VPC or virtual private gateway. If you create a new VPN
  /// connection, you must reconfigure the customer gateway using the new
  /// configuration information returned with the new VPN connection ID.
  ///
  /// [vpnConnectionId]: The ID of the VPN connection.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> deleteVpnConnection(String vpnConnectionId,
      {bool dryRun}) async {
    await _client.send('DeleteVpnConnection', {
      'VpnConnectionId': vpnConnectionId,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Deletes the specified static route associated with a VPN connection
  /// between an existing virtual private gateway and a VPN customer gateway.
  /// The static route allows traffic to be routed from the virtual private
  /// gateway to the VPN customer gateway.
  ///
  /// [destinationCidrBlock]: The CIDR block associated with the local subnet of
  /// the customer network.
  ///
  /// [vpnConnectionId]: The ID of the VPN connection.
  Future<void> deleteVpnConnectionRoute(
      {@required String destinationCidrBlock,
      @required String vpnConnectionId}) async {
    await _client.send('DeleteVpnConnectionRoute', {
      'DestinationCidrBlock': destinationCidrBlock,
      'VpnConnectionId': vpnConnectionId,
    });
  }

  /// Deletes the specified virtual private gateway. We recommend that before
  /// you delete a virtual private gateway, you detach it from the VPC and
  /// delete the VPN connection. Note that you don't need to delete the virtual
  /// private gateway if you plan to delete and recreate the VPN connection
  /// between your VPC and your network.
  ///
  /// [vpnGatewayId]: The ID of the virtual private gateway.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> deleteVpnGateway(String vpnGatewayId, {bool dryRun}) async {
    await _client.send('DeleteVpnGateway', {
      'VpnGatewayId': vpnGatewayId,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Releases the specified address range that you provisioned for use with
  /// your AWS resources through bring your own IP addresses (BYOIP) and deletes
  /// the corresponding address pool.
  ///
  /// Before you can release an address range, you must stop advertising it
  /// using WithdrawByoipCidr and you must not have any IP addresses allocated
  /// from its address range.
  ///
  /// [cidr]: The public IPv4 address range, in CIDR notation. The prefix must
  /// be the same prefix that you specified when you provisioned the address
  /// range.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DeprovisionByoipCidrResult> deprovisionByoipCidr(String cidr,
      {bool dryRun}) async {
    var response_ = await _client.send('DeprovisionByoipCidr', {
      'Cidr': cidr,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DeprovisionByoipCidrResult.fromJson(response_);
  }

  /// Deregisters the specified AMI. After you deregister an AMI, it can't be
  /// used to launch new instances; however, it doesn't affect any instances
  /// that you've already launched from the AMI. You'll continue to incur usage
  /// costs for those instances until you terminate them.
  ///
  /// When you deregister an Amazon EBS-backed AMI, it doesn't affect the
  /// snapshot that was created for the root volume of the instance during the
  /// AMI creation process. When you deregister an instance store-backed AMI, it
  /// doesn't affect the files that you uploaded to Amazon S3 when you created
  /// the AMI.
  ///
  /// [imageId]: The ID of the AMI.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> deregisterImage(String imageId, {bool dryRun}) async {
    await _client.send('DeregisterImage', {
      'ImageId': imageId,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Describes attributes of your AWS account. The following are the supported
  /// account attributes:
  ///
  /// *    `supported-platforms`: Indicates whether your account can launch
  /// instances into EC2-Classic and EC2-VPC, or only into EC2-VPC.
  ///
  /// *    `default-vpc`: The ID of the default VPC for your account, or `none`.
  ///
  /// *    `max-instances`: The maximum number of On-Demand Instances that you
  /// can run.
  ///
  /// *    `vpc-max-security-groups-per-interface`: The maximum number of
  /// security groups that you can assign to a network interface.
  ///
  /// *    `max-elastic-ips`: The maximum number of Elastic IP addresses that
  /// you can allocate for use with EC2-Classic.
  ///
  /// *    `vpc-max-elastic-ips`: The maximum number of Elastic IP addresses
  /// that you can allocate for use with EC2-VPC.
  ///
  /// [attributeNames]: The account attribute names.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeAccountAttributesResult> describeAccountAttributes(
      {List<String> attributeNames, bool dryRun}) async {
    var response_ = await _client.send('DescribeAccountAttributes', {
      if (attributeNames != null) 'AttributeNames': attributeNames,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeAccountAttributesResult.fromJson(response_);
  }

  /// Describes the specified Elastic IP addresses or all of your Elastic IP
  /// addresses.
  ///
  /// An Elastic IP address is for use in either the EC2-Classic platform or in
  /// a VPC. For more information, see
  /// [Elastic IP Addresses](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [filters]: One or more filters. Filter names and values are
  /// case-sensitive.
  ///
  /// *    `allocation-id` - [EC2-VPC] The allocation ID for the address.
  ///
  /// *    `association-id` - [EC2-VPC] The association ID for the address.
  ///
  /// *    `domain` - Indicates whether the address is for use in EC2-Classic
  /// (`standard`) or in a VPC (`vpc`).
  ///
  /// *    `instance-id` - The ID of the instance the address is associated
  /// with, if any.
  ///
  /// *    `network-interface-id` - [EC2-VPC] The ID of the network interface
  /// that the address is associated with, if any.
  ///
  /// *    `network-interface-owner-id` - The AWS account ID of the owner.
  ///
  /// *    `private-ip-address` - [EC2-VPC] The private IP address associated
  /// with the Elastic IP address.
  ///
  /// *    `public-ip` - The Elastic IP address.
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// [publicIps]: One or more Elastic IP addresses.
  ///
  /// Default: Describes all your Elastic IP addresses.
  ///
  /// [allocationIds]: [EC2-VPC] Information about the allocation IDs.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeAddressesResult> describeAddresses(
      {List<Filter> filters,
      List<String> publicIps,
      List<String> allocationIds,
      bool dryRun}) async {
    var response_ = await _client.send('DescribeAddresses', {
      if (filters != null) 'Filters': filters,
      if (publicIps != null) 'PublicIps': publicIps,
      if (allocationIds != null) 'AllocationIds': allocationIds,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeAddressesResult.fromJson(response_);
  }

  /// Describes the longer ID format settings for all resource types in a
  /// specific Region. This request is useful for performing a quick audit to
  /// determine whether a specific Region is fully opted in for longer IDs
  /// (17-character IDs).
  ///
  /// This request only returns information about resource types that support
  /// longer IDs.
  ///
  /// The following resource types support longer IDs: `bundle` |
  /// `conversion-task` | `customer-gateway` | `dhcp-options` |
  /// `elastic-ip-allocation` | `elastic-ip-association` | `export-task` |
  /// `flow-log` | `image` | `import-task` | `instance` | `internet-gateway` |
  /// `network-acl` | `network-acl-association` | `network-interface` |
  /// `network-interface-attachment` | `prefix-list` | `reservation` |
  /// `route-table` | `route-table-association` | `security-group` | `snapshot`
  /// | `subnet` | `subnet-cidr-block-association` | `volume` | `vpc` |
  /// `vpc-cidr-block-association` | `vpc-endpoint` | `vpc-peering-connection` |
  /// `vpn-connection` | `vpn-gateway`.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeAggregateIdFormatResult> describeAggregateIdFormat(
      {bool dryRun}) async {
    var response_ = await _client.send('DescribeAggregateIdFormat', {
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeAggregateIdFormatResult.fromJson(response_);
  }

  /// Describes the Availability Zones that are available to you. The results
  /// include zones only for the Region you're currently using. If there is an
  /// event impacting an Availability Zone, you can use this request to view the
  /// state and any provided message for that Availability Zone.
  ///
  /// For more information, see
  /// [Regions and Availability Zones](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [filters]: The filters.
  ///
  /// *    `message` - Information about the Availability Zone.
  ///
  /// *    `region-name` - The name of the Region for the Availability Zone (for
  /// example, `us-east-1`).
  ///
  /// *    `state` - The state of the Availability Zone (`available` |
  /// `information` | `impaired` | `unavailable`).
  ///
  /// *    `zone-id` - The ID of the Availability Zone (for example,
  /// `use1-az1`).
  ///
  /// *    `zone-name` - The name of the Availability Zone (for example,
  /// `us-east-1a`).
  ///
  /// [zoneNames]: The names of the Availability Zones.
  ///
  /// [zoneIds]: The IDs of the Availability Zones.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeAvailabilityZonesResult> describeAvailabilityZones(
      {List<Filter> filters,
      List<String> zoneNames,
      List<String> zoneIds,
      bool dryRun}) async {
    var response_ = await _client.send('DescribeAvailabilityZones', {
      if (filters != null) 'Filters': filters,
      if (zoneNames != null) 'ZoneNames': zoneNames,
      if (zoneIds != null) 'ZoneIds': zoneIds,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeAvailabilityZonesResult.fromJson(response_);
  }

  /// Describes the specified bundle tasks or all of your bundle tasks.
  ///
  ///
  ///
  /// Completed bundle tasks are listed for only a limited time. If your bundle
  /// task is no longer in the list, you can still register an AMI from it. Just
  /// use `RegisterImage` with the Amazon S3 bucket name and image manifest name
  /// you provided to the bundle task.
  ///
  /// [bundleIds]: The bundle task IDs.
  ///
  /// Default: Describes all your bundle tasks.
  ///
  /// [filters]: The filters.
  ///
  /// *    `bundle-id` - The ID of the bundle task.
  ///
  /// *    `error-code` - If the task failed, the error code returned.
  ///
  /// *    `error-message` - If the task failed, the error message returned.
  ///
  /// *    `instance-id` - The ID of the instance.
  ///
  /// *    `progress` - The level of task completion, as a percentage (for
  /// example, 20%).
  ///
  /// *    `s3-bucket` - The Amazon S3 bucket to store the AMI.
  ///
  /// *    `s3-prefix` - The beginning of the AMI name.
  ///
  /// *    `start-time` - The time the task started (for example,
  /// 2013-09-15T17:15:20.000Z).
  ///
  /// *    `state` - The state of the task (`pending` | `waiting-for-shutdown` |
  /// `bundling` | `storing` | `cancelling` | `complete` | `failed`).
  ///
  /// *    `update-time` - The time of the most recent update for the task.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeBundleTasksResult> describeBundleTasks(
      {List<String> bundleIds, List<Filter> filters, bool dryRun}) async {
    var response_ = await _client.send('DescribeBundleTasks', {
      if (bundleIds != null) 'BundleIds': bundleIds,
      if (filters != null) 'Filters': filters,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeBundleTasksResult.fromJson(response_);
  }

  /// Describes the IP address ranges that were specified in calls to
  /// ProvisionByoipCidr.
  ///
  /// To describe the address pools that were created when you provisioned the
  /// address ranges, use DescribePublicIpv4Pools.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  ///
  /// [nextToken]: The token for the next page of results.
  Future<DescribeByoipCidrsResult> describeByoipCidrs(int maxResults,
      {bool dryRun, String nextToken}) async {
    var response_ = await _client.send('DescribeByoipCidrs', {
      if (dryRun != null) 'DryRun': dryRun,
      'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeByoipCidrsResult.fromJson(response_);
  }

  /// Describes one or more of your Capacity Reservations. The results describe
  /// only the Capacity Reservations in the AWS Region that you're currently
  /// using.
  ///
  /// [capacityReservationIds]: The ID of the Capacity Reservation.
  ///
  /// [nextToken]: The token to retrieve the next page of results.
  ///
  /// [maxResults]: The maximum number of results to return for the request in a
  /// single page. The remaining results can be seen by sending another request
  /// with the returned nextToken value.
  ///
  /// [filters]: One or more filters.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeCapacityReservationsResult> describeCapacityReservations(
      {List<String> capacityReservationIds,
      String nextToken,
      int maxResults,
      List<Filter> filters,
      bool dryRun}) async {
    var response_ = await _client.send('DescribeCapacityReservations', {
      if (capacityReservationIds != null)
        'CapacityReservationIds': capacityReservationIds,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
      if (filters != null) 'Filters': filters,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeCapacityReservationsResult.fromJson(response_);
  }

  /// Describes one or more of your linked EC2-Classic instances. This request
  /// only returns information about EC2-Classic instances linked to a VPC
  /// through ClassicLink. You cannot use this request to return information
  /// about other instances.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `group-id` - The ID of a VPC security group that's associated with
  /// the instance.
  ///
  /// *    `instance-id` - The ID of the instance.
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// *    `vpc-id` - The ID of the VPC to which the instance is linked.
  ///
  ///      `vpc-id` - The ID of the VPC that the instance is linked to.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [instanceIds]: One or more instance IDs. Must be instances linked to a VPC
  /// through ClassicLink.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  ///
  /// Constraint: If the value is greater than 1000, we return only 1000 items.
  ///
  /// [nextToken]: The token for the next page of results.
  Future<DescribeClassicLinkInstancesResult> describeClassicLinkInstances(
      {List<Filter> filters,
      bool dryRun,
      List<String> instanceIds,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeClassicLinkInstances', {
      if (filters != null) 'Filters': filters,
      if (dryRun != null) 'DryRun': dryRun,
      if (instanceIds != null) 'InstanceIds': instanceIds,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeClassicLinkInstancesResult.fromJson(response_);
  }

  /// Describes the authorization rules for a specified Client VPN endpoint.
  ///
  /// [clientVpnEndpointId]: The ID of the Client VPN endpoint.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [nextToken]: The token to retrieve the next page of results.
  ///
  /// [filters]: One or more filters. Filter names and values are
  /// case-sensitive.
  ///
  /// [maxResults]: The maximum number of results to return for the request in a
  /// single page. The remaining results can be seen by sending another request
  /// with the nextToken value.
  Future<DescribeClientVpnAuthorizationRulesResult>
      describeClientVpnAuthorizationRules(String clientVpnEndpointId,
          {bool dryRun,
          String nextToken,
          List<Filter> filters,
          int maxResults}) async {
    var response_ = await _client.send('DescribeClientVpnAuthorizationRules', {
      'ClientVpnEndpointId': clientVpnEndpointId,
      if (dryRun != null) 'DryRun': dryRun,
      if (nextToken != null) 'NextToken': nextToken,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
    });
    return DescribeClientVpnAuthorizationRulesResult.fromJson(response_);
  }

  /// Describes active client connections and connections that have been
  /// terminated within the last 60 minutes for the specified Client VPN
  /// endpoint.
  ///
  /// [clientVpnEndpointId]: The ID of the Client VPN endpoint.
  ///
  /// [filters]: One or more filters. Filter names and values are
  /// case-sensitive.
  ///
  /// [nextToken]: The token to retrieve the next page of results.
  ///
  /// [maxResults]: The maximum number of results to return for the request in a
  /// single page. The remaining results can be seen by sending another request
  /// with the nextToken value.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeClientVpnConnectionsResult> describeClientVpnConnections(
      String clientVpnEndpointId,
      {List<Filter> filters,
      String nextToken,
      int maxResults,
      bool dryRun}) async {
    var response_ = await _client.send('DescribeClientVpnConnections', {
      'ClientVpnEndpointId': clientVpnEndpointId,
      if (filters != null) 'Filters': filters,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeClientVpnConnectionsResult.fromJson(response_);
  }

  /// Describes one or more Client VPN endpoints in the account.
  ///
  /// [clientVpnEndpointIds]: The ID of the Client VPN endpoint.
  ///
  /// [maxResults]: The maximum number of results to return for the request in a
  /// single page. The remaining results can be seen by sending another request
  /// with the nextToken value.
  ///
  /// [nextToken]: The token to retrieve the next page of results.
  ///
  /// [filters]: One or more filters. Filter names and values are
  /// case-sensitive.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeClientVpnEndpointsResult> describeClientVpnEndpoints(
      {List<String> clientVpnEndpointIds,
      int maxResults,
      String nextToken,
      List<Filter> filters,
      bool dryRun}) async {
    var response_ = await _client.send('DescribeClientVpnEndpoints', {
      if (clientVpnEndpointIds != null)
        'ClientVpnEndpointIds': clientVpnEndpointIds,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (filters != null) 'Filters': filters,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeClientVpnEndpointsResult.fromJson(response_);
  }

  /// Describes the routes for the specified Client VPN endpoint.
  ///
  /// [clientVpnEndpointId]: The ID of the Client VPN endpoint.
  ///
  /// [filters]: One or more filters. Filter names and values are
  /// case-sensitive.
  ///
  /// [maxResults]: The maximum number of results to return for the request in a
  /// single page. The remaining results can be seen by sending another request
  /// with the nextToken value.
  ///
  /// [nextToken]: The token to retrieve the next page of results.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeClientVpnRoutesResult> describeClientVpnRoutes(
      String clientVpnEndpointId,
      {List<Filter> filters,
      int maxResults,
      String nextToken,
      bool dryRun}) async {
    var response_ = await _client.send('DescribeClientVpnRoutes', {
      'ClientVpnEndpointId': clientVpnEndpointId,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeClientVpnRoutesResult.fromJson(response_);
  }

  /// Describes the target networks associated with the specified Client VPN
  /// endpoint.
  ///
  /// [clientVpnEndpointId]: The ID of the Client VPN endpoint.
  ///
  /// [associationIds]: The IDs of the target network associations.
  ///
  /// [maxResults]: The maximum number of results to return for the request in a
  /// single page. The remaining results can be seen by sending another request
  /// with the nextToken value.
  ///
  /// [nextToken]: The token to retrieve the next page of results.
  ///
  /// [filters]: One or more filters. Filter names and values are
  /// case-sensitive.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeClientVpnTargetNetworksResult> describeClientVpnTargetNetworks(
      String clientVpnEndpointId,
      {List<String> associationIds,
      int maxResults,
      String nextToken,
      List<Filter> filters,
      bool dryRun}) async {
    var response_ = await _client.send('DescribeClientVpnTargetNetworks', {
      'ClientVpnEndpointId': clientVpnEndpointId,
      if (associationIds != null) 'AssociationIds': associationIds,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (filters != null) 'Filters': filters,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeClientVpnTargetNetworksResult.fromJson(response_);
  }

  /// Describes the specified conversion tasks or all your conversion tasks. For
  /// more information, see the
  /// [VM Import/Export User Guide](https://docs.aws.amazon.com/vm-import/latest/userguide/).
  ///
  /// For information about the import manifest referenced by this API action,
  /// see
  /// [VM Import Manifest](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html).
  ///
  /// [conversionTaskIds]: The conversion task IDs.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeConversionTasksResult> describeConversionTasks(
      {List<String> conversionTaskIds, bool dryRun}) async {
    var response_ = await _client.send('DescribeConversionTasks', {
      if (conversionTaskIds != null) 'ConversionTaskIds': conversionTaskIds,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeConversionTasksResult.fromJson(response_);
  }

  /// Describes one or more of your VPN customer gateways.
  ///
  /// For more information, see
  /// [AWS Site-to-Site VPN](https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html)
  /// in the _AWS Site-to-Site VPN User Guide_.
  ///
  /// [customerGatewayIds]: One or more customer gateway IDs.
  ///
  /// Default: Describes all your customer gateways.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `bgp-asn` - The customer gateway's Border Gateway Protocol (BGP)
  /// Autonomous System Number (ASN).
  ///
  /// *    `customer-gateway-id` - The ID of the customer gateway.
  ///
  /// *    `ip-address` - The IP address of the customer gateway's
  /// Internet-routable external interface.
  ///
  /// *    `state` - The state of the customer gateway (`pending` | `available`
  /// | `deleting` | `deleted`).
  ///
  /// *    `type` - The type of customer gateway. Currently, the only supported
  /// type is `ipsec.1`.
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeCustomerGatewaysResult> describeCustomerGateways(
      {List<String> customerGatewayIds,
      List<Filter> filters,
      bool dryRun}) async {
    var response_ = await _client.send('DescribeCustomerGateways', {
      if (customerGatewayIds != null) 'CustomerGatewayIds': customerGatewayIds,
      if (filters != null) 'Filters': filters,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeCustomerGatewaysResult.fromJson(response_);
  }

  /// Describes one or more of your DHCP options sets.
  ///
  /// For more information, see
  /// [DHCP Options Sets](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_DHCP_Options.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [dhcpOptionsIds]: The IDs of one or more DHCP options sets.
  ///
  /// Default: Describes all your DHCP options sets.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `dhcp-options-id` - The ID of a DHCP options set.
  ///
  /// *    `key` - The key for one of the options (for example, `domain-name`).
  ///
  /// *    `value` - The value for one of the options.
  ///
  /// *    `owner-id` - The ID of the AWS account that owns the DHCP options
  /// set.
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [nextToken]: The token for the next page of results.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  Future<DescribeDhcpOptionsResult> describeDhcpOptions(
      {List<String> dhcpOptionsIds,
      List<Filter> filters,
      bool dryRun,
      String nextToken,
      int maxResults}) async {
    var response_ = await _client.send('DescribeDhcpOptions', {
      if (dhcpOptionsIds != null) 'DhcpOptionsIds': dhcpOptionsIds,
      if (filters != null) 'Filters': filters,
      if (dryRun != null) 'DryRun': dryRun,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
    });
    return DescribeDhcpOptionsResult.fromJson(response_);
  }

  /// Describes one or more of your egress-only internet gateways.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [egressOnlyInternetGatewayIds]: One or more egress-only internet gateway
  /// IDs.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  ///
  /// [nextToken]: The token for the next page of results.
  Future<DescribeEgressOnlyInternetGatewaysResult>
      describeEgressOnlyInternetGateways(
          {bool dryRun,
          List<String> egressOnlyInternetGatewayIds,
          int maxResults,
          String nextToken}) async {
    var response_ = await _client.send('DescribeEgressOnlyInternetGateways', {
      if (dryRun != null) 'DryRun': dryRun,
      if (egressOnlyInternetGatewayIds != null)
        'EgressOnlyInternetGatewayIds': egressOnlyInternetGatewayIds,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeEgressOnlyInternetGatewaysResult.fromJson(response_);
  }

  /// Describes the Elastic Graphics accelerator associated with your instances.
  /// For more information about Elastic Graphics, see
  /// [Amazon Elastic Graphics](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html).
  ///
  /// [elasticGpuIds]: The Elastic Graphics accelerator IDs.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [filters]: The filters.
  ///
  /// *    `availability-zone` - The Availability Zone in which the Elastic
  /// Graphics accelerator resides.
  ///
  /// *    `elastic-gpu-health` - The status of the Elastic Graphics accelerator
  /// (`OK` | `IMPAIRED`).
  ///
  /// *    `elastic-gpu-state` - The state of the Elastic Graphics accelerator
  /// (`ATTACHED`).
  ///
  /// *    `elastic-gpu-type` - The type of Elastic Graphics accelerator; for
  /// example, `eg1.medium`.
  ///
  /// *    `instance-id` - The ID of the instance to which the Elastic Graphics
  /// accelerator is associated.
  ///
  /// [maxResults]: The maximum number of results to return in a single call. To
  /// retrieve the remaining results, make another call with the returned
  /// `NextToken` value. This value can be between 5 and 1000.
  ///
  /// [nextToken]: The token to request the next page of results.
  Future<DescribeElasticGpusResult> describeElasticGpus(
      {List<String> elasticGpuIds,
      bool dryRun,
      List<Filter> filters,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeElasticGpus', {
      if (elasticGpuIds != null) 'ElasticGpuIds': elasticGpuIds,
      if (dryRun != null) 'DryRun': dryRun,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeElasticGpusResult.fromJson(response_);
  }

  /// Describes the specified export image tasks or all your export image tasks.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [filters]: Filter tasks using the `task-state` filter and one of the
  /// following values: `active`, `completed`, `deleting`, or `deleted`.
  ///
  /// [exportImageTaskIds]: The IDs of the export image tasks.
  ///
  /// [maxResults]: The maximum number of results to return in a single call.
  ///
  /// [nextToken]: A token that indicates the next page of results.
  Future<DescribeExportImageTasksResult> describeExportImageTasks(
      {bool dryRun,
      List<Filter> filters,
      List<String> exportImageTaskIds,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeExportImageTasks', {
      if (dryRun != null) 'DryRun': dryRun,
      if (filters != null) 'Filters': filters,
      if (exportImageTaskIds != null) 'ExportImageTaskIds': exportImageTaskIds,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeExportImageTasksResult.fromJson(response_);
  }

  /// Describes the specified export instance tasks or all your export instance
  /// tasks.
  ///
  /// [exportTaskIds]: The export task IDs.
  Future<DescribeExportTasksResult> describeExportTasks(
      {List<String> exportTaskIds}) async {
    var response_ = await _client.send('DescribeExportTasks', {
      if (exportTaskIds != null) 'ExportTaskIds': exportTaskIds,
    });
    return DescribeExportTasksResult.fromJson(response_);
  }

  /// Describes the events for the specified EC2 Fleet during the specified
  /// time.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [eventType]: The type of events to describe. By default, all events are
  /// described.
  ///
  /// [maxResults]: The maximum number of results to return in a single call.
  /// Specify a value between 1 and 1000. The default value is 1000. To retrieve
  /// the remaining results, make another call with the returned `NextToken`
  /// value.
  ///
  /// [nextToken]: The token for the next set of results.
  ///
  /// [fleetId]: The ID of the EC2 Fleet.
  ///
  /// [startTime]: The start date and time for the events, in UTC format (for
  /// example, _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z).
  Future<DescribeFleetHistoryResult> describeFleetHistory(
      {bool dryRun,
      String eventType,
      int maxResults,
      String nextToken,
      @required String fleetId,
      @required DateTime startTime}) async {
    var response_ = await _client.send('DescribeFleetHistory', {
      if (dryRun != null) 'DryRun': dryRun,
      if (eventType != null) 'EventType': eventType,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      'FleetId': fleetId,
      'StartTime': startTime,
    });
    return DescribeFleetHistoryResult.fromJson(response_);
  }

  /// Describes the running instances for the specified EC2 Fleet.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [maxResults]: The maximum number of results to return in a single call.
  /// Specify a value between 1 and 1000. The default value is 1000. To retrieve
  /// the remaining results, make another call with the returned `NextToken`
  /// value.
  ///
  /// [nextToken]: The token for the next set of results.
  ///
  /// [fleetId]: The ID of the EC2 Fleet.
  ///
  /// [filters]: The filters.
  ///
  /// *    `instance-type` - The instance type.
  Future<DescribeFleetInstancesResult> describeFleetInstances(String fleetId,
      {bool dryRun,
      int maxResults,
      String nextToken,
      List<Filter> filters}) async {
    var response_ = await _client.send('DescribeFleetInstances', {
      if (dryRun != null) 'DryRun': dryRun,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      'FleetId': fleetId,
      if (filters != null) 'Filters': filters,
    });
    return DescribeFleetInstancesResult.fromJson(response_);
  }

  /// Describes the specified EC2 Fleets or all your EC2 Fleets.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [maxResults]: The maximum number of results to return in a single call.
  /// Specify a value between 1 and 1000. The default value is 1000. To retrieve
  /// the remaining results, make another call with the returned `NextToken`
  /// value.
  ///
  /// [nextToken]: The token for the next set of results.
  ///
  /// [fleetIds]: The ID of the EC2 Fleets.
  ///
  /// [filters]: The filters.
  ///
  /// *    `activity-status` - The progress of the EC2 Fleet ( `error` |
  /// `pending-fulfillment` | `pending-termination` | `fulfilled`).
  ///
  /// *    `excess-capacity-termination-policy` - Indicates whether to terminate
  /// running instances if the target capacity is decreased below the current
  /// EC2 Fleet size (`true` | `false`).
  ///
  /// *    `fleet-state` - The state of the EC2 Fleet (`submitted` | `active` |
  /// `deleted` | `failed` | `deleted-running` | `deleted-terminating` |
  /// `modifying`).
  ///
  /// *    `replace-unhealthy-instances` - Indicates whether EC2 Fleet should
  /// replace unhealthy instances (`true` | `false`).
  ///
  /// *    `type` - The type of request (`instant` | `request` | `maintain`).
  Future<DescribeFleetsResult> describeFleets(
      {bool dryRun,
      int maxResults,
      String nextToken,
      List<String> fleetIds,
      List<Filter> filters}) async {
    var response_ = await _client.send('DescribeFleets', {
      if (dryRun != null) 'DryRun': dryRun,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (fleetIds != null) 'FleetIds': fleetIds,
      if (filters != null) 'Filters': filters,
    });
    return DescribeFleetsResult.fromJson(response_);
  }

  /// Describes one or more flow logs. To view the information in your flow logs
  /// (the log streams for the network interfaces), you must use the CloudWatch
  /// Logs console or the CloudWatch Logs API.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [filter]: One or more filters.
  ///
  /// *    `deliver-log-status` - The status of the logs delivery (`SUCCESS` |
  /// `FAILED`).
  ///
  /// *    `log-destination-type` - The type of destination to which the flow
  /// log publishes data. Possible destination types include `cloud-watch-logs`
  /// and `S3`.
  ///
  /// *    `flow-log-id` - The ID of the flow log.
  ///
  /// *    `log-group-name` - The name of the log group.
  ///
  /// *    `resource-id` - The ID of the VPC, subnet, or network interface.
  ///
  /// *    `traffic-type` - The type of traffic (`ACCEPT` | `REJECT` | `ALL`).
  ///
  /// [flowLogIds]: One or more flow log IDs.
  ///
  /// Constraint: Maximum of 1000 flow log IDs.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  ///
  /// [nextToken]: The token for the next page of results.
  Future<DescribeFlowLogsResult> describeFlowLogs(
      {bool dryRun,
      List<Filter> filter,
      List<String> flowLogIds,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeFlowLogs', {
      if (dryRun != null) 'DryRun': dryRun,
      if (filter != null) 'Filter': filter,
      if (flowLogIds != null) 'FlowLogIds': flowLogIds,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeFlowLogsResult.fromJson(response_);
  }

  /// Describes the specified attribute of the specified Amazon FPGA Image
  /// (AFI).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [fpgaImageId]: The ID of the AFI.
  ///
  /// [attribute]: The AFI attribute.
  Future<DescribeFpgaImageAttributeResult> describeFpgaImageAttribute(
      {bool dryRun,
      @required String fpgaImageId,
      @required String attribute}) async {
    var response_ = await _client.send('DescribeFpgaImageAttribute', {
      if (dryRun != null) 'DryRun': dryRun,
      'FpgaImageId': fpgaImageId,
      'Attribute': attribute,
    });
    return DescribeFpgaImageAttributeResult.fromJson(response_);
  }

  /// Describes the Amazon FPGA Images (AFIs) available to you. These include
  /// public AFIs, private AFIs that you own, and AFIs owned by other AWS
  /// accounts for which you have load permissions.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [fpgaImageIds]: The AFI IDs.
  ///
  /// [owners]: Filters the AFI by owner. Specify an AWS account ID, `self`
  /// (owner is the sender of the request), or an AWS owner alias (valid values
  /// are `amazon` | `aws-marketplace`).
  ///
  /// [filters]: The filters.
  ///
  /// *    `create-time` - The creation time of the AFI.
  ///
  /// *    `fpga-image-id` - The FPGA image identifier (AFI ID).
  ///
  /// *    `fpga-image-global-id` - The global FPGA image identifier (AGFI ID).
  ///
  /// *    `name` - The name of the AFI.
  ///
  /// *    `owner-id` - The AWS account ID of the AFI owner.
  ///
  /// *    `product-code` - The product code.
  ///
  /// *    `shell-version` - The version of the AWS Shell that was used to
  /// create the bitstream.
  ///
  /// *    `state` - The state of the AFI (`pending` | `failed` | `available` |
  /// `unavailable`).
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// *    `update-time` - The time of the most recent update.
  ///
  /// [nextToken]: The token to retrieve the next page of results.
  ///
  /// [maxResults]: The maximum number of results to return in a single call.
  Future<DescribeFpgaImagesResult> describeFpgaImages(
      {bool dryRun,
      List<String> fpgaImageIds,
      List<String> owners,
      List<Filter> filters,
      String nextToken,
      int maxResults}) async {
    var response_ = await _client.send('DescribeFpgaImages', {
      if (dryRun != null) 'DryRun': dryRun,
      if (fpgaImageIds != null) 'FpgaImageIds': fpgaImageIds,
      if (owners != null) 'Owners': owners,
      if (filters != null) 'Filters': filters,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
    });
    return DescribeFpgaImagesResult.fromJson(response_);
  }

  /// Describes the Dedicated Host reservations that are available to purchase.
  ///
  /// The results describe all the Dedicated Host reservation offerings,
  /// including offerings that may not match the instance family and Region of
  /// your Dedicated Hosts. When purchasing an offering, ensure that the
  /// instance family and Region of the offering matches that of the Dedicated
  /// Hosts with which it is to be associated. For more information about
  /// supported instance types, see
  /// [Dedicated Hosts Overview](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-overview.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [filter]: The filters.
  ///
  /// *    `instance-family` - The instance family of the offering (for example,
  /// `m4`).
  ///
  /// *    `payment-option` - The payment option (`NoUpfront` | `PartialUpfront`
  /// | `AllUpfront`).
  ///
  /// [maxDuration]: This is the maximum duration of the reservation to
  /// purchase, specified in seconds. Reservations are available in one-year and
  /// three-year terms. The number of seconds specified must be the number of
  /// seconds in a year (365x24x60x60) times one of the supported durations (1
  /// or 3). For example, specify 94608000 for three years.
  ///
  /// [maxResults]: The maximum number of results to return for the request in a
  /// single page. The remaining results can be seen by sending another request
  /// with the returned `nextToken` value. This value can be between 5 and 500.
  /// If `maxResults` is given a larger value than 500, you receive an error.
  ///
  /// [minDuration]: This is the minimum duration of the reservation you'd like
  /// to purchase, specified in seconds. Reservations are available in one-year
  /// and three-year terms. The number of seconds specified must be the number
  /// of seconds in a year (365x24x60x60) times one of the supported durations
  /// (1 or 3). For example, specify 31536000 for one year.
  ///
  /// [nextToken]: The token to use to retrieve the next page of results.
  ///
  /// [offeringId]: The ID of the reservation offering.
  Future<DescribeHostReservationOfferingsResult>
      describeHostReservationOfferings(
          {List<Filter> filter,
          int maxDuration,
          int maxResults,
          int minDuration,
          String nextToken,
          String offeringId}) async {
    var response_ = await _client.send('DescribeHostReservationOfferings', {
      if (filter != null) 'Filter': filter,
      if (maxDuration != null) 'MaxDuration': maxDuration,
      if (maxResults != null) 'MaxResults': maxResults,
      if (minDuration != null) 'MinDuration': minDuration,
      if (nextToken != null) 'NextToken': nextToken,
      if (offeringId != null) 'OfferingId': offeringId,
    });
    return DescribeHostReservationOfferingsResult.fromJson(response_);
  }

  /// Describes reservations that are associated with Dedicated Hosts in your
  /// account.
  ///
  /// [filter]: The filters.
  ///
  /// *    `instance-family` - The instance family (for example, `m4`).
  ///
  /// *    `payment-option` - The payment option (`NoUpfront` | `PartialUpfront`
  /// | `AllUpfront`).
  ///
  /// *    `state` - The state of the reservation (`payment-pending` |
  /// `payment-failed` | `active` | `retired`).
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// [hostReservationIdSet]: The host reservation IDs.
  ///
  /// [maxResults]: The maximum number of results to return for the request in a
  /// single page. The remaining results can be seen by sending another request
  /// with the returned `nextToken` value. This value can be between 5 and 500.
  /// If `maxResults` is given a larger value than 500, you receive an error.
  ///
  /// [nextToken]: The token to use to retrieve the next page of results.
  Future<DescribeHostReservationsResult> describeHostReservations(
      {List<Filter> filter,
      List<String> hostReservationIdSet,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeHostReservations', {
      if (filter != null) 'Filter': filter,
      if (hostReservationIdSet != null)
        'HostReservationIdSet': hostReservationIdSet,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeHostReservationsResult.fromJson(response_);
  }

  /// Describes the specified Dedicated Hosts or all your Dedicated Hosts.
  ///
  /// The results describe only the Dedicated Hosts in the Region you're
  /// currently using. All listed instances consume capacity on your Dedicated
  /// Host. Dedicated Hosts that have recently been released are listed with the
  /// state `released`.
  ///
  /// [filter]: The filters.
  ///
  /// *    `auto-placement` - Whether auto-placement is enabled or disabled
  /// (`on` | `off`).
  ///
  /// *    `availability-zone` - The Availability Zone of the host.
  ///
  /// *    `client-token` - The idempotency token that you provided when you
  /// allocated the host.
  ///
  /// *    `host-reservation-id` - The ID of the reservation assigned to this
  /// host.
  ///
  /// *    `instance-type` - The instance type size that the Dedicated Host is
  /// configured to support.
  ///
  /// *    `state` - The allocation state of the Dedicated Host (`available` |
  /// `under-assessment` | `permanent-failure` | `released` |
  /// `released-permanent-failure`).
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// [hostIds]: The IDs of the Dedicated Hosts. The IDs are used for targeted
  /// instance launches.
  ///
  /// [maxResults]: The maximum number of results to return for the request in a
  /// single page. The remaining results can be seen by sending another request
  /// with the returned `nextToken` value. This value can be between 5 and 500.
  /// If `maxResults` is given a larger value than 500, you receive an error.
  ///
  /// You cannot specify this parameter and the host IDs parameter in the same
  /// request.
  ///
  /// [nextToken]: The token to use to retrieve the next page of results.
  Future<DescribeHostsResult> describeHosts(
      {List<Filter> filter,
      List<String> hostIds,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeHosts', {
      if (filter != null) 'Filter': filter,
      if (hostIds != null) 'HostIds': hostIds,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeHostsResult.fromJson(response_);
  }

  /// Describes your IAM instance profile associations.
  ///
  /// [associationIds]: The IAM instance profile associations.
  ///
  /// [filters]: The filters.
  ///
  /// *    `instance-id` - The ID of the instance.
  ///
  /// *    `state` - The state of the association (`associating` | `associated`
  /// | `disassociating` | `disassociated`).
  ///
  /// [maxResults]: The maximum number of results to return in a single call. To
  /// retrieve the remaining results, make another call with the returned
  /// `NextToken` value.
  ///
  /// [nextToken]: The token to request the next page of results.
  Future<DescribeIamInstanceProfileAssociationsResult>
      describeIamInstanceProfileAssociations(
          {List<String> associationIds,
          List<Filter> filters,
          int maxResults,
          String nextToken}) async {
    var response_ =
        await _client.send('DescribeIamInstanceProfileAssociations', {
      if (associationIds != null) 'AssociationIds': associationIds,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeIamInstanceProfileAssociationsResult.fromJson(response_);
  }

  /// Describes the ID format settings for your resources on a per-Region basis,
  /// for example, to view which resource types are enabled for longer IDs. This
  /// request only returns information about resource types whose ID formats can
  /// be modified; it does not return information about other resource types.
  ///
  /// The following resource types support longer IDs: `bundle` |
  /// `conversion-task` | `customer-gateway` | `dhcp-options` |
  /// `elastic-ip-allocation` | `elastic-ip-association` | `export-task` |
  /// `flow-log` | `image` | `import-task` | `instance` | `internet-gateway` |
  /// `network-acl` | `network-acl-association` | `network-interface` |
  /// `network-interface-attachment` | `prefix-list` | `reservation` |
  /// `route-table` | `route-table-association` | `security-group` | `snapshot`
  /// | `subnet` | `subnet-cidr-block-association` | `volume` | `vpc` |
  /// `vpc-cidr-block-association` | `vpc-endpoint` | `vpc-peering-connection` |
  /// `vpn-connection` | `vpn-gateway`.
  ///
  /// These settings apply to the IAM user who makes the request; they do not
  /// apply to the entire AWS account. By default, an IAM user defaults to the
  /// same settings as the root user, unless they explicitly override the
  /// settings by running the ModifyIdFormat command. Resources created with
  /// longer IDs are visible to all IAM users, regardless of these settings and
  /// provided that they have permission to use the relevant `Describe` command
  /// for the resource type.
  ///
  /// [resource]: The type of resource: `bundle` | `conversion-task` |
  /// `customer-gateway` | `dhcp-options` | `elastic-ip-allocation` |
  /// `elastic-ip-association` | `export-task` | `flow-log` | `image` |
  /// `import-task` | `instance` | `internet-gateway` | `network-acl` |
  /// `network-acl-association` | `network-interface` |
  /// `network-interface-attachment` | `prefix-list` | `reservation` |
  /// `route-table` | `route-table-association` | `security-group` | `snapshot`
  /// | `subnet` | `subnet-cidr-block-association` | `volume` | `vpc` |
  /// `vpc-cidr-block-association` | `vpc-endpoint` | `vpc-peering-connection` |
  /// `vpn-connection` | `vpn-gateway`
  Future<DescribeIdFormatResult> describeIdFormat({String resource}) async {
    var response_ = await _client.send('DescribeIdFormat', {
      if (resource != null) 'Resource': resource,
    });
    return DescribeIdFormatResult.fromJson(response_);
  }

  /// Describes the ID format settings for resources for the specified IAM user,
  /// IAM role, or root user. For example, you can view the resource types that
  /// are enabled for longer IDs. This request only returns information about
  /// resource types whose ID formats can be modified; it does not return
  /// information about other resource types. For more information, see
  /// [Resource IDs](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/resource-ids.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// The following resource types support longer IDs: `bundle` |
  /// `conversion-task` | `customer-gateway` | `dhcp-options` |
  /// `elastic-ip-allocation` | `elastic-ip-association` | `export-task` |
  /// `flow-log` | `image` | `import-task` | `instance` | `internet-gateway` |
  /// `network-acl` | `network-acl-association` | `network-interface` |
  /// `network-interface-attachment` | `prefix-list` | `reservation` |
  /// `route-table` | `route-table-association` | `security-group` | `snapshot`
  /// | `subnet` | `subnet-cidr-block-association` | `volume` | `vpc` |
  /// `vpc-cidr-block-association` | `vpc-endpoint` | `vpc-peering-connection` |
  /// `vpn-connection` | `vpn-gateway`.
  ///
  /// These settings apply to the principal specified in the request. They do
  /// not apply to the principal that makes the request.
  ///
  /// [principalArn]: The ARN of the principal, which can be an IAM role, IAM
  /// user, or the root user.
  ///
  /// [resource]: The type of resource: `bundle` | `conversion-task` |
  /// `customer-gateway` | `dhcp-options` | `elastic-ip-allocation` |
  /// `elastic-ip-association` | `export-task` | `flow-log` | `image` |
  /// `import-task` | `instance` | `internet-gateway` | `network-acl` |
  /// `network-acl-association` | `network-interface` |
  /// `network-interface-attachment` | `prefix-list` | `reservation` |
  /// `route-table` | `route-table-association` | `security-group` | `snapshot`
  /// | `subnet` | `subnet-cidr-block-association` | `volume` | `vpc` |
  /// `vpc-cidr-block-association` | `vpc-endpoint` | `vpc-peering-connection` |
  /// `vpn-connection` | `vpn-gateway`
  Future<DescribeIdentityIdFormatResult> describeIdentityIdFormat(
      String principalArn,
      {String resource}) async {
    var response_ = await _client.send('DescribeIdentityIdFormat', {
      'PrincipalArn': principalArn,
      if (resource != null) 'Resource': resource,
    });
    return DescribeIdentityIdFormatResult.fromJson(response_);
  }

  /// Describes the specified attribute of the specified AMI. You can specify
  /// only one attribute at a time.
  ///
  /// [attribute]: The AMI attribute.
  ///
  ///  **Note**: Depending on your account privileges, the `blockDeviceMapping`
  /// attribute may return a `Client.AuthFailure` error. If this happens, use
  /// DescribeImages to get information about the block device mapping for the
  /// AMI.
  ///
  /// [imageId]: The ID of the AMI.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ImageAttribute> describeImageAttribute(
      {@required String attribute,
      @required String imageId,
      bool dryRun}) async {
    var response_ = await _client.send('DescribeImageAttribute', {
      'Attribute': attribute,
      'ImageId': imageId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ImageAttribute.fromJson(response_);
  }

  /// Describes the specified images (AMIs, AKIs, and ARIs) available to you or
  /// all of the images available to you.
  ///
  /// The images available to you include public images, private images that you
  /// own, and private images owned by other AWS accounts for which you have
  /// explicit launch permissions.
  ///
  /// Recently deregistered images appear in the returned results for a short
  /// interval and then return empty results. After all instances that reference
  /// a deregistered AMI are terminated, specifying the ID of the image results
  /// in an error indicating that the AMI ID cannot be found.
  ///
  /// [executableUsers]: Scopes the images by users with explicit launch
  /// permissions. Specify an AWS account ID, `self` (the sender of the
  /// request), or `all` (public AMIs).
  ///
  /// [filters]: The filters.
  ///
  /// *    `architecture` - The image architecture (`i386` | `x86_64` |
  /// `arm64`).
  ///
  /// *    `block-device-mapping.delete-on-termination` - A Boolean value that
  /// indicates whether the Amazon EBS volume is deleted on instance
  /// termination.
  ///
  /// *    `block-device-mapping.device-name` - The device name specified in the
  /// block device mapping (for example, `/dev/sdh` or `xvdh`).
  ///
  /// *    `block-device-mapping.snapshot-id` - The ID of the snapshot used for
  /// the EBS volume.
  ///
  /// *    `block-device-mapping.volume-size` - The volume size of the EBS
  /// volume, in GiB.
  ///
  /// *    `block-device-mapping.volume-type` - The volume type of the EBS
  /// volume (`gp2` | `io1` | `st1` | `sc1` | `standard`).
  ///
  /// *    `block-device-mapping.encrypted` - A Boolean that indicates whether
  /// the EBS volume is encrypted.
  ///
  /// *    `description` - The description of the image (provided during image
  /// creation).
  ///
  /// *    `ena-support` - A Boolean that indicates whether enhanced networking
  /// with ENA is enabled.
  ///
  /// *    `hypervisor` - The hypervisor type (`ovm` | `xen`).
  ///
  /// *    `image-id` - The ID of the image.
  ///
  /// *    `image-type` - The image type (`machine` | `kernel` | `ramdisk`).
  ///
  /// *    `is-public` - A Boolean that indicates whether the image is public.
  ///
  /// *    `kernel-id` - The kernel ID.
  ///
  /// *    `manifest-location` - The location of the image manifest.
  ///
  /// *    `name` - The name of the AMI (provided during image creation).
  ///
  /// *    `owner-alias` - String value from an Amazon-maintained list (`amazon`
  /// | `aws-marketplace` | `microsoft`) of snapshot owners. Not to be confused
  /// with the user-configured AWS account alias, which is set from the IAM
  /// console.
  ///
  /// *    `owner-id` - The AWS account ID of the image owner.
  ///
  /// *    `platform` - The platform. To only list Windows-based AMIs, use
  /// `windows`.
  ///
  /// *    `product-code` - The product code.
  ///
  /// *    `product-code.type` - The type of the product code (`devpay` |
  /// `marketplace`).
  ///
  /// *    `ramdisk-id` - The RAM disk ID.
  ///
  /// *    `root-device-name` - The device name of the root device volume (for
  /// example, `/dev/sda1`).
  ///
  /// *    `root-device-type` - The type of the root device volume (`ebs` |
  /// `instance-store`).
  ///
  /// *    `state` - The state of the image (`available` | `pending` |
  /// `failed`).
  ///
  /// *    `state-reason-code` - The reason code for the state change.
  ///
  /// *    `state-reason-message` - The message for the state change.
  ///
  /// *    `sriov-net-support` - A value of `simple` indicates that enhanced
  /// networking with the Intel 82599 VF interface is enabled.
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// *    `virtualization-type` - The virtualization type (`paravirtual` |
  /// `hvm`).
  ///
  /// [imageIds]: The image IDs.
  ///
  /// Default: Describes all images available to you.
  ///
  /// [owners]: Filters the images by the owner. Specify an AWS account ID,
  /// `self` (owner is the sender of the request), or an AWS owner alias (valid
  /// values are `amazon` | `aws-marketplace` | `microsoft`). Omitting this
  /// option returns all images for which you have launch permissions,
  /// regardless of ownership.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeImagesResult> describeImages(
      {List<String> executableUsers,
      List<Filter> filters,
      List<String> imageIds,
      List<String> owners,
      bool dryRun}) async {
    var response_ = await _client.send('DescribeImages', {
      if (executableUsers != null) 'ExecutableUsers': executableUsers,
      if (filters != null) 'Filters': filters,
      if (imageIds != null) 'ImageIds': imageIds,
      if (owners != null) 'Owners': owners,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeImagesResult.fromJson(response_);
  }

  /// Displays details about an import virtual machine or import snapshot tasks
  /// that are already created.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [filters]: Filter tasks using the `task-state` filter and one of the
  /// following values: `active`, `completed`, `deleting`, or `deleted`.
  ///
  /// [importTaskIds]: The IDs of the import image tasks.
  ///
  /// [maxResults]: The maximum number of results to return in a single call.
  ///
  /// [nextToken]: A token that indicates the next page of results.
  Future<DescribeImportImageTasksResult> describeImportImageTasks(
      {bool dryRun,
      List<Filter> filters,
      List<String> importTaskIds,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeImportImageTasks', {
      if (dryRun != null) 'DryRun': dryRun,
      if (filters != null) 'Filters': filters,
      if (importTaskIds != null) 'ImportTaskIds': importTaskIds,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeImportImageTasksResult.fromJson(response_);
  }

  /// Describes your import snapshot tasks.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [filters]: The filters.
  ///
  /// [importTaskIds]: A list of import snapshot task IDs.
  ///
  /// [maxResults]: The maximum number of results to return in a single call. To
  /// retrieve the remaining results, make another call with the returned
  /// `NextToken` value.
  ///
  /// [nextToken]: A token that indicates the next page of results.
  Future<DescribeImportSnapshotTasksResult> describeImportSnapshotTasks(
      {bool dryRun,
      List<Filter> filters,
      List<String> importTaskIds,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeImportSnapshotTasks', {
      if (dryRun != null) 'DryRun': dryRun,
      if (filters != null) 'Filters': filters,
      if (importTaskIds != null) 'ImportTaskIds': importTaskIds,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeImportSnapshotTasksResult.fromJson(response_);
  }

  /// Describes the specified attribute of the specified instance. You can
  /// specify only one attribute at a time. Valid attribute values are:
  /// `instanceType` | `kernel` | `ramdisk` | `userData` |
  /// `disableApiTermination` | `instanceInitiatedShutdownBehavior` |
  /// `rootDeviceName` | `blockDeviceMapping` | `productCodes` |
  /// `sourceDestCheck` | `groupSet` | `ebsOptimized` | `sriovNetSupport`
  ///
  /// [attribute]: The instance attribute.
  ///
  /// Note: The `enaSupport` attribute is not supported at this time.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [instanceId]: The ID of the instance.
  Future<InstanceAttribute> describeInstanceAttribute(
      {@required String attribute,
      bool dryRun,
      @required String instanceId}) async {
    var response_ = await _client.send('DescribeInstanceAttribute', {
      'Attribute': attribute,
      if (dryRun != null) 'DryRun': dryRun,
      'InstanceId': instanceId,
    });
    return InstanceAttribute.fromJson(response_);
  }

  /// Describes the credit option for CPU usage of the specified T2 or T3
  /// instances. The credit options are `standard` and `unlimited`.
  ///
  /// If you do not specify an instance ID, Amazon EC2 returns T2 and T3
  /// instances with the `unlimited` credit option, as well as instances that
  /// were previously configured as T2 or T3 with the `unlimited` credit option.
  /// For example, if you resize a T2 instance, while it is configured as
  /// `unlimited`, to an M4 instance, Amazon EC2 returns the M4 instance.
  ///
  /// If you specify one or more instance IDs, Amazon EC2 returns the credit
  /// option (`standard` or `unlimited`) of those instances. If you specify an
  /// instance ID that is not valid, such as an instance that is not a T2 or T3
  /// instance, an error is returned.
  ///
  /// Recently terminated instances might appear in the returned results. This
  /// interval is usually less than one hour.
  ///
  /// If an Availability Zone is experiencing a service disruption and you
  /// specify instance IDs in the affected zone, or do not specify any instance
  /// IDs at all, the call fails. If you specify only instance IDs in an
  /// unaffected zone, the call works normally.
  ///
  /// For more information, see
  /// [Burstable Performance Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [filters]: The filters.
  ///
  /// *    `instance-id` - The ID of the instance.
  ///
  /// [instanceIds]: The instance IDs.
  ///
  /// Default: Describes all your instances.
  ///
  /// Constraints: Maximum 1000 explicitly specified instance IDs.
  ///
  /// [maxResults]: The maximum number of results to return in a single call. To
  /// retrieve the remaining results, make another call with the returned
  /// `NextToken` value. This value can be between 5 and 1000. You cannot
  /// specify this parameter and the instance IDs parameter in the same call.
  ///
  /// [nextToken]: The token to retrieve the next page of results.
  Future<DescribeInstanceCreditSpecificationsResult>
      describeInstanceCreditSpecifications(
          {bool dryRun,
          List<Filter> filters,
          List<String> instanceIds,
          int maxResults,
          String nextToken}) async {
    var response_ = await _client.send('DescribeInstanceCreditSpecifications', {
      if (dryRun != null) 'DryRun': dryRun,
      if (filters != null) 'Filters': filters,
      if (instanceIds != null) 'InstanceIds': instanceIds,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeInstanceCreditSpecificationsResult.fromJson(response_);
  }

  /// Describes the status of the specified instances or all of your instances.
  /// By default, only running instances are described, unless you specifically
  /// indicate to return the status of all instances.
  ///
  /// Instance status includes the following components:
  ///
  /// *    **Status checks** - Amazon EC2 performs status checks on running EC2
  /// instances to identify hardware and software issues. For more information,
  /// see
  /// [Status Checks for Your Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/monitoring-system-instance-status-check.html)
  /// and
  /// [Troubleshooting Instances with Failed Status Checks](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/TroubleshootingInstances.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// *    **Scheduled events** - Amazon EC2 can schedule events (such as
  /// reboot, stop, or terminate) for your instances related to hardware issues,
  /// software updates, or system maintenance. For more information, see
  /// [Scheduled Events for Your Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/monitoring-instances-status-check_sched.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// *    **Instance state** - You can manage your instances from the moment
  /// you launch them through their termination. For more information, see
  /// [Instance Lifecycle](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-lifecycle.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [filters]: The filters.
  ///
  /// *    `availability-zone` - The Availability Zone of the instance.
  ///
  /// *    `event.code` - The code for the scheduled event (`instance-reboot` |
  /// `system-reboot` | `system-maintenance` | `instance-retirement` |
  /// `instance-stop`).
  ///
  /// *    `event.description` - A description of the event.
  ///
  /// *    `event.instance-event-id` - The ID of the event whose date and time
  /// you are modifying.
  ///
  /// *    `event.not-after` - The latest end time for the scheduled event (for
  /// example, `2014-09-15T17:15:20.000Z`).
  ///
  /// *    `event.not-before` - The earliest start time for the scheduled event
  /// (for example, `2014-09-15T17:15:20.000Z`).
  ///
  /// *    `event.not-before-deadline` - The deadline for starting the event
  /// (for example, `2014-09-15T17:15:20.000Z`).
  ///
  /// *    `instance-state-code` - The code for the instance state, as a 16-bit
  /// unsigned integer. The high byte is used for internal purposes and should
  /// be ignored. The low byte is set based on the state represented. The valid
  /// values are 0 (pending), 16 (running), 32 (shutting-down), 48 (terminated),
  /// 64 (stopping), and 80 (stopped).
  ///
  /// *    `instance-state-name` - The state of the instance (`pending` |
  /// `running` | `shutting-down` | `terminated` | `stopping` | `stopped`).
  ///
  /// *    `instance-status.reachability` - Filters on instance status where the
  /// name is `reachability` (`passed` | `failed` | `initializing` |
  /// `insufficient-data`).
  ///
  /// *    `instance-status.status` - The status of the instance (`ok` |
  /// `impaired` | `initializing` | `insufficient-data` | `not-applicable`).
  ///
  /// *    `system-status.reachability` - Filters on system status where the
  /// name is `reachability` (`passed` | `failed` | `initializing` |
  /// `insufficient-data`).
  ///
  /// *    `system-status.status` - The system status of the instance (`ok` |
  /// `impaired` | `initializing` | `insufficient-data` | `not-applicable`).
  ///
  /// [instanceIds]: The instance IDs.
  ///
  /// Default: Describes all your instances.
  ///
  /// Constraints: Maximum 100 explicitly specified instance IDs.
  ///
  /// [maxResults]: The maximum number of results to return in a single call. To
  /// retrieve the remaining results, make another call with the returned
  /// `NextToken` value. This value can be between 5 and 1000. You cannot
  /// specify this parameter and the instance IDs parameter in the same call.
  ///
  /// [nextToken]: The token to retrieve the next page of results.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [includeAllInstances]: When `true`, includes the health status for all
  /// instances. When `false`, includes the health status for running instances
  /// only.
  ///
  /// Default: `false`
  Future<DescribeInstanceStatusResult> describeInstanceStatus(
      {List<Filter> filters,
      List<String> instanceIds,
      int maxResults,
      String nextToken,
      bool dryRun,
      bool includeAllInstances}) async {
    var response_ = await _client.send('DescribeInstanceStatus', {
      if (filters != null) 'Filters': filters,
      if (instanceIds != null) 'InstanceIds': instanceIds,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (dryRun != null) 'DryRun': dryRun,
      if (includeAllInstances != null)
        'IncludeAllInstances': includeAllInstances,
    });
    return DescribeInstanceStatusResult.fromJson(response_);
  }

  /// Describes the specified instances or all of AWS account's instances.
  ///
  /// If you specify one or more instance IDs, Amazon EC2 returns information
  /// for those instances. If you do not specify instance IDs, Amazon EC2
  /// returns information for all relevant instances. If you specify an instance
  /// ID that is not valid, an error is returned. If you specify an instance
  /// that you do not own, it is not included in the returned results.
  ///
  /// Recently terminated instances might appear in the returned results. This
  /// interval is usually less than one hour.
  ///
  /// If you describe instances in the rare case where an Availability Zone is
  /// experiencing a service disruption and you specify instance IDs that are in
  /// the affected zone, or do not specify any instance IDs at all, the call
  /// fails. If you describe instances and specify only instance IDs that are in
  /// an unaffected zone, the call works normally.
  ///
  /// [filters]: The filters.
  ///
  /// *    `affinity` - The affinity setting for an instance running on a
  /// Dedicated Host (`default` | `host`).
  ///
  /// *    `architecture` - The instance architecture (`i386` | `x86_64` |
  /// `arm64`).
  ///
  /// *    `availability-zone` - The Availability Zone of the instance.
  ///
  /// *    `block-device-mapping.attach-time` - The attach time for an EBS
  /// volume mapped to the instance, for example, `2010-09-15T17:15:20.000Z`.
  ///
  /// *    `block-device-mapping.delete-on-termination` - A Boolean that
  /// indicates whether the EBS volume is deleted on instance termination.
  ///
  /// *    `block-device-mapping.device-name` - The device name specified in the
  /// block device mapping (for example, `/dev/sdh` or `xvdh`).
  ///
  /// *    `block-device-mapping.status` - The status for the EBS volume
  /// (`attaching` | `attached` | `detaching` | `detached`).
  ///
  /// *    `block-device-mapping.volume-id` - The volume ID of the EBS volume.
  ///
  /// *    `client-token` - The idempotency token you provided when you launched
  /// the instance.
  ///
  /// *    `dns-name` - The public DNS name of the instance.
  ///
  /// *    `group-id` - The ID of the security group for the instance.
  /// EC2-Classic only.
  ///
  /// *    `group-name` - The name of the security group for the instance.
  /// EC2-Classic only.
  ///
  /// *    `hibernation-options.configured` - A Boolean that indicates whether
  /// the instance is enabled for hibernation. A value of `true` means that the
  /// instance is enabled for hibernation.
  ///
  /// *    `host-id` - The ID of the Dedicated Host on which the instance is
  /// running, if applicable.
  ///
  /// *    `hypervisor` - The hypervisor type of the instance (`ovm` | `xen`).
  ///
  /// *    `iam-instance-profile.arn` - The instance profile associated with the
  /// instance. Specified as an ARN.
  ///
  /// *    `image-id` - The ID of the image used to launch the instance.
  ///
  /// *    `instance-id` - The ID of the instance.
  ///
  /// *    `instance-lifecycle` - Indicates whether this is a Spot Instance or a
  /// Scheduled Instance (`spot` | `scheduled`).
  ///
  /// *    `instance-state-code` - The state of the instance, as a 16-bit
  /// unsigned integer. The high byte is used for internal purposes and should
  /// be ignored. The low byte is set based on the state represented. The valid
  /// values are: 0 (pending), 16 (running), 32 (shutting-down), 48
  /// (terminated), 64 (stopping), and 80 (stopped).
  ///
  /// *    `instance-state-name` - The state of the instance (`pending` |
  /// `running` | `shutting-down` | `terminated` | `stopping` | `stopped`).
  ///
  /// *    `instance-type` - The type of instance (for example, `t2.micro`).
  ///
  /// *    `instance.group-id` - The ID of the security group for the instance.
  ///
  /// *    `instance.group-name` - The name of the security group for the
  /// instance.
  ///
  /// *    `ip-address` - The public IPv4 address of the instance.
  ///
  /// *    `kernel-id` - The kernel ID.
  ///
  /// *    `key-name` - The name of the key pair used when the instance was
  /// launched.
  ///
  /// *    `launch-index` - When launching multiple instances, this is the index
  /// for the instance in the launch group (for example, 0, 1, 2, and so on).
  ///
  /// *    `launch-time` - The time when the instance was launched.
  ///
  /// *    `monitoring-state` - Indicates whether detailed monitoring is enabled
  /// (`disabled` | `enabled`).
  ///
  /// *    `network-interface.addresses.private-ip-address` - The private IPv4
  /// address associated with the network interface.
  ///
  /// *    `network-interface.addresses.primary` - Specifies whether the IPv4
  /// address of the network interface is the primary private IPv4 address.
  ///
  /// *    `network-interface.addresses.association.public-ip` - The ID of the
  /// association of an Elastic IP address (IPv4) with a network interface.
  ///
  /// *    `network-interface.addresses.association.ip-owner-id` - The owner ID
  /// of the private IPv4 address associated with the network interface.
  ///
  /// *    `network-interface.association.public-ip` - The address of the
  /// Elastic IP address (IPv4) bound to the network interface.
  ///
  /// *    `network-interface.association.ip-owner-id` - The owner of the
  /// Elastic IP address (IPv4) associated with the network interface.
  ///
  /// *    `network-interface.association.allocation-id` - The allocation ID
  /// returned when you allocated the Elastic IP address (IPv4) for your network
  /// interface.
  ///
  /// *    `network-interface.association.association-id` - The association ID
  /// returned when the network interface was associated with an IPv4 address.
  ///
  /// *    `network-interface.attachment.attachment-id` - The ID of the
  /// interface attachment.
  ///
  /// *    `network-interface.attachment.instance-id` - The ID of the instance
  /// to which the network interface is attached.
  ///
  /// *    `network-interface.attachment.instance-owner-id` - The owner ID of
  /// the instance to which the network interface is attached.
  ///
  /// *    `network-interface.attachment.device-index` - The device index to
  /// which the network interface is attached.
  ///
  /// *    `network-interface.attachment.status` - The status of the attachment
  /// (`attaching` | `attached` | `detaching` | `detached`).
  ///
  /// *    `network-interface.attachment.attach-time` - The time that the
  /// network interface was attached to an instance.
  ///
  /// *    `network-interface.attachment.delete-on-termination` - Specifies
  /// whether the attachment is deleted when an instance is terminated.
  ///
  /// *    `network-interface.availability-zone` - The Availability Zone for the
  /// network interface.
  ///
  /// *    `network-interface.description` - The description of the network
  /// interface.
  ///
  /// *    `network-interface.group-id` - The ID of a security group associated
  /// with the network interface.
  ///
  /// *    `network-interface.group-name` - The name of a security group
  /// associated with the network interface.
  ///
  /// *    `network-interface.ipv6-addresses.ipv6-address` - The IPv6 address
  /// associated with the network interface.
  ///
  /// *    `network-interface.mac-address` - The MAC address of the network
  /// interface.
  ///
  /// *    `network-interface.network-interface-id` - The ID of the network
  /// interface.
  ///
  /// *    `network-interface.owner-id` - The ID of the owner of the network
  /// interface.
  ///
  /// *    `network-interface.private-dns-name` - The private DNS name of the
  /// network interface.
  ///
  /// *    `network-interface.requester-id` - The requester ID for the network
  /// interface.
  ///
  /// *    `network-interface.requester-managed` - Indicates whether the network
  /// interface is being managed by AWS.
  ///
  /// *    `network-interface.status` - The status of the network interface
  /// (`available`) | `in-use`).
  ///
  /// *    `network-interface.source-dest-check` - Whether the network interface
  /// performs source/destination checking. A value of `true` means that
  /// checking is enabled, and `false` means that checking is disabled. The
  /// value must be `false` for the network interface to perform network address
  /// translation (NAT) in your VPC.
  ///
  /// *    `network-interface.subnet-id` - The ID of the subnet for the network
  /// interface.
  ///
  /// *    `network-interface.vpc-id` - The ID of the VPC for the network
  /// interface.
  ///
  /// *    `owner-id` - The AWS account ID of the instance owner.
  ///
  /// *    `placement-group-name` - The name of the placement group for the
  /// instance.
  ///
  /// *    `placement-partition-number` - The partition in which the instance is
  /// located.
  ///
  /// *    `platform` - The platform. To list only Windows instances, use
  /// `windows`.
  ///
  /// *    `private-dns-name` - The private IPv4 DNS name of the instance.
  ///
  /// *    `private-ip-address` - The private IPv4 address of the instance.
  ///
  /// *    `product-code` - The product code associated with the AMI used to
  /// launch the instance.
  ///
  /// *    `product-code.type` - The type of product code (`devpay` |
  /// `marketplace`).
  ///
  /// *    `ramdisk-id` - The RAM disk ID.
  ///
  /// *    `reason` - The reason for the current state of the instance (for
  /// example, shows "User Initiated [date]" when you stop or terminate the
  /// instance). Similar to the state-reason-code filter.
  ///
  /// *    `requester-id` - The ID of the entity that launched the instance on
  /// your behalf (for example, AWS Management Console, Auto Scaling, and so
  /// on).
  ///
  /// *    `reservation-id` - The ID of the instance's reservation. A
  /// reservation ID is created any time you launch an instance. A reservation
  /// ID has a one-to-one relationship with an instance launch request, but can
  /// be associated with more than one instance if you launch multiple instances
  /// using the same launch request. For example, if you launch one instance,
  /// you get one reservation ID. If you launch ten instances using the same
  /// launch request, you also get one reservation ID.
  ///
  /// *    `root-device-name` - The device name of the root device volume (for
  /// example, `/dev/sda1`).
  ///
  /// *    `root-device-type` - The type of the root device volume (`ebs` |
  /// `instance-store`).
  ///
  /// *    `source-dest-check` - Indicates whether the instance performs
  /// source/destination checking. A value of `true` means that checking is
  /// enabled, and `false` means that checking is disabled. The value must be
  /// `false` for the instance to perform network address translation (NAT) in
  /// your VPC.
  ///
  /// *    `spot-instance-request-id` - The ID of the Spot Instance request.
  ///
  /// *    `state-reason-code` - The reason code for the state change.
  ///
  /// *    `state-reason-message` - A message that describes the state change.
  ///
  /// *    `subnet-id` - The ID of the subnet for the instance.
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources that have a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// *    `tenancy` - The tenancy of an instance (`dedicated` | `default` |
  /// `host`).
  ///
  /// *    `virtualization-type` - The virtualization type of the instance
  /// (`paravirtual` | `hvm`).
  ///
  /// *    `vpc-id` - The ID of the VPC that the instance is running in.
  ///
  /// [instanceIds]: The instance IDs.
  ///
  /// Default: Describes all your instances.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [maxResults]: The maximum number of results to return in a single call. To
  /// retrieve the remaining results, make another call with the returned
  /// `NextToken` value. This value can be between 5 and 1000. You cannot
  /// specify this parameter and the instance IDs parameter in the same call.
  ///
  /// [nextToken]: The token to request the next page of results.
  Future<DescribeInstancesResult> describeInstances(
      {List<Filter> filters,
      List<String> instanceIds,
      bool dryRun,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeInstances', {
      if (filters != null) 'Filters': filters,
      if (instanceIds != null) 'InstanceIds': instanceIds,
      if (dryRun != null) 'DryRun': dryRun,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeInstancesResult.fromJson(response_);
  }

  /// Describes one or more of your internet gateways.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `attachment.state` - The current state of the attachment between the
  /// gateway and the VPC (`available`). Present only if a VPC is attached.
  ///
  /// *    `attachment.vpc-id` - The ID of an attached VPC.
  ///
  /// *    `internet-gateway-id` - The ID of the Internet gateway.
  ///
  /// *    `owner-id` - The ID of the AWS account that owns the internet
  /// gateway.
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [internetGatewayIds]: One or more internet gateway IDs.
  ///
  /// Default: Describes all your internet gateways.
  ///
  /// [nextToken]: The token for the next page of results.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  Future<DescribeInternetGatewaysResult> describeInternetGateways(
      {List<Filter> filters,
      bool dryRun,
      List<String> internetGatewayIds,
      String nextToken,
      int maxResults}) async {
    var response_ = await _client.send('DescribeInternetGateways', {
      if (filters != null) 'Filters': filters,
      if (dryRun != null) 'DryRun': dryRun,
      if (internetGatewayIds != null) 'InternetGatewayIds': internetGatewayIds,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
    });
    return DescribeInternetGatewaysResult.fromJson(response_);
  }

  /// Describes the specified key pairs or all of your key pairs.
  ///
  /// For more information about key pairs, see
  /// [Key Pairs](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [filters]: The filters.
  ///
  /// *    `fingerprint` - The fingerprint of the key pair.
  ///
  /// *    `key-name` - The name of the key pair.
  ///
  /// [keyNames]: The key pair names.
  ///
  /// Default: Describes all your key pairs.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeKeyPairsResult> describeKeyPairs(
      {List<Filter> filters, List<String> keyNames, bool dryRun}) async {
    var response_ = await _client.send('DescribeKeyPairs', {
      if (filters != null) 'Filters': filters,
      if (keyNames != null) 'KeyNames': keyNames,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeKeyPairsResult.fromJson(response_);
  }

  /// Describes one or more versions of a specified launch template. You can
  /// describe all versions, individual versions, or a range of versions.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [launchTemplateId]: The ID of the launch template. You must specify either
  /// the launch template ID or launch template name in the request.
  ///
  /// [launchTemplateName]: The name of the launch template. You must specify
  /// either the launch template ID or launch template name in the request.
  ///
  /// [versions]: One or more versions of the launch template.
  ///
  /// [minVersion]: The version number after which to describe launch template
  /// versions.
  ///
  /// [maxVersion]: The version number up to which to describe launch template
  /// versions.
  ///
  /// [nextToken]: The token to request the next page of results.
  ///
  /// [maxResults]: The maximum number of results to return in a single call. To
  /// retrieve the remaining results, make another call with the returned
  /// `NextToken` value. This value can be between 1 and 200.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `create-time` - The time the launch template version was created.
  ///
  /// *    `ebs-optimized` - A boolean that indicates whether the instance is
  /// optimized for Amazon EBS I/O.
  ///
  /// *    `iam-instance-profile` - The ARN of the IAM instance profile.
  ///
  /// *    `image-id` - The ID of the AMI.
  ///
  /// *    `instance-type` - The instance type.
  ///
  /// *    `is-default-version` - A boolean that indicates whether the launch
  /// template version is the default version.
  ///
  /// *    `kernel-id` - The kernel ID.
  ///
  /// *    `ram-disk-id` - The RAM disk ID.
  Future<DescribeLaunchTemplateVersionsResult> describeLaunchTemplateVersions(
      {bool dryRun,
      String launchTemplateId,
      String launchTemplateName,
      List<String> versions,
      String minVersion,
      String maxVersion,
      String nextToken,
      int maxResults,
      List<Filter> filters}) async {
    var response_ = await _client.send('DescribeLaunchTemplateVersions', {
      if (dryRun != null) 'DryRun': dryRun,
      if (launchTemplateId != null) 'LaunchTemplateId': launchTemplateId,
      if (launchTemplateName != null) 'LaunchTemplateName': launchTemplateName,
      if (versions != null) 'Versions': versions,
      if (minVersion != null) 'MinVersion': minVersion,
      if (maxVersion != null) 'MaxVersion': maxVersion,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
      if (filters != null) 'Filters': filters,
    });
    return DescribeLaunchTemplateVersionsResult.fromJson(response_);
  }

  /// Describes one or more launch templates.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [launchTemplateIds]: One or more launch template IDs.
  ///
  /// [launchTemplateNames]: One or more launch template names.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `create-time` - The time the launch template was created.
  ///
  /// *    `launch-template-name` - The name of the launch template.
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// [nextToken]: The token to request the next page of results.
  ///
  /// [maxResults]: The maximum number of results to return in a single call. To
  /// retrieve the remaining results, make another call with the returned
  /// `NextToken` value. This value can be between 1 and 200.
  Future<DescribeLaunchTemplatesResult> describeLaunchTemplates(
      {bool dryRun,
      List<String> launchTemplateIds,
      List<String> launchTemplateNames,
      List<Filter> filters,
      String nextToken,
      int maxResults}) async {
    var response_ = await _client.send('DescribeLaunchTemplates', {
      if (dryRun != null) 'DryRun': dryRun,
      if (launchTemplateIds != null) 'LaunchTemplateIds': launchTemplateIds,
      if (launchTemplateNames != null)
        'LaunchTemplateNames': launchTemplateNames,
      if (filters != null) 'Filters': filters,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
    });
    return DescribeLaunchTemplatesResult.fromJson(response_);
  }

  /// Describes your Elastic IP addresses that are being moved to the EC2-VPC
  /// platform, or that are being restored to the EC2-Classic platform. This
  /// request does not return information about any other Elastic IP addresses
  /// in your account.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `moving-status` - The status of the Elastic IP address (`MovingToVpc`
  /// | `RestoringToClassic`).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [maxResults]: The maximum number of results to return for the request in a
  /// single page. The remaining results of the initial request can be seen by
  /// sending another request with the returned `NextToken` value. This value
  /// can be between 5 and 1000; if `MaxResults` is given a value outside of
  /// this range, an error is returned.
  ///
  /// Default: If no value is provided, the default is 1000.
  ///
  /// [nextToken]: The token for the next page of results.
  ///
  /// [publicIps]: One or more Elastic IP addresses.
  Future<DescribeMovingAddressesResult> describeMovingAddresses(
      {List<Filter> filters,
      bool dryRun,
      int maxResults,
      String nextToken,
      List<String> publicIps}) async {
    var response_ = await _client.send('DescribeMovingAddresses', {
      if (filters != null) 'Filters': filters,
      if (dryRun != null) 'DryRun': dryRun,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (publicIps != null) 'PublicIps': publicIps,
    });
    return DescribeMovingAddressesResult.fromJson(response_);
  }

  /// Describes one or more of your NAT gateways.
  ///
  /// [filter]: One or more filters.
  ///
  /// *    `nat-gateway-id` - The ID of the NAT gateway.
  ///
  /// *    `state` - The state of the NAT gateway (`pending` | `failed` |
  /// `available` | `deleting` | `deleted`).
  ///
  /// *    `subnet-id` - The ID of the subnet in which the NAT gateway resides.
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// *    `vpc-id` - The ID of the VPC in which the NAT gateway resides.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  ///
  /// [natGatewayIds]: One or more NAT gateway IDs.
  ///
  /// [nextToken]: The token for the next page of results.
  Future<DescribeNatGatewaysResult> describeNatGateways(
      {List<Filter> filter,
      int maxResults,
      List<String> natGatewayIds,
      String nextToken}) async {
    var response_ = await _client.send('DescribeNatGateways', {
      if (filter != null) 'Filter': filter,
      if (maxResults != null) 'MaxResults': maxResults,
      if (natGatewayIds != null) 'NatGatewayIds': natGatewayIds,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeNatGatewaysResult.fromJson(response_);
  }

  /// Describes one or more of your network ACLs.
  ///
  /// For more information, see
  /// [Network ACLs](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_ACLs.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `association.association-id` - The ID of an association ID for the
  /// ACL.
  ///
  /// *    `association.network-acl-id` - The ID of the network ACL involved in
  /// the association.
  ///
  /// *    `association.subnet-id` - The ID of the subnet involved in the
  /// association.
  ///
  /// *    `default` - Indicates whether the ACL is the default network ACL for
  /// the VPC.
  ///
  /// *    `entry.cidr` - The IPv4 CIDR range specified in the entry.
  ///
  /// *    `entry.icmp.code` - The ICMP code specified in the entry, if any.
  ///
  /// *    `entry.icmp.type` - The ICMP type specified in the entry, if any.
  ///
  /// *    `entry.ipv6-cidr` - The IPv6 CIDR range specified in the entry.
  ///
  /// *    `entry.port-range.from` - The start of the port range specified in
  /// the entry.
  ///
  /// *    `entry.port-range.to` - The end of the port range specified in the
  /// entry.
  ///
  /// *    `entry.protocol` - The protocol specified in the entry (`tcp` | `udp`
  /// | `icmp` or a protocol number).
  ///
  /// *    `entry.rule-action` - Allows or denies the matching traffic (`allow`
  /// | `deny`).
  ///
  /// *    `entry.rule-number` - The number of an entry (in other words, rule)
  /// in the set of ACL entries.
  ///
  /// *    `network-acl-id` - The ID of the network ACL.
  ///
  /// *    `owner-id` - The ID of the AWS account that owns the network ACL.
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// *    `vpc-id` - The ID of the VPC for the network ACL.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [networkAclIds]: One or more network ACL IDs.
  ///
  /// Default: Describes all your network ACLs.
  ///
  /// [nextToken]: The token for the next page of results.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  Future<DescribeNetworkAclsResult> describeNetworkAcls(
      {List<Filter> filters,
      bool dryRun,
      List<String> networkAclIds,
      String nextToken,
      int maxResults}) async {
    var response_ = await _client.send('DescribeNetworkAcls', {
      if (filters != null) 'Filters': filters,
      if (dryRun != null) 'DryRun': dryRun,
      if (networkAclIds != null) 'NetworkAclIds': networkAclIds,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
    });
    return DescribeNetworkAclsResult.fromJson(response_);
  }

  /// Describes a network interface attribute. You can specify only one
  /// attribute at a time.
  ///
  /// [attribute]: The attribute of the network interface. This parameter is
  /// required.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [networkInterfaceId]: The ID of the network interface.
  Future<DescribeNetworkInterfaceAttributeResult>
      describeNetworkInterfaceAttribute(String networkInterfaceId,
          {String attribute, bool dryRun}) async {
    var response_ = await _client.send('DescribeNetworkInterfaceAttribute', {
      if (attribute != null) 'Attribute': attribute,
      if (dryRun != null) 'DryRun': dryRun,
      'NetworkInterfaceId': networkInterfaceId,
    });
    return DescribeNetworkInterfaceAttributeResult.fromJson(response_);
  }

  /// Describes the permissions for your network interfaces.
  ///
  /// [networkInterfacePermissionIds]: One or more network interface permission
  /// IDs.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `network-interface-permission.network-interface-permission-id` - The
  /// ID of the permission.
  ///
  /// *    `network-interface-permission.network-interface-id` - The ID of the
  /// network interface.
  ///
  /// *    `network-interface-permission.aws-account-id` - The AWS account ID.
  ///
  /// *    `network-interface-permission.aws-service` - The AWS service.
  ///
  /// *    `network-interface-permission.permission` - The type of permission
  /// (`INSTANCE-ATTACH` | `EIP-ASSOCIATE`).
  ///
  /// [nextToken]: The token to request the next page of results.
  ///
  /// [maxResults]: The maximum number of results to return in a single call. To
  /// retrieve the remaining results, make another call with the returned
  /// `NextToken` value. If this parameter is not specified, up to 50 results
  /// are returned by default.
  Future<DescribeNetworkInterfacePermissionsResult>
      describeNetworkInterfacePermissions(
          {List<String> networkInterfacePermissionIds,
          List<Filter> filters,
          String nextToken,
          int maxResults}) async {
    var response_ = await _client.send('DescribeNetworkInterfacePermissions', {
      if (networkInterfacePermissionIds != null)
        'NetworkInterfacePermissionIds': networkInterfacePermissionIds,
      if (filters != null) 'Filters': filters,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
    });
    return DescribeNetworkInterfacePermissionsResult.fromJson(response_);
  }

  /// Describes one or more of your network interfaces.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `addresses.private-ip-address` - The private IPv4 addresses
  /// associated with the network interface.
  ///
  /// *    `addresses.primary` - Whether the private IPv4 address is the primary
  /// IP address associated with the network interface.
  ///
  /// *    `addresses.association.public-ip` - The association ID returned when
  /// the network interface was associated with the Elastic IP address (IPv4).
  ///
  /// *    `addresses.association.owner-id` - The owner ID of the addresses
  /// associated with the network interface.
  ///
  /// *    `association.association-id` - The association ID returned when the
  /// network interface was associated with an IPv4 address.
  ///
  /// *    `association.allocation-id` - The allocation ID returned when you
  /// allocated the Elastic IP address (IPv4) for your network interface.
  ///
  /// *    `association.ip-owner-id` - The owner of the Elastic IP address
  /// (IPv4) associated with the network interface.
  ///
  /// *    `association.public-ip` - The address of the Elastic IP address
  /// (IPv4) bound to the network interface.
  ///
  /// *    `association.public-dns-name` - The public DNS name for the network
  /// interface (IPv4).
  ///
  /// *    `attachment.attachment-id` - The ID of the interface attachment.
  ///
  /// *    `attachment.attach-time` - The time that the network interface was
  /// attached to an instance.
  ///
  /// *    `attachment.delete-on-termination` - Indicates whether the attachment
  /// is deleted when an instance is terminated.
  ///
  /// *    `attachment.device-index` - The device index to which the network
  /// interface is attached.
  ///
  /// *    `attachment.instance-id` - The ID of the instance to which the
  /// network interface is attached.
  ///
  /// *    `attachment.instance-owner-id` - The owner ID of the instance to
  /// which the network interface is attached.
  ///
  /// *    `attachment.nat-gateway-id` - The ID of the NAT gateway to which the
  /// network interface is attached.
  ///
  /// *    `attachment.status` - The status of the attachment (`attaching` |
  /// `attached` | `detaching` | `detached`).
  ///
  /// *    `availability-zone` - The Availability Zone of the network interface.
  ///
  /// *    `description` - The description of the network interface.
  ///
  /// *    `group-id` - The ID of a security group associated with the network
  /// interface.
  ///
  /// *    `group-name` - The name of a security group associated with the
  /// network interface.
  ///
  /// *    `ipv6-addresses.ipv6-address` - An IPv6 address associated with the
  /// network interface.
  ///
  /// *    `mac-address` - The MAC address of the network interface.
  ///
  /// *    `network-interface-id` - The ID of the network interface.
  ///
  /// *    `owner-id` - The AWS account ID of the network interface owner.
  ///
  /// *    `private-ip-address` - The private IPv4 address or addresses of the
  /// network interface.
  ///
  /// *    `private-dns-name` - The private DNS name of the network interface
  /// (IPv4).
  ///
  /// *    `requester-id` - The ID of the entity that launched the instance on
  /// your behalf (for example, AWS Management Console, Auto Scaling, and so
  /// on).
  ///
  /// *    `requester-managed` - Indicates whether the network interface is
  /// being managed by an AWS service (for example, AWS Management Console, Auto
  /// Scaling, and so on).
  ///
  /// *    `source-dest-check` - Indicates whether the network interface
  /// performs source/destination checking. A value of `true` means checking is
  /// enabled, and `false` means checking is disabled. The value must be `false`
  /// for the network interface to perform network address translation (NAT) in
  /// your VPC.
  ///
  /// *    `status` - The status of the network interface. If the network
  /// interface is not attached to an instance, the status is `available`; if a
  /// network interface is attached to an instance the status is `in-use`.
  ///
  /// *    `subnet-id` - The ID of the subnet for the network interface.
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// *    `vpc-id` - The ID of the VPC for the network interface.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [networkInterfaceIds]: One or more network interface IDs.
  ///
  /// Default: Describes all your network interfaces.
  ///
  /// [nextToken]: The token to retrieve the next page of results.
  ///
  /// [maxResults]: The maximum number of items to return for this request. The
  /// request returns a token that you can specify in a subsequent call to get
  /// the next set of results.
  Future<DescribeNetworkInterfacesResult> describeNetworkInterfaces(
      {List<Filter> filters,
      bool dryRun,
      List<String> networkInterfaceIds,
      String nextToken,
      int maxResults}) async {
    var response_ = await _client.send('DescribeNetworkInterfaces', {
      if (filters != null) 'Filters': filters,
      if (dryRun != null) 'DryRun': dryRun,
      if (networkInterfaceIds != null)
        'NetworkInterfaceIds': networkInterfaceIds,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
    });
    return DescribeNetworkInterfacesResult.fromJson(response_);
  }

  /// Describes the specified placement groups or all of your placement groups.
  /// For more information, see
  /// [Placement Groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [filters]: The filters.
  ///
  /// *    `group-name` - The name of the placement group.
  ///
  /// *    `state` - The state of the placement group (`pending` | `available` |
  /// `deleting` | `deleted`).
  ///
  /// *    `strategy` - The strategy of the placement group (`cluster` |
  /// `spread` | `partition`).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [groupNames]: The names of the placement groups.
  ///
  /// Default: Describes all your placement groups, or only those otherwise
  /// specified.
  Future<DescribePlacementGroupsResult> describePlacementGroups(
      {List<Filter> filters, bool dryRun, List<String> groupNames}) async {
    var response_ = await _client.send('DescribePlacementGroups', {
      if (filters != null) 'Filters': filters,
      if (dryRun != null) 'DryRun': dryRun,
      if (groupNames != null) 'GroupNames': groupNames,
    });
    return DescribePlacementGroupsResult.fromJson(response_);
  }

  /// Describes available AWS services in a prefix list format, which includes
  /// the prefix list name and prefix list ID of the service and the IP address
  /// range for the service. A prefix list ID is required for creating an
  /// outbound security group rule that allows traffic from a VPC to access an
  /// AWS service through a gateway VPC endpoint. Currently, the services that
  /// support this action are Amazon S3 and Amazon DynamoDB.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `prefix-list-id`: The ID of a prefix list.
  ///
  /// *    `prefix-list-name`: The name of a prefix list.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  ///
  /// [nextToken]: The token for the next page of results.
  ///
  /// [prefixListIds]: One or more prefix list IDs.
  Future<DescribePrefixListsResult> describePrefixLists(
      {bool dryRun,
      List<Filter> filters,
      int maxResults,
      String nextToken,
      List<String> prefixListIds}) async {
    var response_ = await _client.send('DescribePrefixLists', {
      if (dryRun != null) 'DryRun': dryRun,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (prefixListIds != null) 'PrefixListIds': prefixListIds,
    });
    return DescribePrefixListsResult.fromJson(response_);
  }

  /// Describes the ID format settings for the root user and all IAM roles and
  /// IAM users that have explicitly specified a longer ID (17-character ID)
  /// preference.
  ///
  /// By default, all IAM roles and IAM users default to the same ID settings as
  /// the root user, unless they explicitly override the settings. This request
  /// is useful for identifying those IAM users and IAM roles that have
  /// overridden the default ID settings.
  ///
  /// The following resource types support longer IDs: `bundle` |
  /// `conversion-task` | `customer-gateway` | `dhcp-options` |
  /// `elastic-ip-allocation` | `elastic-ip-association` | `export-task` |
  /// `flow-log` | `image` | `import-task` | `instance` | `internet-gateway` |
  /// `network-acl` | `network-acl-association` | `network-interface` |
  /// `network-interface-attachment` | `prefix-list` | `reservation` |
  /// `route-table` | `route-table-association` | `security-group` | `snapshot`
  /// | `subnet` | `subnet-cidr-block-association` | `volume` | `vpc` |
  /// `vpc-cidr-block-association` | `vpc-endpoint` | `vpc-peering-connection` |
  /// `vpn-connection` | `vpn-gateway`.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [resources]: The type of resource: `bundle` | `conversion-task` |
  /// `customer-gateway` | `dhcp-options` | `elastic-ip-allocation` |
  /// `elastic-ip-association` | `export-task` | `flow-log` | `image` |
  /// `import-task` | `instance` | `internet-gateway` | `network-acl` |
  /// `network-acl-association` | `network-interface` |
  /// `network-interface-attachment` | `prefix-list` | `reservation` |
  /// `route-table` | `route-table-association` | `security-group` | `snapshot`
  /// | `subnet` | `subnet-cidr-block-association` | `volume` | `vpc` |
  /// `vpc-cidr-block-association` | `vpc-endpoint` | `vpc-peering-connection` |
  /// `vpn-connection` | `vpn-gateway`
  ///
  /// [maxResults]: The maximum number of results to return in a single call. To
  /// retrieve the remaining results, make another call with the returned
  /// NextToken value.
  ///
  /// [nextToken]: The token to request the next page of results.
  Future<DescribePrincipalIdFormatResult> describePrincipalIdFormat(
      {bool dryRun,
      List<String> resources,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribePrincipalIdFormat', {
      if (dryRun != null) 'DryRun': dryRun,
      if (resources != null) 'Resources': resources,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribePrincipalIdFormatResult.fromJson(response_);
  }

  /// Describes the specified IPv4 address pools.
  ///
  /// [poolIds]: The IDs of the address pools.
  ///
  /// [nextToken]: The token for the next page of results.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  Future<DescribePublicIpv4PoolsResult> describePublicIpv4Pools(
      {List<String> poolIds, String nextToken, int maxResults}) async {
    var response_ = await _client.send('DescribePublicIpv4Pools', {
      if (poolIds != null) 'PoolIds': poolIds,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
    });
    return DescribePublicIpv4PoolsResult.fromJson(response_);
  }

  /// Describes the Regions that are enabled for your account, or all Regions.
  ///
  /// For a list of the Regions supported by Amazon EC2, see
  /// [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region).
  ///
  /// For information about enabling and disabling Regions for your account, see
  /// [Managing AWS Regions](https://docs.aws.amazon.com/general/latest/gr/rande-manage.html)
  /// in the _AWS General Reference_.
  ///
  /// [filters]: The filters.
  ///
  /// *    `endpoint` - The endpoint of the Region (for example,
  /// `ec2.us-east-1.amazonaws.com`).
  ///
  /// *    `opt-in-status` - The opt-in status of the Region
  /// (`opt-in-not-required` | `opted-in` | `not-opted-in`).
  ///
  /// *    `region-name` - The name of the Region (for example, `us-east-1`).
  ///
  /// [regionNames]: The names of the Regions. You can specify any Regions,
  /// whether they are enabled and disabled for your account.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [allRegions]: Indicates whether to display all Regions, including Regions
  /// that are disabled for your account.
  Future<DescribeRegionsResult> describeRegions(
      {List<Filter> filters,
      List<String> regionNames,
      bool dryRun,
      bool allRegions}) async {
    var response_ = await _client.send('DescribeRegions', {
      if (filters != null) 'Filters': filters,
      if (regionNames != null) 'RegionNames': regionNames,
      if (dryRun != null) 'DryRun': dryRun,
      if (allRegions != null) 'AllRegions': allRegions,
    });
    return DescribeRegionsResult.fromJson(response_);
  }

  /// Describes one or more of the Reserved Instances that you purchased.
  ///
  /// For more information about Reserved Instances, see
  /// [Reserved Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/concepts-on-demand-reserved-instances.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `availability-zone` - The Availability Zone where the Reserved
  /// Instance can be used.
  ///
  /// *    `duration` - The duration of the Reserved Instance (one year or three
  /// years), in seconds (`31536000` | `94608000`).
  ///
  /// *    `end` - The time when the Reserved Instance expires (for example,
  /// 2015-08-07T11:54:42.000Z).
  ///
  /// *    `fixed-price` - The purchase price of the Reserved Instance (for
  /// example, 9800.0).
  ///
  /// *    `instance-type` - The instance type that is covered by the
  /// reservation.
  ///
  /// *    `scope` - The scope of the Reserved Instance (`Region` or
  /// `Availability Zone`).
  ///
  /// *    `product-description` - The Reserved Instance product platform
  /// description. Instances that include `(Amazon VPC)` in the product platform
  /// description will only be displayed to EC2-Classic account holders and are
  /// for use with Amazon VPC (`Linux/UNIX` | `Linux/UNIX (Amazon VPC)` | `SUSE
  /// Linux` | `SUSE Linux (Amazon VPC)` | `Red Hat Enterprise Linux` | `Red Hat
  /// Enterprise Linux (Amazon VPC)` | `Windows` | `Windows (Amazon VPC)` |
  /// `Windows with SQL Server Standard` | `Windows with SQL Server Standard
  /// (Amazon VPC)` | `Windows with SQL Server Web` | `Windows with SQL Server
  /// Web (Amazon VPC)` | `Windows with SQL Server Enterprise` | `Windows with
  /// SQL Server Enterprise (Amazon VPC)`).
  ///
  /// *    `reserved-instances-id` - The ID of the Reserved Instance.
  ///
  /// *    `start` - The time at which the Reserved Instance purchase request
  /// was placed (for example, 2014-08-07T11:54:42.000Z).
  ///
  /// *    `state` - The state of the Reserved Instance (`payment-pending` |
  /// `active` | `payment-failed` | `retired`).
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// *    `usage-price` - The usage price of the Reserved Instance, per hour
  /// (for example, 0.84).
  ///
  /// [offeringClass]: Describes whether the Reserved Instance is Standard or
  /// Convertible.
  ///
  /// [reservedInstancesIds]: One or more Reserved Instance IDs.
  ///
  /// Default: Describes all your Reserved Instances, or only those otherwise
  /// specified.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [offeringType]: The Reserved Instance offering type. If you are using
  /// tools that predate the 2011-11-01 API version, you only have access to the
  /// `Medium Utilization` Reserved Instance offering type.
  Future<DescribeReservedInstancesResult> describeReservedInstances(
      {List<Filter> filters,
      String offeringClass,
      List<String> reservedInstancesIds,
      bool dryRun,
      String offeringType}) async {
    var response_ = await _client.send('DescribeReservedInstances', {
      if (filters != null) 'Filters': filters,
      if (offeringClass != null) 'OfferingClass': offeringClass,
      if (reservedInstancesIds != null)
        'ReservedInstancesIds': reservedInstancesIds,
      if (dryRun != null) 'DryRun': dryRun,
      if (offeringType != null) 'OfferingType': offeringType,
    });
    return DescribeReservedInstancesResult.fromJson(response_);
  }

  /// Describes your account's Reserved Instance listings in the Reserved
  /// Instance Marketplace.
  ///
  /// The Reserved Instance Marketplace matches sellers who want to resell
  /// Reserved Instance capacity that they no longer need with buyers who want
  /// to purchase additional capacity. Reserved Instances bought and sold
  /// through the Reserved Instance Marketplace work like any other Reserved
  /// Instances.
  ///
  /// As a seller, you choose to list some or all of your Reserved Instances,
  /// and you specify the upfront price to receive for them. Your Reserved
  /// Instances are then listed in the Reserved Instance Marketplace and are
  /// available for purchase.
  ///
  /// As a buyer, you specify the configuration of the Reserved Instance to
  /// purchase, and the Marketplace matches what you're searching for with
  /// what's available. The Marketplace first sells the lowest priced Reserved
  /// Instances to you, and continues to sell available Reserved Instance
  /// listings to you until your demand is met. You are charged based on the
  /// total price of all of the listings that you purchase.
  ///
  /// For more information, see
  /// [Reserved Instance Marketplace](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-market-general.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `reserved-instances-id` - The ID of the Reserved Instances.
  ///
  /// *    `reserved-instances-listing-id` - The ID of the Reserved Instances
  /// listing.
  ///
  /// *    `status` - The status of the Reserved Instance listing (`pending` |
  /// `active` | `cancelled` | `closed`).
  ///
  /// *    `status-message` - The reason for the status.
  ///
  /// [reservedInstancesId]: One or more Reserved Instance IDs.
  ///
  /// [reservedInstancesListingId]: One or more Reserved Instance listing IDs.
  Future<DescribeReservedInstancesListingsResult>
      describeReservedInstancesListings(
          {List<Filter> filters,
          String reservedInstancesId,
          String reservedInstancesListingId}) async {
    var response_ = await _client.send('DescribeReservedInstancesListings', {
      if (filters != null) 'Filters': filters,
      if (reservedInstancesId != null)
        'ReservedInstancesId': reservedInstancesId,
      if (reservedInstancesListingId != null)
        'ReservedInstancesListingId': reservedInstancesListingId,
    });
    return DescribeReservedInstancesListingsResult.fromJson(response_);
  }

  /// Describes the modifications made to your Reserved Instances. If no
  /// parameter is specified, information about all your Reserved Instances
  /// modification requests is returned. If a modification ID is specified, only
  /// information about the specific modification is returned.
  ///
  /// For more information, see
  /// [Modifying Reserved Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-modifying.html)
  /// in the Amazon Elastic Compute Cloud User Guide.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `client-token` - The idempotency token for the modification request.
  ///
  /// *    `create-date` - The time when the modification request was created.
  ///
  /// *    `effective-date` - The time when the modification becomes effective.
  ///
  /// *    `modification-result.reserved-instances-id` - The ID for the Reserved
  /// Instances created as part of the modification request. This ID is only
  /// available when the status of the modification is `fulfilled`.
  ///
  /// *    `modification-result.target-configuration.availability-zone` - The
  /// Availability Zone for the new Reserved Instances.
  ///
  /// *    `modification-result.target-configuration.instance-count`  - The
  /// number of new Reserved Instances.
  ///
  /// *    `modification-result.target-configuration.instance-type` - The
  /// instance type of the new Reserved Instances.
  ///
  /// *    `modification-result.target-configuration.platform` - The network
  /// platform of the new Reserved Instances (`EC2-Classic` | `EC2-VPC`).
  ///
  /// *    `reserved-instances-id` - The ID of the Reserved Instances modified.
  ///
  /// *    `reserved-instances-modification-id` - The ID of the modification
  /// request.
  ///
  /// *    `status` - The status of the Reserved Instances modification request
  /// (`processing` | `fulfilled` | `failed`).
  ///
  /// *    `status-message` - The reason for the status.
  ///
  /// *    `update-date` - The time when the modification request was last
  /// updated.
  ///
  /// [reservedInstancesModificationIds]: IDs for the submitted modification
  /// request.
  ///
  /// [nextToken]: The token to retrieve the next page of results.
  Future<DescribeReservedInstancesModificationsResult>
      describeReservedInstancesModifications(
          {List<Filter> filters,
          List<String> reservedInstancesModificationIds,
          String nextToken}) async {
    var response_ =
        await _client.send('DescribeReservedInstancesModifications', {
      if (filters != null) 'Filters': filters,
      if (reservedInstancesModificationIds != null)
        'ReservedInstancesModificationIds': reservedInstancesModificationIds,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeReservedInstancesModificationsResult.fromJson(response_);
  }

  /// Describes Reserved Instance offerings that are available for purchase.
  /// With Reserved Instances, you purchase the right to launch instances for a
  /// period of time. During that time period, you do not receive insufficient
  /// capacity errors, and you pay a lower usage rate than the rate charged for
  /// On-Demand instances for the actual time used.
  ///
  /// If you have listed your own Reserved Instances for sale in the Reserved
  /// Instance Marketplace, they will be excluded from these results. This is to
  /// ensure that you do not purchase your own Reserved Instances.
  ///
  /// For more information, see
  /// [Reserved Instance Marketplace](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-market-general.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [availabilityZone]: The Availability Zone in which the Reserved Instance
  /// can be used.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `availability-zone` - The Availability Zone where the Reserved
  /// Instance can be used.
  ///
  /// *    `duration` - The duration of the Reserved Instance (for example, one
  /// year or three years), in seconds (`31536000` | `94608000`).
  ///
  /// *    `fixed-price` - The purchase price of the Reserved Instance (for
  /// example, 9800.0).
  ///
  /// *    `instance-type` - The instance type that is covered by the
  /// reservation.
  ///
  /// *    `marketplace` - Set to `true` to show only Reserved Instance
  /// Marketplace offerings. When this filter is not used, which is the default
  /// behavior, all offerings from both AWS and the Reserved Instance
  /// Marketplace are listed.
  ///
  /// *    `product-description` - The Reserved Instance product platform
  /// description. Instances that include `(Amazon VPC)` in the product platform
  /// description will only be displayed to EC2-Classic account holders and are
  /// for use with Amazon VPC. (`Linux/UNIX` | `Linux/UNIX (Amazon VPC)` | `SUSE
  /// Linux` | `SUSE Linux (Amazon VPC)` | `Red Hat Enterprise Linux` | `Red Hat
  /// Enterprise Linux (Amazon VPC)` | `Windows` | `Windows (Amazon VPC)` |
  /// `Windows with SQL Server Standard` | `Windows with SQL Server Standard
  /// (Amazon VPC)` | `Windows with SQL Server Web` |  `Windows with SQL Server
  /// Web (Amazon VPC)` | `Windows with SQL Server Enterprise` | `Windows with
  /// SQL Server Enterprise (Amazon VPC)`)
  ///
  /// *    `reserved-instances-offering-id` - The Reserved Instances offering
  /// ID.
  ///
  /// *    `scope` - The scope of the Reserved Instance (`Availability Zone` or
  /// `Region`).
  ///
  /// *    `usage-price` - The usage price of the Reserved Instance, per hour
  /// (for example, 0.84).
  ///
  /// [includeMarketplace]: Include Reserved Instance Marketplace offerings in
  /// the response.
  ///
  /// [instanceType]: The instance type that the reservation will cover (for
  /// example, `m1.small`). For more information, see
  /// [Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [maxDuration]: The maximum duration (in seconds) to filter when searching
  /// for offerings.
  ///
  /// Default: 94608000 (3 years)
  ///
  /// [maxInstanceCount]: The maximum number of instances to filter when
  /// searching for offerings.
  ///
  /// Default: 20
  ///
  /// [minDuration]: The minimum duration (in seconds) to filter when searching
  /// for offerings.
  ///
  /// Default: 2592000 (1 month)
  ///
  /// [offeringClass]: The offering class of the Reserved Instance. Can be
  /// `standard` or `convertible`.
  ///
  /// [productDescription]: The Reserved Instance product platform description.
  /// Instances that include `(Amazon VPC)` in the description are for use with
  /// Amazon VPC.
  ///
  /// [reservedInstancesOfferingIds]: One or more Reserved Instances offering
  /// IDs.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [instanceTenancy]: The tenancy of the instances covered by the
  /// reservation. A Reserved Instance with a tenancy of `dedicated` is applied
  /// to instances that run in a VPC on single-tenant hardware (i.e., Dedicated
  /// Instances).
  ///
  ///  **Important:** The `host` value cannot be used with this parameter. Use
  /// the `default` or `dedicated` values only.
  ///
  /// Default: `default`
  ///
  /// [maxResults]: The maximum number of results to return for the request in a
  /// single page. The remaining results of the initial request can be seen by
  /// sending another request with the returned `NextToken` value. The maximum
  /// is 100.
  ///
  /// Default: 100
  ///
  /// [nextToken]: The token to retrieve the next page of results.
  ///
  /// [offeringType]: The Reserved Instance offering type. If you are using
  /// tools that predate the 2011-11-01 API version, you only have access to the
  /// `Medium Utilization` Reserved Instance offering type.
  Future<DescribeReservedInstancesOfferingsResult>
      describeReservedInstancesOfferings(
          {String availabilityZone,
          List<Filter> filters,
          bool includeMarketplace,
          String instanceType,
          BigInt maxDuration,
          int maxInstanceCount,
          BigInt minDuration,
          String offeringClass,
          String productDescription,
          List<String> reservedInstancesOfferingIds,
          bool dryRun,
          String instanceTenancy,
          int maxResults,
          String nextToken,
          String offeringType}) async {
    var response_ = await _client.send('DescribeReservedInstancesOfferings', {
      if (availabilityZone != null) 'AvailabilityZone': availabilityZone,
      if (filters != null) 'Filters': filters,
      if (includeMarketplace != null) 'IncludeMarketplace': includeMarketplace,
      if (instanceType != null) 'InstanceType': instanceType,
      if (maxDuration != null) 'MaxDuration': maxDuration,
      if (maxInstanceCount != null) 'MaxInstanceCount': maxInstanceCount,
      if (minDuration != null) 'MinDuration': minDuration,
      if (offeringClass != null) 'OfferingClass': offeringClass,
      if (productDescription != null) 'ProductDescription': productDescription,
      if (reservedInstancesOfferingIds != null)
        'ReservedInstancesOfferingIds': reservedInstancesOfferingIds,
      if (dryRun != null) 'DryRun': dryRun,
      if (instanceTenancy != null) 'InstanceTenancy': instanceTenancy,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (offeringType != null) 'OfferingType': offeringType,
    });
    return DescribeReservedInstancesOfferingsResult.fromJson(response_);
  }

  /// Describes one or more of your route tables.
  ///
  /// Each subnet in your VPC must be associated with a route table. If a subnet
  /// is not explicitly associated with any route table, it is implicitly
  /// associated with the main route table. This command does not return the
  /// subnet ID for implicit associations.
  ///
  /// For more information, see
  /// [Route Tables](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Route_Tables.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `association.route-table-association-id` - The ID of an association
  /// ID for the route table.
  ///
  /// *    `association.route-table-id` - The ID of the route table involved in
  /// the association.
  ///
  /// *    `association.subnet-id` - The ID of the subnet involved in the
  /// association.
  ///
  /// *    `association.main` - Indicates whether the route table is the main
  /// route table for the VPC (`true` | `false`). Route tables that do not have
  /// an association ID are not returned in the response.
  ///
  /// *    `owner-id` - The ID of the AWS account that owns the route table.
  ///
  /// *    `route-table-id` - The ID of the route table.
  ///
  /// *    `route.destination-cidr-block` - The IPv4 CIDR range specified in a
  /// route in the table.
  ///
  /// *    `route.destination-ipv6-cidr-block` - The IPv6 CIDR range specified
  /// in a route in the route table.
  ///
  /// *    `route.destination-prefix-list-id` - The ID (prefix) of the AWS
  /// service specified in a route in the table.
  ///
  /// *    `route.egress-only-internet-gateway-id` - The ID of an egress-only
  /// Internet gateway specified in a route in the route table.
  ///
  /// *    `route.gateway-id` - The ID of a gateway specified in a route in the
  /// table.
  ///
  /// *    `route.instance-id` - The ID of an instance specified in a route in
  /// the table.
  ///
  /// *    `route.nat-gateway-id` - The ID of a NAT gateway.
  ///
  /// *    `route.transit-gateway-id` - The ID of a transit gateway.
  ///
  /// *    `route.origin` - Describes how the route was created.
  /// `CreateRouteTable` indicates that the route was automatically created when
  /// the route table was created; `CreateRoute` indicates that the route was
  /// manually added to the route table; `EnableVgwRoutePropagation` indicates
  /// that the route was propagated by route propagation.
  ///
  /// *    `route.state` - The state of a route in the route table (`active` |
  /// `blackhole`). The blackhole state indicates that the route's target isn't
  /// available (for example, the specified gateway isn't attached to the VPC,
  /// the specified NAT instance has been terminated, and so on).
  ///
  /// *    `route.vpc-peering-connection-id` - The ID of a VPC peering
  /// connection specified in a route in the table.
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// *    `transit-gateway-id` - The ID of a transit gateway.
  ///
  /// *    `vpc-id` - The ID of the VPC for the route table.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [routeTableIds]: One or more route table IDs.
  ///
  /// Default: Describes all your route tables.
  ///
  /// [nextToken]: The token for the next page of results.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  Future<DescribeRouteTablesResult> describeRouteTables(
      {List<Filter> filters,
      bool dryRun,
      List<String> routeTableIds,
      String nextToken,
      int maxResults}) async {
    var response_ = await _client.send('DescribeRouteTables', {
      if (filters != null) 'Filters': filters,
      if (dryRun != null) 'DryRun': dryRun,
      if (routeTableIds != null) 'RouteTableIds': routeTableIds,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
    });
    return DescribeRouteTablesResult.fromJson(response_);
  }

  /// Finds available schedules that meet the specified criteria.
  ///
  /// You can search for an available schedule no more than 3 months in advance.
  /// You must meet the minimum required duration of 1,200 hours per year. For
  /// example, the minimum daily schedule is 4 hours, the minimum weekly
  /// schedule is 24 hours, and the minimum monthly schedule is 100 hours.
  ///
  /// After you find a schedule that meets your needs, call
  /// PurchaseScheduledInstances to purchase Scheduled Instances with that
  /// schedule.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [filters]: The filters.
  ///
  /// *    `availability-zone` - The Availability Zone (for example,
  /// `us-west-2a`).
  ///
  /// *    `instance-type` - The instance type (for example, `c4.large`).
  ///
  /// *    `network-platform` - The network platform (`EC2-Classic` or
  /// `EC2-VPC`).
  ///
  /// *    `platform` - The platform (`Linux/UNIX` or `Windows`).
  ///
  /// [firstSlotStartTimeRange]: The time period for the first schedule to
  /// start.
  ///
  /// [maxResults]: The maximum number of results to return in a single call.
  /// This value can be between 5 and 300. The default value is 300. To retrieve
  /// the remaining results, make another call with the returned `NextToken`
  /// value.
  ///
  /// [maxSlotDurationInHours]: The maximum available duration, in hours. This
  /// value must be greater than `MinSlotDurationInHours` and less than 1,720.
  ///
  /// [minSlotDurationInHours]: The minimum available duration, in hours. The
  /// minimum required duration is 1,200 hours per year. For example, the
  /// minimum daily schedule is 4 hours, the minimum weekly schedule is 24
  /// hours, and the minimum monthly schedule is 100 hours.
  ///
  /// [nextToken]: The token for the next set of results.
  ///
  /// [recurrence]: The schedule recurrence.
  Future<DescribeScheduledInstanceAvailabilityResult>
      describeScheduledInstanceAvailability(
          {bool dryRun,
          List<Filter> filters,
          @required SlotDateTimeRangeRequest firstSlotStartTimeRange,
          int maxResults,
          int maxSlotDurationInHours,
          int minSlotDurationInHours,
          String nextToken,
          @required ScheduledInstanceRecurrenceRequest recurrence}) async {
    var response_ =
        await _client.send('DescribeScheduledInstanceAvailability', {
      if (dryRun != null) 'DryRun': dryRun,
      if (filters != null) 'Filters': filters,
      'FirstSlotStartTimeRange': firstSlotStartTimeRange,
      if (maxResults != null) 'MaxResults': maxResults,
      if (maxSlotDurationInHours != null)
        'MaxSlotDurationInHours': maxSlotDurationInHours,
      if (minSlotDurationInHours != null)
        'MinSlotDurationInHours': minSlotDurationInHours,
      if (nextToken != null) 'NextToken': nextToken,
      'Recurrence': recurrence,
    });
    return DescribeScheduledInstanceAvailabilityResult.fromJson(response_);
  }

  /// Describes the specified Scheduled Instances or all your Scheduled
  /// Instances.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [filters]: The filters.
  ///
  /// *    `availability-zone` - The Availability Zone (for example,
  /// `us-west-2a`).
  ///
  /// *    `instance-type` - The instance type (for example, `c4.large`).
  ///
  /// *    `network-platform` - The network platform (`EC2-Classic` or
  /// `EC2-VPC`).
  ///
  /// *    `platform` - The platform (`Linux/UNIX` or `Windows`).
  ///
  /// [maxResults]: The maximum number of results to return in a single call.
  /// This value can be between 5 and 300. The default value is 100. To retrieve
  /// the remaining results, make another call with the returned `NextToken`
  /// value.
  ///
  /// [nextToken]: The token for the next set of results.
  ///
  /// [scheduledInstanceIds]: The Scheduled Instance IDs.
  ///
  /// [slotStartTimeRange]: The time period for the first schedule to start.
  Future<DescribeScheduledInstancesResult> describeScheduledInstances(
      {bool dryRun,
      List<Filter> filters,
      int maxResults,
      String nextToken,
      List<String> scheduledInstanceIds,
      SlotStartTimeRangeRequest slotStartTimeRange}) async {
    var response_ = await _client.send('DescribeScheduledInstances', {
      if (dryRun != null) 'DryRun': dryRun,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (scheduledInstanceIds != null)
        'ScheduledInstanceIds': scheduledInstanceIds,
      if (slotStartTimeRange != null) 'SlotStartTimeRange': slotStartTimeRange,
    });
    return DescribeScheduledInstancesResult.fromJson(response_);
  }

  /// [VPC only] Describes the VPCs on the other side of a VPC peering
  /// connection that are referencing the security groups you've specified in
  /// this request.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [groupId]: The IDs of the security groups in your account.
  Future<DescribeSecurityGroupReferencesResult> describeSecurityGroupReferences(
      List<String> groupId,
      {bool dryRun}) async {
    var response_ = await _client.send('DescribeSecurityGroupReferences', {
      if (dryRun != null) 'DryRun': dryRun,
      'GroupId': groupId,
    });
    return DescribeSecurityGroupReferencesResult.fromJson(response_);
  }

  /// Describes the specified security groups or all of your security groups.
  ///
  /// A security group is for use with instances either in the EC2-Classic
  /// platform or in a specific VPC. For more information, see
  /// [Amazon EC2 Security Groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_ and
  /// [Security Groups for Your VPC](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [filters]: The filters. If using multiple filters for rules, the results
  /// include security groups for which any combination of rules - not
  /// necessarily a single rule - match all filters.
  ///
  /// *    `description` - The description of the security group.
  ///
  /// *    `egress.ip-permission.cidr` - An IPv4 CIDR block for an outbound
  /// security group rule.
  ///
  /// *    `egress.ip-permission.from-port` - For an outbound rule, the start of
  /// port range for the TCP and UDP protocols, or an ICMP type number.
  ///
  /// *    `egress.ip-permission.group-id` - The ID of a security group that has
  /// been referenced in an outbound security group rule.
  ///
  /// *    `egress.ip-permission.group-name` - The name of a security group that
  /// has been referenced in an outbound security group rule.
  ///
  /// *    `egress.ip-permission.ipv6-cidr` - An IPv6 CIDR block for an outbound
  /// security group rule.
  ///
  /// *    `egress.ip-permission.prefix-list-id` - The ID (prefix) of the AWS
  /// service to which a security group rule allows outbound access.
  ///
  /// *    `egress.ip-permission.protocol` - The IP protocol for an outbound
  /// security group rule (`tcp` | `udp` | `icmp` or a protocol number).
  ///
  /// *    `egress.ip-permission.to-port` - For an outbound rule, the end of
  /// port range for the TCP and UDP protocols, or an ICMP code.
  ///
  /// *    `egress.ip-permission.user-id` - The ID of an AWS account that has
  /// been referenced in an outbound security group rule.
  ///
  /// *    `group-id` - The ID of the security group.
  ///
  /// *    `group-name` - The name of the security group.
  ///
  /// *    `ip-permission.cidr` - An IPv4 CIDR block for an inbound security
  /// group rule.
  ///
  /// *    `ip-permission.from-port` - For an inbound rule, the start of port
  /// range for the TCP and UDP protocols, or an ICMP type number.
  ///
  /// *    `ip-permission.group-id` - The ID of a security group that has been
  /// referenced in an inbound security group rule.
  ///
  /// *    `ip-permission.group-name` - The name of a security group that has
  /// been referenced in an inbound security group rule.
  ///
  /// *    `ip-permission.ipv6-cidr` - An IPv6 CIDR block for an inbound
  /// security group rule.
  ///
  /// *    `ip-permission.prefix-list-id` - The ID (prefix) of the AWS service
  /// from which a security group rule allows inbound access.
  ///
  /// *    `ip-permission.protocol` - The IP protocol for an inbound security
  /// group rule (`tcp` | `udp` | `icmp` or a protocol number).
  ///
  /// *    `ip-permission.to-port` - For an inbound rule, the end of port range
  /// for the TCP and UDP protocols, or an ICMP code.
  ///
  /// *    `ip-permission.user-id` - The ID of an AWS account that has been
  /// referenced in an inbound security group rule.
  ///
  /// *    `owner-id` - The AWS account ID of the owner of the security group.
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// *    `vpc-id` - The ID of the VPC specified when the security group was
  /// created.
  ///
  /// [groupIds]: The IDs of the security groups. Required for security groups
  /// in a nondefault VPC.
  ///
  /// Default: Describes all your security groups.
  ///
  /// [groupNames]: [EC2-Classic and default VPC only] The names of the security
  /// groups. You can specify either the security group name or the security
  /// group ID. For security groups in a nondefault VPC, use the `group-name`
  /// filter to describe security groups by name.
  ///
  /// Default: Describes all your security groups.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [nextToken]: The token to request the next page of results.
  ///
  /// [maxResults]: The maximum number of results to return in a single call. To
  /// retrieve the remaining results, make another request with the returned
  /// `NextToken` value. This value can be between 5 and 1000. If this parameter
  /// is not specified, then all results are returned.
  Future<DescribeSecurityGroupsResult> describeSecurityGroups(
      {List<Filter> filters,
      List<String> groupIds,
      List<String> groupNames,
      bool dryRun,
      String nextToken,
      int maxResults}) async {
    var response_ = await _client.send('DescribeSecurityGroups', {
      if (filters != null) 'Filters': filters,
      if (groupIds != null) 'GroupIds': groupIds,
      if (groupNames != null) 'GroupNames': groupNames,
      if (dryRun != null) 'DryRun': dryRun,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
    });
    return DescribeSecurityGroupsResult.fromJson(response_);
  }

  /// Describes the specified attribute of the specified snapshot. You can
  /// specify only one attribute at a time.
  ///
  /// For more information about EBS snapshots, see
  /// [Amazon EBS Snapshots](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSSnapshots.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [attribute]: The snapshot attribute you would like to view.
  ///
  /// [snapshotId]: The ID of the EBS snapshot.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeSnapshotAttributeResult> describeSnapshotAttribute(
      {@required String attribute,
      @required String snapshotId,
      bool dryRun}) async {
    var response_ = await _client.send('DescribeSnapshotAttribute', {
      'Attribute': attribute,
      'SnapshotId': snapshotId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeSnapshotAttributeResult.fromJson(response_);
  }

  /// Describes the specified EBS snapshots available to you or all of the EBS
  /// snapshots available to you.
  ///
  /// The snapshots available to you include public snapshots, private snapshots
  /// that you own, and private snapshots owned by other AWS accounts for which
  /// you have explicit create volume permissions.
  ///
  /// The create volume permissions fall into the following categories:
  ///
  /// *    _public_: The owner of the snapshot granted create volume permissions
  /// for the snapshot to the `all` group. All AWS accounts have create volume
  /// permissions for these snapshots.
  ///
  /// *    _explicit_: The owner of the snapshot granted create volume
  /// permissions to a specific AWS account.
  ///
  /// *    _implicit_: An AWS account has implicit create volume permissions for
  /// all snapshots it owns.
  ///
  ///
  /// The list of snapshots returned can be modified by specifying snapshot IDs,
  /// snapshot owners, or AWS accounts with create volume permissions. If no
  /// options are specified, Amazon EC2 returns all snapshots for which you have
  /// create volume permissions.
  ///
  /// If you specify one or more snapshot IDs, only snapshots that have the
  /// specified IDs are returned. If you specify an invalid snapshot ID, an
  /// error is returned. If you specify a snapshot ID for which you do not have
  /// access, it is not included in the returned results.
  ///
  /// If you specify one or more snapshot owners using the `OwnerIds` option,
  /// only snapshots from the specified owners and for which you have access are
  /// returned. The results can include the AWS account IDs of the specified
  /// owners, `amazon` for snapshots owned by Amazon, or `self` for snapshots
  /// that you own.
  ///
  /// If you specify a list of restorable users, only snapshots with create
  /// snapshot permissions for those users are returned. You can specify AWS
  /// account IDs (if you own the snapshots), `self` for snapshots for which you
  /// own or have explicit permissions, or `all` for public snapshots.
  ///
  /// If you are describing a long list of snapshots, you can paginate the
  /// output to make the list more manageable. The `MaxResults` parameter sets
  /// the maximum number of results returned in a single page. If the list of
  /// results exceeds your `MaxResults` value, then that number of results is
  /// returned along with a `NextToken` value that can be passed to a subsequent
  /// `DescribeSnapshots` request to retrieve the remaining results.
  ///
  /// For more information about EBS snapshots, see
  /// [Amazon EBS Snapshots](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSSnapshots.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [filters]: The filters.
  ///
  /// *    `description` - A description of the snapshot.
  ///
  /// *    `encrypted` - Indicates whether the snapshot is encrypted (`true` |
  /// `false`)
  ///
  /// *    `owner-alias` - Value from an Amazon-maintained list (`amazon` |
  /// `self` | `all` | `aws-marketplace` | `microsoft`) of snapshot owners. Not
  /// to be confused with the user-configured AWS account alias, which is set
  /// from the IAM console.
  ///
  /// *    `owner-id` - The ID of the AWS account that owns the snapshot.
  ///
  /// *    `progress` - The progress of the snapshot, as a percentage (for
  /// example, 80%).
  ///
  /// *    `snapshot-id` - The snapshot ID.
  ///
  /// *    `start-time` - The time stamp when the snapshot was initiated.
  ///
  /// *    `status` - The status of the snapshot (`pending` | `completed` |
  /// `error`).
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// *    `volume-id` - The ID of the volume the snapshot is for.
  ///
  /// *    `volume-size` - The size of the volume, in GiB.
  ///
  /// [maxResults]: The maximum number of snapshot results returned by
  /// `DescribeSnapshots` in paginated output. When this parameter is used,
  /// `DescribeSnapshots` only returns `MaxResults` results in a single page
  /// along with a `NextToken` response element. The remaining results of the
  /// initial request can be seen by sending another `DescribeSnapshots` request
  /// with the returned `NextToken` value. This value can be between 5 and 1000;
  /// if `MaxResults` is given a value larger than 1000, only 1000 results are
  /// returned. If this parameter is not used, then `DescribeSnapshots` returns
  /// all results. You cannot specify this parameter and the snapshot IDs
  /// parameter in the same request.
  ///
  /// [nextToken]: The `NextToken` value returned from a previous paginated
  /// `DescribeSnapshots` request where `MaxResults` was used and the results
  /// exceeded the value of that parameter. Pagination continues from the end of
  /// the previous results that returned the `NextToken` value. This value is
  /// `null` when there are no more results to return.
  ///
  /// [ownerIds]: Describes the snapshots owned by these owners.
  ///
  /// [restorableByUserIds]: The IDs of the AWS accounts that can create volumes
  /// from the snapshot.
  ///
  /// [snapshotIds]: The snapshot IDs.
  ///
  /// Default: Describes the snapshots for which you have create volume
  /// permissions.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeSnapshotsResult> describeSnapshots(
      {List<Filter> filters,
      int maxResults,
      String nextToken,
      List<String> ownerIds,
      List<String> restorableByUserIds,
      List<String> snapshotIds,
      bool dryRun}) async {
    var response_ = await _client.send('DescribeSnapshots', {
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (ownerIds != null) 'OwnerIds': ownerIds,
      if (restorableByUserIds != null)
        'RestorableByUserIds': restorableByUserIds,
      if (snapshotIds != null) 'SnapshotIds': snapshotIds,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeSnapshotsResult.fromJson(response_);
  }

  /// Describes the data feed for Spot Instances. For more information, see
  /// [Spot Instance Data Feed](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-data-feeds.html)
  /// in the _Amazon EC2 User Guide for Linux Instances_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeSpotDatafeedSubscriptionResult>
      describeSpotDatafeedSubscription({bool dryRun}) async {
    var response_ = await _client.send('DescribeSpotDatafeedSubscription', {
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeSpotDatafeedSubscriptionResult.fromJson(response_);
  }

  /// Describes the running instances for the specified Spot Fleet.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [maxResults]: The maximum number of results to return in a single call.
  /// Specify a value between 1 and 1000. The default value is 1000. To retrieve
  /// the remaining results, make another call with the returned `NextToken`
  /// value.
  ///
  /// [nextToken]: The token for the next set of results.
  ///
  /// [spotFleetRequestId]: The ID of the Spot Fleet request.
  Future<DescribeSpotFleetInstancesResponse> describeSpotFleetInstances(
      String spotFleetRequestId,
      {bool dryRun,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeSpotFleetInstances', {
      if (dryRun != null) 'DryRun': dryRun,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      'SpotFleetRequestId': spotFleetRequestId,
    });
    return DescribeSpotFleetInstancesResponse.fromJson(response_);
  }

  /// Describes the events for the specified Spot Fleet request during the
  /// specified time.
  ///
  /// Spot Fleet events are delayed by up to 30 seconds before they can be
  /// described. This ensures that you can query by the last evaluated time and
  /// not miss a recorded event. Spot Fleet events are available for 48 hours.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [eventType]: The type of events to describe. By default, all events are
  /// described.
  ///
  /// [maxResults]: The maximum number of results to return in a single call.
  /// Specify a value between 1 and 1000. The default value is 1000. To retrieve
  /// the remaining results, make another call with the returned `NextToken`
  /// value.
  ///
  /// [nextToken]: The token for the next set of results.
  ///
  /// [spotFleetRequestId]: The ID of the Spot Fleet request.
  ///
  /// [startTime]: The starting date and time for the events, in UTC format (for
  /// example, _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z).
  Future<DescribeSpotFleetRequestHistoryResponse>
      describeSpotFleetRequestHistory(
          {bool dryRun,
          String eventType,
          int maxResults,
          String nextToken,
          @required String spotFleetRequestId,
          @required DateTime startTime}) async {
    var response_ = await _client.send('DescribeSpotFleetRequestHistory', {
      if (dryRun != null) 'DryRun': dryRun,
      if (eventType != null) 'EventType': eventType,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      'SpotFleetRequestId': spotFleetRequestId,
      'StartTime': startTime,
    });
    return DescribeSpotFleetRequestHistoryResponse.fromJson(response_);
  }

  /// Describes your Spot Fleet requests.
  ///
  /// Spot Fleet requests are deleted 48 hours after they are canceled and their
  /// instances are terminated.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [maxResults]: The maximum number of results to return in a single call.
  /// Specify a value between 1 and 1000. The default value is 1000. To retrieve
  /// the remaining results, make another call with the returned `NextToken`
  /// value.
  ///
  /// [nextToken]: The token for the next set of results.
  ///
  /// [spotFleetRequestIds]: The IDs of the Spot Fleet requests.
  Future<DescribeSpotFleetRequestsResponse> describeSpotFleetRequests(
      {bool dryRun,
      int maxResults,
      String nextToken,
      List<String> spotFleetRequestIds}) async {
    var response_ = await _client.send('DescribeSpotFleetRequests', {
      if (dryRun != null) 'DryRun': dryRun,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (spotFleetRequestIds != null)
        'SpotFleetRequestIds': spotFleetRequestIds,
    });
    return DescribeSpotFleetRequestsResponse.fromJson(response_);
  }

  /// Describes the specified Spot Instance requests.
  ///
  /// You can use `DescribeSpotInstanceRequests` to find a running Spot Instance
  /// by examining the response. If the status of the Spot Instance is
  /// `fulfilled`, the instance ID appears in the response and contains the
  /// identifier of the instance. Alternatively, you can use DescribeInstances
  /// with a filter to look for instances where the instance lifecycle is
  /// `spot`.
  ///
  /// We recommend that you set `MaxResults` to a value between 5 and 1000 to
  /// limit the number of results returned. This paginates the output, which
  /// makes the list more manageable and returns the results faster. If the list
  /// of results exceeds your `MaxResults` value, then that number of results is
  /// returned along with a `NextToken` value that can be passed to a subsequent
  /// `DescribeSpotInstanceRequests` request to retrieve the remaining results.
  ///
  /// Spot Instance requests are deleted four hours after they are canceled and
  /// their instances are terminated.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `availability-zone-group` - The Availability Zone group.
  ///
  /// *    `create-time` - The time stamp when the Spot Instance request was
  /// created.
  ///
  /// *    `fault-code` - The fault code related to the request.
  ///
  /// *    `fault-message` - The fault message related to the request.
  ///
  /// *    `instance-id` - The ID of the instance that fulfilled the request.
  ///
  /// *    `launch-group` - The Spot Instance launch group.
  ///
  /// *    `launch.block-device-mapping.delete-on-termination` - Indicates
  /// whether the EBS volume is deleted on instance termination.
  ///
  /// *    `launch.block-device-mapping.device-name` - The device name for the
  /// volume in the block device mapping (for example, `/dev/sdh` or `xvdh`).
  ///
  /// *    `launch.block-device-mapping.snapshot-id` - The ID of the snapshot
  /// for the EBS volume.
  ///
  /// *    `launch.block-device-mapping.volume-size` - The size of the EBS
  /// volume, in GiB.
  ///
  /// *    `launch.block-device-mapping.volume-type` - The type of EBS volume:
  /// `gp2` for General Purpose SSD, `io1` for Provisioned IOPS SSD, `st1` for
  /// Throughput Optimized HDD, `sc1`for Cold HDD, or `standard` for Magnetic.
  ///
  /// *    `launch.group-id` - The ID of the security group for the instance.
  ///
  /// *    `launch.group-name` - The name of the security group for the
  /// instance.
  ///
  /// *    `launch.image-id` - The ID of the AMI.
  ///
  /// *    `launch.instance-type` - The type of instance (for example,
  /// `m3.medium`).
  ///
  /// *    `launch.kernel-id` - The kernel ID.
  ///
  /// *    `launch.key-name` - The name of the key pair the instance launched
  /// with.
  ///
  /// *    `launch.monitoring-enabled` - Whether detailed monitoring is enabled
  /// for the Spot Instance.
  ///
  /// *    `launch.ramdisk-id` - The RAM disk ID.
  ///
  /// *    `launched-availability-zone` - The Availability Zone in which the
  /// request is launched.
  ///
  /// *    `network-interface.addresses.primary` - Indicates whether the IP
  /// address is the primary private IP address.
  ///
  /// *    `network-interface.delete-on-termination` - Indicates whether the
  /// network interface is deleted when the instance is terminated.
  ///
  /// *    `network-interface.description` - A description of the network
  /// interface.
  ///
  /// *    `network-interface.device-index` - The index of the device for the
  /// network interface attachment on the instance.
  ///
  /// *    `network-interface.group-id` - The ID of the security group
  /// associated with the network interface.
  ///
  /// *    `network-interface.network-interface-id` - The ID of the network
  /// interface.
  ///
  /// *    `network-interface.private-ip-address` - The primary private IP
  /// address of the network interface.
  ///
  /// *    `network-interface.subnet-id` - The ID of the subnet for the
  /// instance.
  ///
  /// *    `product-description` - The product description associated with the
  /// instance (`Linux/UNIX` | `Windows`).
  ///
  /// *    `spot-instance-request-id` - The Spot Instance request ID.
  ///
  /// *    `spot-price` - The maximum hourly price for any Spot Instance
  /// launched to fulfill the request.
  ///
  /// *    `state` - The state of the Spot Instance request (`open` | `active` |
  /// `closed` | `cancelled` | `failed`). Spot request status information can
  /// help you track your Amazon EC2 Spot Instance requests. For more
  /// information, see
  /// [Spot Request Status](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html)
  /// in the _Amazon EC2 User Guide for Linux Instances_.
  ///
  /// *    `status-code` - The short code describing the most recent evaluation
  /// of your Spot Instance request.
  ///
  /// *    `status-message` - The message explaining the status of the Spot
  /// Instance request.
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// *    `type` - The type of Spot Instance request (`one-time` |
  /// `persistent`).
  ///
  /// *    `valid-from` - The start date of the request.
  ///
  /// *    `valid-until` - The end date of the request.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [spotInstanceRequestIds]: One or more Spot Instance request IDs.
  ///
  /// [nextToken]: The token to request the next set of results. This value is
  /// `null` when there are no more results to return.
  ///
  /// [maxResults]: The maximum number of results to return in a single call.
  /// Specify a value between 5 and 1000. To retrieve the remaining results,
  /// make another call with the returned `NextToken` value.
  Future<DescribeSpotInstanceRequestsResult> describeSpotInstanceRequests(
      {List<Filter> filters,
      bool dryRun,
      List<String> spotInstanceRequestIds,
      String nextToken,
      int maxResults}) async {
    var response_ = await _client.send('DescribeSpotInstanceRequests', {
      if (filters != null) 'Filters': filters,
      if (dryRun != null) 'DryRun': dryRun,
      if (spotInstanceRequestIds != null)
        'SpotInstanceRequestIds': spotInstanceRequestIds,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
    });
    return DescribeSpotInstanceRequestsResult.fromJson(response_);
  }

  /// Describes the Spot price history. For more information, see
  /// [Spot Instance Pricing History](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-spot-instances-history.html)
  /// in the _Amazon EC2 User Guide for Linux Instances_.
  ///
  /// When you specify a start and end time, this operation returns the prices
  /// of the instance types within the time range that you specified and the
  /// time when the price changed. The price is valid within the time period
  /// that you specified; the response merely indicates the last time that the
  /// price changed.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `availability-zone` - The Availability Zone for which prices should
  /// be returned.
  ///
  /// *    `instance-type` - The type of instance (for example, `m3.medium`).
  ///
  /// *    `product-description` - The product description for the Spot price
  /// (`Linux/UNIX` | `SUSE Linux` | `Windows` | `Linux/UNIX (Amazon VPC)` |
  /// `SUSE Linux (Amazon VPC)` | `Windows (Amazon VPC)`).
  ///
  /// *    `spot-price` - The Spot price. The value must match exactly (or use
  /// wildcards; greater than or less than comparison is not supported).
  ///
  /// *    `timestamp` - The time stamp of the Spot price history, in UTC format
  /// (for example, _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z). You can use wildcards (*
  /// and ?). Greater than or less than comparison is not supported.
  ///
  /// [availabilityZone]: Filters the results by the specified Availability
  /// Zone.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [endTime]: The date and time, up to the current date, from which to stop
  /// retrieving the price history data, in UTC format (for example,
  /// _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z).
  ///
  /// [instanceTypes]: Filters the results by the specified instance types.
  ///
  /// [maxResults]: The maximum number of results to return in a single call.
  /// Specify a value between 1 and 1000. The default value is 1000. To retrieve
  /// the remaining results, make another call with the returned `NextToken`
  /// value.
  ///
  /// [nextToken]: The token for the next set of results.
  ///
  /// [productDescriptions]: Filters the results by the specified basic product
  /// descriptions.
  ///
  /// [startTime]: The date and time, up to the past 90 days, from which to
  /// start retrieving the price history data, in UTC format (for example,
  /// _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z).
  Future<DescribeSpotPriceHistoryResult> describeSpotPriceHistory(
      {List<Filter> filters,
      String availabilityZone,
      bool dryRun,
      DateTime endTime,
      List<String> instanceTypes,
      int maxResults,
      String nextToken,
      List<String> productDescriptions,
      DateTime startTime}) async {
    var response_ = await _client.send('DescribeSpotPriceHistory', {
      if (filters != null) 'Filters': filters,
      if (availabilityZone != null) 'AvailabilityZone': availabilityZone,
      if (dryRun != null) 'DryRun': dryRun,
      if (endTime != null) 'EndTime': endTime,
      if (instanceTypes != null) 'InstanceTypes': instanceTypes,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (productDescriptions != null)
        'ProductDescriptions': productDescriptions,
      if (startTime != null) 'StartTime': startTime,
    });
    return DescribeSpotPriceHistoryResult.fromJson(response_);
  }

  /// [VPC only] Describes the stale security group rules for security groups in
  /// a specified VPC. Rules are stale when they reference a deleted security
  /// group in a peer VPC, or a security group in a peer VPC for which the VPC
  /// peering connection has been deleted.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [maxResults]: The maximum number of items to return for this request. The
  /// request returns a token that you can specify in a subsequent call to get
  /// the next set of results.
  ///
  /// [nextToken]: The token for the next set of items to return. (You received
  /// this token from a prior call.)
  ///
  /// [vpcId]: The ID of the VPC.
  Future<DescribeStaleSecurityGroupsResult> describeStaleSecurityGroups(
      String vpcId,
      {bool dryRun,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeStaleSecurityGroups', {
      if (dryRun != null) 'DryRun': dryRun,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      'VpcId': vpcId,
    });
    return DescribeStaleSecurityGroupsResult.fromJson(response_);
  }

  /// Describes one or more of your subnets.
  ///
  /// For more information, see
  /// [Your VPC and Subnets](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `availability-zone` - The Availability Zone for the subnet. You can
  /// also use `availabilityZone` as the filter name.
  ///
  /// *    `availability-zone-id` - The ID of the Availability Zone for the
  /// subnet. You can also use `availabilityZoneId` as the filter name.
  ///
  /// *    `available-ip-address-count` - The number of IPv4 addresses in the
  /// subnet that are available.
  ///
  /// *    `cidr-block` - The IPv4 CIDR block of the subnet. The CIDR block you
  /// specify must exactly match the subnet's CIDR block for information to be
  /// returned for the subnet. You can also use `cidr` or `cidrBlock` as the
  /// filter names.
  ///
  /// *    `default-for-az` - Indicates whether this is the default subnet for
  /// the Availability Zone. You can also use `defaultForAz` as the filter name.
  ///
  /// *    `ipv6-cidr-block-association.ipv6-cidr-block` - An IPv6 CIDR block
  /// associated with the subnet.
  ///
  /// *    `ipv6-cidr-block-association.association-id` - An association ID for
  /// an IPv6 CIDR block associated with the subnet.
  ///
  /// *    `ipv6-cidr-block-association.state` - The state of an IPv6 CIDR block
  /// associated with the subnet.
  ///
  /// *    `owner-id` - The ID of the AWS account that owns the subnet.
  ///
  /// *    `state` - The state of the subnet (`pending` | `available`).
  ///
  /// *    `subnet-arn` - The Amazon Resource Name (ARN) of the subnet.
  ///
  /// *    `subnet-id` - The ID of the subnet.
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// *    `vpc-id` - The ID of the VPC for the subnet.
  ///
  /// [subnetIds]: One or more subnet IDs.
  ///
  /// Default: Describes all your subnets.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [nextToken]: The token for the next page of results.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  Future<DescribeSubnetsResult> describeSubnets(
      {List<Filter> filters,
      List<String> subnetIds,
      bool dryRun,
      String nextToken,
      int maxResults}) async {
    var response_ = await _client.send('DescribeSubnets', {
      if (filters != null) 'Filters': filters,
      if (subnetIds != null) 'SubnetIds': subnetIds,
      if (dryRun != null) 'DryRun': dryRun,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
    });
    return DescribeSubnetsResult.fromJson(response_);
  }

  /// Describes the specified tags for your EC2 resources.
  ///
  /// For more information about tags, see
  /// [Tagging Your Resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [filters]: The filters.
  ///
  /// *    `key` - The tag key.
  ///
  /// *    `resource-id` - The ID of the resource.
  ///
  /// *    `resource-type` - The resource type (`customer-gateway` |
  /// `dedicated-host` | `dhcp-options` | `elastic-ip` | `fleet` | `fpga-image`
  /// | `image` | `instance` | `host-reservation` | `internet-gateway` |
  /// `launch-template` | `natgateway` | `network-acl` | `network-interface` |
  /// `reserved-instances` | `route-table` | `security-group` | `snapshot` |
  /// `spot-instances-request` | `subnet` | `volume` | `vpc` |
  /// `vpc-peering-connection` | `vpn-connection` | `vpn-gateway`).
  ///
  /// *    `tag`:<key> - The key/value combination of the tag. For example,
  /// specify "tag:Owner" for the filter name and "TeamA" for the filter value
  /// to find resources with the tag "Owner=TeamA".
  ///
  /// *    `value` - The tag value.
  ///
  /// [maxResults]: The maximum number of results to return in a single call.
  /// This value can be between 5 and 1000. To retrieve the remaining results,
  /// make another call with the returned `NextToken` value.
  ///
  /// [nextToken]: The token to retrieve the next page of results.
  Future<DescribeTagsResult> describeTags(
      {bool dryRun,
      List<Filter> filters,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeTags', {
      if (dryRun != null) 'DryRun': dryRun,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeTagsResult.fromJson(response_);
  }

  /// Describes one or more Traffic Mirror filters.
  ///
  /// [trafficMirrorFilterIds]: The ID of the Traffic Mirror filter.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [filters]: One or more filters. The possible values are:
  ///
  /// *    `description`: The Traffic Mirror filter description.
  ///
  /// *    `traffic-mirror-filter-id`: The ID of the Traffic Mirror filter.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  ///
  /// [nextToken]: The token for the next page of results.
  Future<DescribeTrafficMirrorFiltersResult> describeTrafficMirrorFilters(
      {List<String> trafficMirrorFilterIds,
      bool dryRun,
      List<Filter> filters,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeTrafficMirrorFilters', {
      if (trafficMirrorFilterIds != null)
        'TrafficMirrorFilterIds': trafficMirrorFilterIds,
      if (dryRun != null) 'DryRun': dryRun,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeTrafficMirrorFiltersResult.fromJson(response_);
  }

  /// Describes one or more Traffic Mirror sessions. By default, all Traffic
  /// Mirror sessions are described. Alternatively, you can filter the results.
  ///
  /// [trafficMirrorSessionIds]: The ID of the Traffic Mirror session.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [filters]: One or more filters. The possible values are:
  ///
  /// *    `description`: The Traffic Mirror session description.
  ///
  /// *    `network-interface-id`: The ID of the Traffic Mirror session network
  /// interface.
  ///
  /// *    `owner-id`: The ID of the account that owns the Traffic Mirror
  /// session.
  ///
  /// *    `packet-length`: The assigned number of packets to mirror.
  ///
  /// *    `session-number`: The assigned session number.
  ///
  /// *    `traffic-mirror-filter-id`: The ID of the Traffic Mirror filter.
  ///
  /// *    `traffic-mirror-session-id`: The ID of the Traffic Mirror session.
  ///
  /// *    `traffic-mirror-target-id`: The ID of the Traffic Mirror target.
  ///
  /// *    `virtual-network-id`: The virtual network ID of the Traffic Mirror
  /// session.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  ///
  /// [nextToken]: The token for the next page of results.
  Future<DescribeTrafficMirrorSessionsResult> describeTrafficMirrorSessions(
      {List<String> trafficMirrorSessionIds,
      bool dryRun,
      List<Filter> filters,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeTrafficMirrorSessions', {
      if (trafficMirrorSessionIds != null)
        'TrafficMirrorSessionIds': trafficMirrorSessionIds,
      if (dryRun != null) 'DryRun': dryRun,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeTrafficMirrorSessionsResult.fromJson(response_);
  }

  /// Information about one or more Traffic Mirror targets.
  ///
  /// [trafficMirrorTargetIds]: The ID of the Traffic Mirror targets.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [filters]: One or more filters. The possible values are:
  ///
  /// *    `description`: The Traffic Mirror target description.
  ///
  /// *    `network-interface-id`: The ID of the Traffic Mirror session network
  /// interface.
  ///
  /// *    `network-load-balancer-arn`: The Amazon Resource Name (ARN) of the
  /// Network Load Balancer that is associated with the session.
  ///
  /// *    `owner-id`: The ID of the account that owns the Traffic Mirror
  /// session.
  ///
  /// *    `traffic-mirror-target-id`: The ID of the Traffic Mirror target.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  ///
  /// [nextToken]: The token for the next page of results.
  Future<DescribeTrafficMirrorTargetsResult> describeTrafficMirrorTargets(
      {List<String> trafficMirrorTargetIds,
      bool dryRun,
      List<Filter> filters,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeTrafficMirrorTargets', {
      if (trafficMirrorTargetIds != null)
        'TrafficMirrorTargetIds': trafficMirrorTargetIds,
      if (dryRun != null) 'DryRun': dryRun,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeTrafficMirrorTargetsResult.fromJson(response_);
  }

  /// Describes one or more attachments between resources and transit gateways.
  /// By default, all attachments are described. Alternatively, you can filter
  /// the results by attachment ID, attachment state, resource ID, or resource
  /// owner.
  ///
  /// [transitGatewayAttachmentIds]: The IDs of the attachments.
  ///
  /// [filters]: One or more filters. The possible values are:
  ///
  /// *    `association.state` - The state of the association (`associating` |
  /// `associated` | `disassociating`).
  ///
  /// *    `association.transit-gateway-route-table-id` - The ID of the route
  /// table for the transit gateway.
  ///
  /// *    `resource-id` - The ID of the resource.
  ///
  /// *    `resource-owner-id` - The ID of the AWS account that owns the
  /// resource.
  ///
  /// *    `resource-type` - The resource type (`vpc` | `vpn`).
  ///
  /// *    `state` - The state of the attachment (`available` | `deleted` |
  /// `deleting` | `failed` | `modifying` | `pendingAcceptance` | `pending` |
  /// `rollingBack` | `rejected` | `rejecting`).
  ///
  /// *    `transit-gateway-attachment-id` - The ID of the attachment.
  ///
  /// *    `transit-gateway-id` - The ID of the transit gateway.
  ///
  /// *    `transit-gateway-owner-id` - The ID of the AWS account that owns the
  /// transit gateway.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  ///
  /// [nextToken]: The token for the next page of results.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeTransitGatewayAttachmentsResult>
      describeTransitGatewayAttachments(
          {List<String> transitGatewayAttachmentIds,
          List<Filter> filters,
          int maxResults,
          String nextToken,
          bool dryRun}) async {
    var response_ = await _client.send('DescribeTransitGatewayAttachments', {
      if (transitGatewayAttachmentIds != null)
        'TransitGatewayAttachmentIds': transitGatewayAttachmentIds,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeTransitGatewayAttachmentsResult.fromJson(response_);
  }

  /// Describes one or more transit gateway route tables. By default, all
  /// transit gateway route tables are described. Alternatively, you can filter
  /// the results.
  ///
  /// [transitGatewayRouteTableIds]: The IDs of the transit gateway route
  /// tables.
  ///
  /// [filters]: One or more filters. The possible values are:
  ///
  /// *    `default-association-route-table` - Indicates whether this is the
  /// default association route table for the transit gateway (`true` |
  /// `false`).
  ///
  /// *    `default-propagation-route-table` - Indicates whether this is the
  /// default propagation route table for the transit gateway (`true` |
  /// `false`).
  ///
  /// *    `state` - The state of the attachment (`available` | `deleted` |
  /// `deleting` | `failed` | `modifying` | `pendingAcceptance` | `pending` |
  /// `rollingBack` | `rejected` | `rejecting`).
  ///
  /// *    `transit-gateway-id` - The ID of the transit gateway.
  ///
  /// *    `transit-gateway-route-table-id` - The ID of the transit gateway
  /// route table.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  ///
  /// [nextToken]: The token for the next page of results.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeTransitGatewayRouteTablesResult>
      describeTransitGatewayRouteTables(
          {List<String> transitGatewayRouteTableIds,
          List<Filter> filters,
          int maxResults,
          String nextToken,
          bool dryRun}) async {
    var response_ = await _client.send('DescribeTransitGatewayRouteTables', {
      if (transitGatewayRouteTableIds != null)
        'TransitGatewayRouteTableIds': transitGatewayRouteTableIds,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeTransitGatewayRouteTablesResult.fromJson(response_);
  }

  /// Describes one or more VPC attachments. By default, all VPC attachments are
  /// described. Alternatively, you can filter the results.
  ///
  /// [transitGatewayAttachmentIds]: The IDs of the attachments.
  ///
  /// [filters]: One or more filters. The possible values are:
  ///
  /// *    `state` - The state of the attachment (`available` | `deleted` |
  /// `deleting` | `failed` | `modifying` | `pendingAcceptance` | `pending` |
  /// `rollingBack` | `rejected` | `rejecting`).
  ///
  /// *    `transit-gateway-attachment-id` - The ID of the attachment.
  ///
  /// *    `transit-gateway-id` - The ID of the transit gateway.
  ///
  /// *    `vpc-id` - The ID of the VPC.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  ///
  /// [nextToken]: The token for the next page of results.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeTransitGatewayVpcAttachmentsResult>
      describeTransitGatewayVpcAttachments(
          {List<String> transitGatewayAttachmentIds,
          List<Filter> filters,
          int maxResults,
          String nextToken,
          bool dryRun}) async {
    var response_ = await _client.send('DescribeTransitGatewayVpcAttachments', {
      if (transitGatewayAttachmentIds != null)
        'TransitGatewayAttachmentIds': transitGatewayAttachmentIds,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeTransitGatewayVpcAttachmentsResult.fromJson(response_);
  }

  /// Describes one or more transit gateways. By default, all transit gateways
  /// are described. Alternatively, you can filter the results.
  ///
  /// [transitGatewayIds]: The IDs of the transit gateways.
  ///
  /// [filters]: One or more filters. The possible values are:
  ///
  /// *    `options.propagation-default-route-table-id` - The ID of the default
  /// propagation route table.
  ///
  /// *    `options.amazon-side-asn` - The private ASN for the Amazon side of a
  /// BGP session.
  ///
  /// *    `options.association-default-route-table-id` - The ID of the default
  /// association route table.
  ///
  /// *    `options.auto-accept-shared-attachments` - Indicates whether there is
  /// automatic acceptance of attachment requests (`enable` | `disable`).
  ///
  /// *    `options.default-route-table-association` - Indicates whether
  /// resource attachments are automatically associated with the default
  /// association route table (`enable` | `disable`).
  ///
  /// *    `options.default-route-table-propagation` - Indicates whether
  /// resource attachments automatically propagate routes to the default
  /// propagation route table (`enable` | `disable`).
  ///
  /// *    `options.dns-support` - Indicates whether DNS support is enabled
  /// (`enable` | `disable`).
  ///
  /// *    `options.vpn-ecmp-support` - Indicates whether Equal Cost Multipath
  /// Protocol support is enabled (`enable` | `disable`).
  ///
  /// *    `owner-id` - The ID of the AWS account that owns the transit gateway.
  ///
  /// *    `state` - The state of the attachment (`available` | `deleted` |
  /// `deleting` | `failed` | `modifying` | `pendingAcceptance` | `pending` |
  /// `rollingBack` | `rejected` | `rejecting`).
  ///
  /// *    `transit-gateway-id` - The ID of the transit gateway.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  ///
  /// [nextToken]: The token for the next page of results.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeTransitGatewaysResult> describeTransitGateways(
      {List<String> transitGatewayIds,
      List<Filter> filters,
      int maxResults,
      String nextToken,
      bool dryRun}) async {
    var response_ = await _client.send('DescribeTransitGateways', {
      if (transitGatewayIds != null) 'TransitGatewayIds': transitGatewayIds,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeTransitGatewaysResult.fromJson(response_);
  }

  /// Describes the specified attribute of the specified volume. You can specify
  /// only one attribute at a time.
  ///
  /// For more information about EBS volumes, see
  /// [Amazon EBS Volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumes.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [attribute]: The attribute of the volume. This parameter is required.
  ///
  /// [volumeId]: The ID of the volume.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeVolumeAttributeResult> describeVolumeAttribute(
      {@required String attribute,
      @required String volumeId,
      bool dryRun}) async {
    var response_ = await _client.send('DescribeVolumeAttribute', {
      'Attribute': attribute,
      'VolumeId': volumeId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeVolumeAttributeResult.fromJson(response_);
  }

  /// Describes the status of the specified volumes. Volume status provides the
  /// result of the checks performed on your volumes to determine events that
  /// can impair the performance of your volumes. The performance of a volume
  /// can be affected if an issue occurs on the volume's underlying host. If the
  /// volume's underlying host experiences a power outage or system issue, after
  /// the system is restored, there could be data inconsistencies on the volume.
  /// Volume events notify you if this occurs. Volume actions notify you if any
  /// action needs to be taken in response to the event.
  ///
  /// The `DescribeVolumeStatus` operation provides the following information
  /// about the specified volumes:
  ///
  ///  _Status_: Reflects the current status of the volume. The possible values
  /// are `ok`, `impaired` , `warning`, or `insufficient-data`. If all checks
  /// pass, the overall status of the volume is `ok`. If the check fails, the
  /// overall status is `impaired`. If the status is `insufficient-data`, then
  /// the checks may still be taking place on your volume at the time. We
  /// recommend that you retry the request. For more information about volume
  /// status, see
  /// [Monitoring the Status of Your Volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/monitoring-volume-status.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  ///  _Events_: Reflect the cause of a volume status and may require you to
  /// take action. For example, if your volume returns an `impaired` status,
  /// then the volume event might be `potential-data-inconsistency`. This means
  /// that your volume has been affected by an issue with the underlying host,
  /// has all I/O operations disabled, and may have inconsistent data.
  ///
  ///  _Actions_: Reflect the actions you may have to take in response to an
  /// event. For example, if the status of the volume is `impaired` and the
  /// volume event shows `potential-data-inconsistency`, then the action shows
  /// `enable-volume-io`. This means that you may want to enable the I/O
  /// operations for the volume by calling the EnableVolumeIO action and then
  /// check the volume for data consistency.
  ///
  /// Volume status is based on the volume status checks, and does not reflect
  /// the volume state. Therefore, volume status does not indicate volumes in
  /// the `error` state (for example, when a volume is incapable of accepting
  /// I/O.)
  ///
  /// [filters]: The filters.
  ///
  /// *    `action.code` - The action code for the event (for example,
  /// `enable-volume-io`).
  ///
  /// *    `action.description` - A description of the action.
  ///
  /// *    `action.event-id` - The event ID associated with the action.
  ///
  /// *    `availability-zone` - The Availability Zone of the instance.
  ///
  /// *    `event.description` - A description of the event.
  ///
  /// *    `event.event-id` - The event ID.
  ///
  /// *    `event.event-type` - The event type (for `io-enabled`: `passed` |
  /// `failed`; for `io-performance`: `io-performance:degraded` |
  /// `io-performance:severely-degraded` | `io-performance:stalled`).
  ///
  /// *    `event.not-after` - The latest end time for the event.
  ///
  /// *    `event.not-before` - The earliest start time for the event.
  ///
  /// *    `volume-status.details-name` - The cause for `volume-status.status`
  /// (`io-enabled` | `io-performance`).
  ///
  /// *    `volume-status.details-status` - The status of
  /// `volume-status.details-name` (for `io-enabled`: `passed` | `failed`; for
  /// `io-performance`: `normal` | `degraded` | `severely-degraded` |
  /// `stalled`).
  ///
  /// *    `volume-status.status` - The status of the volume (`ok` | `impaired`
  /// | `warning` | `insufficient-data`).
  ///
  /// [maxResults]: The maximum number of volume results returned by
  /// `DescribeVolumeStatus` in paginated output. When this parameter is used,
  /// the request only returns `MaxResults` results in a single page along with
  /// a `NextToken` response element. The remaining results of the initial
  /// request can be seen by sending another request with the returned
  /// `NextToken` value. This value can be between 5 and 1000; if `MaxResults`
  /// is given a value larger than 1000, only 1000 results are returned. If this
  /// parameter is not used, then `DescribeVolumeStatus` returns all results.
  /// You cannot specify this parameter and the volume IDs parameter in the same
  /// request.
  ///
  /// [nextToken]: The `NextToken` value to include in a future
  /// `DescribeVolumeStatus` request. When the results of the request exceed
  /// `MaxResults`, this value can be used to retrieve the next page of results.
  /// This value is `null` when there are no more results to return.
  ///
  /// [volumeIds]: The IDs of the volumes.
  ///
  /// Default: Describes all your volumes.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeVolumeStatusResult> describeVolumeStatus(
      {List<Filter> filters,
      int maxResults,
      String nextToken,
      List<String> volumeIds,
      bool dryRun}) async {
    var response_ = await _client.send('DescribeVolumeStatus', {
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (volumeIds != null) 'VolumeIds': volumeIds,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeVolumeStatusResult.fromJson(response_);
  }

  /// Describes the specified EBS volumes or all of your EBS volumes.
  ///
  /// If you are describing a long list of volumes, you can paginate the output
  /// to make the list more manageable. The `MaxResults` parameter sets the
  /// maximum number of results returned in a single page. If the list of
  /// results exceeds your `MaxResults` value, then that number of results is
  /// returned along with a `NextToken` value that can be passed to a subsequent
  /// `DescribeVolumes` request to retrieve the remaining results.
  ///
  /// For more information about EBS volumes, see
  /// [Amazon EBS Volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumes.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [filters]: The filters.
  ///
  /// *    `attachment.attach-time` - The time stamp when the attachment
  /// initiated.
  ///
  /// *    `attachment.delete-on-termination` - Whether the volume is deleted on
  /// instance termination.
  ///
  /// *    `attachment.device` - The device name specified in the block device
  /// mapping (for example, `/dev/sda1`).
  ///
  /// *    `attachment.instance-id` - The ID of the instance the volume is
  /// attached to.
  ///
  /// *    `attachment.status` - The attachment state (`attaching` | `attached`
  /// | `detaching`).
  ///
  /// *    `availability-zone` - The Availability Zone in which the volume was
  /// created.
  ///
  /// *    `create-time` - The time stamp when the volume was created.
  ///
  /// *    `encrypted` - Indicates whether the volume is encrypted (`true` |
  /// `false`)
  ///
  /// *    `size` - The size of the volume, in GiB.
  ///
  /// *    `snapshot-id` - The snapshot from which the volume was created.
  ///
  /// *    `status` - The status of the volume (`creating` | `available` |
  /// `in-use` | `deleting` | `deleted` | `error`).
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// *    `volume-id` - The volume ID.
  ///
  /// *    `volume-type` - The Amazon EBS volume type. This can be `gp2` for
  /// General Purpose SSD, `io1` for Provisioned IOPS SSD, `st1` for Throughput
  /// Optimized HDD, `sc1` for Cold HDD, or `standard` for Magnetic volumes.
  ///
  /// [volumeIds]: The volume IDs.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [maxResults]: The maximum number of volume results returned by
  /// `DescribeVolumes` in paginated output. When this parameter is used,
  /// `DescribeVolumes` only returns `MaxResults` results in a single page along
  /// with a `NextToken` response element. The remaining results of the initial
  /// request can be seen by sending another `DescribeVolumes` request with the
  /// returned `NextToken` value. This value can be between 5 and 500; if
  /// `MaxResults` is given a value larger than 500, only 500 results are
  /// returned. If this parameter is not used, then `DescribeVolumes` returns
  /// all results. You cannot specify this parameter and the volume IDs
  /// parameter in the same request.
  ///
  /// [nextToken]: The `NextToken` value returned from a previous paginated
  /// `DescribeVolumes` request where `MaxResults` was used and the results
  /// exceeded the value of that parameter. Pagination continues from the end of
  /// the previous results that returned the `NextToken` value. This value is
  /// `null` when there are no more results to return.
  Future<DescribeVolumesResult> describeVolumes(
      {List<Filter> filters,
      List<String> volumeIds,
      bool dryRun,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeVolumes', {
      if (filters != null) 'Filters': filters,
      if (volumeIds != null) 'VolumeIds': volumeIds,
      if (dryRun != null) 'DryRun': dryRun,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeVolumesResult.fromJson(response_);
  }

  /// Reports the current modification status of EBS volumes.
  ///
  /// Current-generation EBS volumes support modification of attributes
  /// including type, size, and (for `io1` volumes) IOPS provisioning while
  /// either attached to or detached from an instance. Following an action from
  /// the API or the console to modify a volume, the status of the modification
  /// may be `modifying`, `optimizing`, `completed`, or `failed`. If a volume
  /// has never been modified, then certain elements of the returned
  /// `VolumeModification` objects are null.
  ///
  ///  You can also use CloudWatch Events to check the status of a modification
  /// to an EBS volume. For information about CloudWatch Events, see the
  /// [Amazon CloudWatch Events User Guide](https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/).
  /// For more information, see
  /// [Monitoring Volume Modifications"](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-expand-volume.html#monitoring_mods)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [volumeIds]: The IDs of the volumes for which in-progress modifications
  /// will be described.
  ///
  /// [filters]: The filters. Supported filters: `volume-id`,
  /// `modification-state`, `target-size`, `target-iops`, `target-volume-type`,
  /// `original-size`, `original-iops`, `original-volume-type`, `start-time`.
  ///
  /// [nextToken]: The `nextToken` value returned by a previous paginated
  /// request.
  ///
  /// [maxResults]: The maximum number of results (up to a limit of 500) to be
  /// returned in a paginated request.
  Future<DescribeVolumesModificationsResult> describeVolumesModifications(
      {bool dryRun,
      List<String> volumeIds,
      List<Filter> filters,
      String nextToken,
      int maxResults}) async {
    var response_ = await _client.send('DescribeVolumesModifications', {
      if (dryRun != null) 'DryRun': dryRun,
      if (volumeIds != null) 'VolumeIds': volumeIds,
      if (filters != null) 'Filters': filters,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
    });
    return DescribeVolumesModificationsResult.fromJson(response_);
  }

  /// Describes the specified attribute of the specified VPC. You can specify
  /// only one attribute at a time.
  ///
  /// [attribute]: The VPC attribute.
  ///
  /// [vpcId]: The ID of the VPC.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeVpcAttributeResult> describeVpcAttribute(
      {@required String attribute, @required String vpcId, bool dryRun}) async {
    var response_ = await _client.send('DescribeVpcAttribute', {
      'Attribute': attribute,
      'VpcId': vpcId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeVpcAttributeResult.fromJson(response_);
  }

  /// Describes the ClassicLink status of one or more VPCs.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `is-classic-link-enabled` - Whether the VPC is enabled for
  /// ClassicLink (`true` | `false`).
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [vpcIds]: One or more VPCs for which you want to describe the ClassicLink
  /// status.
  Future<DescribeVpcClassicLinkResult> describeVpcClassicLink(
      {List<Filter> filters, bool dryRun, List<String> vpcIds}) async {
    var response_ = await _client.send('DescribeVpcClassicLink', {
      if (filters != null) 'Filters': filters,
      if (dryRun != null) 'DryRun': dryRun,
      if (vpcIds != null) 'VpcIds': vpcIds,
    });
    return DescribeVpcClassicLinkResult.fromJson(response_);
  }

  /// Describes the ClassicLink DNS support status of one or more VPCs. If
  /// enabled, the DNS hostname of a linked EC2-Classic instance resolves to its
  /// private IP address when addressed from an instance in the VPC to which
  /// it's linked. Similarly, the DNS hostname of an instance in a VPC resolves
  /// to its private IP address when addressed from a linked EC2-Classic
  /// instance. For more information, see
  /// [ClassicLink](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  ///
  /// [nextToken]: The token for the next page of results.
  ///
  /// [vpcIds]: One or more VPC IDs.
  Future<DescribeVpcClassicLinkDnsSupportResult>
      describeVpcClassicLinkDnsSupport(
          {int maxResults, String nextToken, List<String> vpcIds}) async {
    var response_ = await _client.send('DescribeVpcClassicLinkDnsSupport', {
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (vpcIds != null) 'VpcIds': vpcIds,
    });
    return DescribeVpcClassicLinkDnsSupportResult.fromJson(response_);
  }

  /// Describes the connection notifications for VPC endpoints and VPC endpoint
  /// services.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [connectionNotificationId]: The ID of the notification.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `connection-notification-arn` - The ARN of SNS topic for the
  /// notification.
  ///
  /// *    `connection-notification-id` - The ID of the notification.
  ///
  /// *    `connection-notification-state` - The state of the notification
  /// (`Enabled` | `Disabled`).
  ///
  /// *    `connection-notification-type` - The type of notification (`Topic`).
  ///
  /// *    `service-id` - The ID of the endpoint service.
  ///
  /// *    `vpc-endpoint-id` - The ID of the VPC endpoint.
  ///
  /// [maxResults]: The maximum number of results to return in a single call. To
  /// retrieve the remaining results, make another request with the returned
  /// `NextToken` value.
  ///
  /// [nextToken]: The token to request the next page of results.
  Future<DescribeVpcEndpointConnectionNotificationsResult>
      describeVpcEndpointConnectionNotifications(
          {bool dryRun,
          String connectionNotificationId,
          List<Filter> filters,
          int maxResults,
          String nextToken}) async {
    var response_ =
        await _client.send('DescribeVpcEndpointConnectionNotifications', {
      if (dryRun != null) 'DryRun': dryRun,
      if (connectionNotificationId != null)
        'ConnectionNotificationId': connectionNotificationId,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeVpcEndpointConnectionNotificationsResult.fromJson(response_);
  }

  /// Describes the VPC endpoint connections to your VPC endpoint services,
  /// including any endpoints that are pending your acceptance.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `service-id` - The ID of the service.
  ///
  /// *    `vpc-endpoint-owner` - The AWS account number of the owner of the
  /// endpoint.
  ///
  /// *    `vpc-endpoint-state` - The state of the endpoint (`pendingAcceptance`
  /// | `pending` | `available` | `deleting` | `deleted` | `rejected` |
  /// `failed`).
  ///
  /// *    `vpc-endpoint-id` - The ID of the endpoint.
  ///
  /// [maxResults]: The maximum number of results to return for the request in a
  /// single page. The remaining results of the initial request can be seen by
  /// sending another request with the returned `NextToken` value. This value
  /// can be between 5 and 1000; if `MaxResults` is given a value larger than
  /// 1000, only 1000 results are returned.
  ///
  /// [nextToken]: The token to retrieve the next page of results.
  Future<DescribeVpcEndpointConnectionsResult> describeVpcEndpointConnections(
      {bool dryRun,
      List<Filter> filters,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeVpcEndpointConnections', {
      if (dryRun != null) 'DryRun': dryRun,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeVpcEndpointConnectionsResult.fromJson(response_);
  }

  /// Describes the VPC endpoint service configurations in your account (your
  /// services).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [serviceIds]: The IDs of one or more services.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `service-name` - The name of the service.
  ///
  /// *    `service-id` - The ID of the service.
  ///
  /// *    `service-state` - The state of the service (`Pending` | `Available` |
  /// `Deleting` | `Deleted` | `Failed`).
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// [maxResults]: The maximum number of results to return for the request in a
  /// single page. The remaining results of the initial request can be seen by
  /// sending another request with the returned `NextToken` value. This value
  /// can be between 5 and 1000; if `MaxResults` is given a value larger than
  /// 1000, only 1000 results are returned.
  ///
  /// [nextToken]: The token to retrieve the next page of results.
  Future<DescribeVpcEndpointServiceConfigurationsResult>
      describeVpcEndpointServiceConfigurations(
          {bool dryRun,
          List<String> serviceIds,
          List<Filter> filters,
          int maxResults,
          String nextToken}) async {
    var response_ =
        await _client.send('DescribeVpcEndpointServiceConfigurations', {
      if (dryRun != null) 'DryRun': dryRun,
      if (serviceIds != null) 'ServiceIds': serviceIds,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeVpcEndpointServiceConfigurationsResult.fromJson(response_);
  }

  /// Describes the principals (service consumers) that are permitted to
  /// discover your VPC endpoint service.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [serviceId]: The ID of the service.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `principal` - The ARN of the principal.
  ///
  /// *    `principal-type` - The principal type (`All` | `Service` |
  /// `OrganizationUnit` | `Account` | `User` | `Role`).
  ///
  /// [maxResults]: The maximum number of results to return for the request in a
  /// single page. The remaining results of the initial request can be seen by
  /// sending another request with the returned `NextToken` value. This value
  /// can be between 5 and 1000; if `MaxResults` is given a value larger than
  /// 1000, only 1000 results are returned.
  ///
  /// [nextToken]: The token to retrieve the next page of results.
  Future<DescribeVpcEndpointServicePermissionsResult>
      describeVpcEndpointServicePermissions(String serviceId,
          {bool dryRun,
          List<Filter> filters,
          int maxResults,
          String nextToken}) async {
    var response_ =
        await _client.send('DescribeVpcEndpointServicePermissions', {
      if (dryRun != null) 'DryRun': dryRun,
      'ServiceId': serviceId,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeVpcEndpointServicePermissionsResult.fromJson(response_);
  }

  /// Describes available services to which you can create a VPC endpoint.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [serviceNames]: One or more service names.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `service-name`: The name of the service.
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// [maxResults]: The maximum number of items to return for this request. The
  /// request returns a token that you can specify in a subsequent call to get
  /// the next set of results.
  ///
  /// Constraint: If the value is greater than 1000, we return only 1000 items.
  ///
  /// [nextToken]: The token for the next set of items to return. (You received
  /// this token from a prior call.)
  Future<DescribeVpcEndpointServicesResult> describeVpcEndpointServices(
      {bool dryRun,
      List<String> serviceNames,
      List<Filter> filters,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeVpcEndpointServices', {
      if (dryRun != null) 'DryRun': dryRun,
      if (serviceNames != null) 'ServiceNames': serviceNames,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeVpcEndpointServicesResult.fromJson(response_);
  }

  /// Describes one or more of your VPC endpoints.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [vpcEndpointIds]: One or more endpoint IDs.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `service-name`: The name of the service.
  ///
  /// *    `vpc-id`: The ID of the VPC in which the endpoint resides.
  ///
  /// *    `vpc-endpoint-id`: The ID of the endpoint.
  ///
  /// *    `vpc-endpoint-state` - The state of the endpoint (`pendingAcceptance`
  /// | `pending` | `available` | `deleting` | `deleted` | `rejected` |
  /// `failed`).
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// [maxResults]: The maximum number of items to return for this request. The
  /// request returns a token that you can specify in a subsequent call to get
  /// the next set of results.
  ///
  /// Constraint: If the value is greater than 1000, we return only 1000 items.
  ///
  /// [nextToken]: The token for the next set of items to return. (You received
  /// this token from a prior call.)
  Future<DescribeVpcEndpointsResult> describeVpcEndpoints(
      {bool dryRun,
      List<String> vpcEndpointIds,
      List<Filter> filters,
      int maxResults,
      String nextToken}) async {
    var response_ = await _client.send('DescribeVpcEndpoints', {
      if (dryRun != null) 'DryRun': dryRun,
      if (vpcEndpointIds != null) 'VpcEndpointIds': vpcEndpointIds,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    });
    return DescribeVpcEndpointsResult.fromJson(response_);
  }

  /// Describes one or more of your VPC peering connections.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `accepter-vpc-info.cidr-block` - The IPv4 CIDR block of the accepter
  /// VPC.
  ///
  /// *    `accepter-vpc-info.owner-id` - The AWS account ID of the owner of the
  /// accepter VPC.
  ///
  /// *    `accepter-vpc-info.vpc-id` - The ID of the accepter VPC.
  ///
  /// *    `expiration-time` - The expiration date and time for the VPC peering
  /// connection.
  ///
  /// *    `requester-vpc-info.cidr-block` - The IPv4 CIDR block of the
  /// requester's VPC.
  ///
  /// *    `requester-vpc-info.owner-id` - The AWS account ID of the owner of
  /// the requester VPC.
  ///
  /// *    `requester-vpc-info.vpc-id` - The ID of the requester VPC.
  ///
  /// *    `status-code` - The status of the VPC peering connection
  /// (`pending-acceptance` | `failed` | `expired` | `provisioning` | `active` |
  /// `deleting` | `deleted` | `rejected`).
  ///
  /// *    `status-message` - A message that provides more information about the
  /// status of the VPC peering connection, if applicable.
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// *    `vpc-peering-connection-id` - The ID of the VPC peering connection.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [vpcPeeringConnectionIds]: One or more VPC peering connection IDs.
  ///
  /// Default: Describes all your VPC peering connections.
  ///
  /// [nextToken]: The token for the next page of results.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  Future<DescribeVpcPeeringConnectionsResult> describeVpcPeeringConnections(
      {List<Filter> filters,
      bool dryRun,
      List<String> vpcPeeringConnectionIds,
      String nextToken,
      int maxResults}) async {
    var response_ = await _client.send('DescribeVpcPeeringConnections', {
      if (filters != null) 'Filters': filters,
      if (dryRun != null) 'DryRun': dryRun,
      if (vpcPeeringConnectionIds != null)
        'VpcPeeringConnectionIds': vpcPeeringConnectionIds,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
    });
    return DescribeVpcPeeringConnectionsResult.fromJson(response_);
  }

  /// Describes one or more of your VPCs.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `cidr` - The primary IPv4 CIDR block of the VPC. The CIDR block you
  /// specify must exactly match the VPC's CIDR block for information to be
  /// returned for the VPC. Must contain the slash followed by one or two digits
  /// (for example, `/28`).
  ///
  /// *    `cidr-block-association.cidr-block` - An IPv4 CIDR block associated
  /// with the VPC.
  ///
  /// *    `cidr-block-association.association-id` - The association ID for an
  /// IPv4 CIDR block associated with the VPC.
  ///
  /// *    `cidr-block-association.state` - The state of an IPv4 CIDR block
  /// associated with the VPC.
  ///
  /// *    `dhcp-options-id` - The ID of a set of DHCP options.
  ///
  /// *    `ipv6-cidr-block-association.ipv6-cidr-block` - An IPv6 CIDR block
  /// associated with the VPC.
  ///
  /// *    `ipv6-cidr-block-association.association-id` - The association ID for
  /// an IPv6 CIDR block associated with the VPC.
  ///
  /// *    `ipv6-cidr-block-association.state` - The state of an IPv6 CIDR block
  /// associated with the VPC.
  ///
  /// *    `isDefault` - Indicates whether the VPC is the default VPC.
  ///
  /// *    `owner-id` - The ID of the AWS account that owns the VPC.
  ///
  /// *    `state` - The state of the VPC (`pending` | `available`).
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// *    `vpc-id` - The ID of the VPC.
  ///
  /// [vpcIds]: One or more VPC IDs.
  ///
  /// Default: Describes all your VPCs.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [nextToken]: The token for the next page of results.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  Future<DescribeVpcsResult> describeVpcs(
      {List<Filter> filters,
      List<String> vpcIds,
      bool dryRun,
      String nextToken,
      int maxResults}) async {
    var response_ = await _client.send('DescribeVpcs', {
      if (filters != null) 'Filters': filters,
      if (vpcIds != null) 'VpcIds': vpcIds,
      if (dryRun != null) 'DryRun': dryRun,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
    });
    return DescribeVpcsResult.fromJson(response_);
  }

  /// Describes one or more of your VPN connections.
  ///
  /// For more information, see
  /// [AWS Site-to-Site VPN](https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html)
  /// in the _AWS Site-to-Site VPN User Guide_.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `customer-gateway-configuration` - The configuration information for
  /// the customer gateway.
  ///
  /// *    `customer-gateway-id` - The ID of a customer gateway associated with
  /// the VPN connection.
  ///
  /// *    `state` - The state of the VPN connection (`pending` | `available` |
  /// `deleting` | `deleted`).
  ///
  /// *    `option.static-routes-only` - Indicates whether the connection has
  /// static routes only. Used for devices that do not support Border Gateway
  /// Protocol (BGP).
  ///
  /// *    `route.destination-cidr-block` - The destination CIDR block. This
  /// corresponds to the subnet used in a customer data center.
  ///
  /// *    `bgp-asn` - The BGP Autonomous System Number (ASN) associated with a
  /// BGP device.
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// *    `type` - The type of VPN connection. Currently the only supported
  /// type is `ipsec.1`.
  ///
  /// *    `vpn-connection-id` - The ID of the VPN connection.
  ///
  /// *    `vpn-gateway-id` - The ID of a virtual private gateway associated
  /// with the VPN connection.
  ///
  /// [vpnConnectionIds]: One or more VPN connection IDs.
  ///
  /// Default: Describes your VPN connections.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeVpnConnectionsResult> describeVpnConnections(
      {List<Filter> filters,
      List<String> vpnConnectionIds,
      bool dryRun}) async {
    var response_ = await _client.send('DescribeVpnConnections', {
      if (filters != null) 'Filters': filters,
      if (vpnConnectionIds != null) 'VpnConnectionIds': vpnConnectionIds,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeVpnConnectionsResult.fromJson(response_);
  }

  /// Describes one or more of your virtual private gateways.
  ///
  /// For more information, see
  /// [AWS Site-to-Site VPN](https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html)
  /// in the _AWS Site-to-Site VPN User Guide_.
  ///
  /// [filters]: One or more filters.
  ///
  /// *    `amazon-side-asn` - The Autonomous System Number (ASN) for the Amazon
  /// side of the gateway.
  ///
  /// *    `attachment.state` - The current state of the attachment between the
  /// gateway and the VPC (`attaching` | `attached` | `detaching` | `detached`).
  ///
  /// *    `attachment.vpc-id` - The ID of an attached VPC.
  ///
  /// *    `availability-zone` - The Availability Zone for the virtual private
  /// gateway (if applicable).
  ///
  /// *    `state` - The state of the virtual private gateway (`pending` |
  /// `available` | `deleting` | `deleted`).
  ///
  /// *    `tag`:<key> - The key/value combination of a tag assigned to the
  /// resource. Use the tag key in the filter name and the tag value as the
  /// filter value. For example, to find all resources that have a tag with the
  /// key `Owner` and the value `TeamA`, specify `tag:Owner` for the filter name
  /// and `TeamA` for the filter value.
  ///
  /// *    `tag-key` - The key of a tag assigned to the resource. Use this
  /// filter to find all resources assigned a tag with a specific key,
  /// regardless of the tag value.
  ///
  /// *    `type` - The type of virtual private gateway. Currently the only
  /// supported type is `ipsec.1`.
  ///
  /// *    `vpn-gateway-id` - The ID of the virtual private gateway.
  ///
  /// [vpnGatewayIds]: One or more virtual private gateway IDs.
  ///
  /// Default: Describes all your virtual private gateways.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DescribeVpnGatewaysResult> describeVpnGateways(
      {List<Filter> filters, List<String> vpnGatewayIds, bool dryRun}) async {
    var response_ = await _client.send('DescribeVpnGateways', {
      if (filters != null) 'Filters': filters,
      if (vpnGatewayIds != null) 'VpnGatewayIds': vpnGatewayIds,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DescribeVpnGatewaysResult.fromJson(response_);
  }

  /// Unlinks (detaches) a linked EC2-Classic instance from a VPC. After the
  /// instance has been unlinked, the VPC security groups are no longer
  /// associated with it. An instance is automatically unlinked from a VPC when
  /// it's stopped.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [instanceId]: The ID of the instance to unlink from the VPC.
  ///
  /// [vpcId]: The ID of the VPC to which the instance is linked.
  Future<DetachClassicLinkVpcResult> detachClassicLinkVpc(
      {bool dryRun,
      @required String instanceId,
      @required String vpcId}) async {
    var response_ = await _client.send('DetachClassicLinkVpc', {
      if (dryRun != null) 'DryRun': dryRun,
      'InstanceId': instanceId,
      'VpcId': vpcId,
    });
    return DetachClassicLinkVpcResult.fromJson(response_);
  }

  /// Detaches an internet gateway from a VPC, disabling connectivity between
  /// the internet and the VPC. The VPC must not contain any running instances
  /// with Elastic IP addresses or public IPv4 addresses.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [internetGatewayId]: The ID of the internet gateway.
  ///
  /// [vpcId]: The ID of the VPC.
  Future<void> detachInternetGateway(
      {bool dryRun,
      @required String internetGatewayId,
      @required String vpcId}) async {
    await _client.send('DetachInternetGateway', {
      if (dryRun != null) 'DryRun': dryRun,
      'InternetGatewayId': internetGatewayId,
      'VpcId': vpcId,
    });
  }

  /// Detaches a network interface from an instance.
  ///
  /// [attachmentId]: The ID of the attachment.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [force]: Specifies whether to force a detachment.
  ///
  ///
  ///
  /// *   Use the `Force` parameter only as a last resort to detach a network
  /// interface from a failed instance.
  ///
  /// *   If you use the `Force` parameter to detach a network interface, you
  /// might not be able to attach a different network interface to the same
  /// index on the instance without first stopping and starting the instance.
  ///
  /// *   If you force the detachment of a network interface, the
  /// [instance metadata](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html)
  /// might not get updated. This means that the attributes associated with the
  /// detached network interface might still be visible. The instance metadata
  /// will get updated when you stop and start the instance.
  Future<void> detachNetworkInterface(String attachmentId,
      {bool dryRun, bool force}) async {
    await _client.send('DetachNetworkInterface', {
      'AttachmentId': attachmentId,
      if (dryRun != null) 'DryRun': dryRun,
      if (force != null) 'Force': force,
    });
  }

  /// Detaches an EBS volume from an instance. Make sure to unmount any file
  /// systems on the device within your operating system before detaching the
  /// volume. Failure to do so can result in the volume becoming stuck in the
  /// `busy` state while detaching. If this happens, detachment can be delayed
  /// indefinitely until you unmount the volume, force detachment, reboot the
  /// instance, or all three. If an EBS volume is the root device of an
  /// instance, it can't be detached while the instance is running. To detach
  /// the root volume, stop the instance first.
  ///
  /// When a volume with an AWS Marketplace product code is detached from an
  /// instance, the product code is no longer associated with the instance.
  ///
  /// For more information, see
  /// [Detaching an Amazon EBS Volume](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-detaching-volume.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [device]: The device name.
  ///
  /// [force]: Forces detachment if the previous detachment attempt did not
  /// occur cleanly (for example, logging into an instance, unmounting the
  /// volume, and detaching normally). This option can lead to data loss or a
  /// corrupted file system. Use this option only as a last resort to detach a
  /// volume from a failed instance. The instance won't have an opportunity to
  /// flush file system caches or file system metadata. If you use this option,
  /// you must perform file system check and repair procedures.
  ///
  /// [instanceId]: The ID of the instance.
  ///
  /// [volumeId]: The ID of the volume.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<VolumeAttachment> detachVolume(String volumeId,
      {String device, bool force, String instanceId, bool dryRun}) async {
    var response_ = await _client.send('DetachVolume', {
      if (device != null) 'Device': device,
      if (force != null) 'Force': force,
      if (instanceId != null) 'InstanceId': instanceId,
      'VolumeId': volumeId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return VolumeAttachment.fromJson(response_);
  }

  /// Detaches a virtual private gateway from a VPC. You do this if you're
  /// planning to turn off the VPC and not use it anymore. You can confirm a
  /// virtual private gateway has been completely detached from a VPC by
  /// describing the virtual private gateway (any attachments to the virtual
  /// private gateway are also described).
  ///
  /// You must wait for the attachment's state to switch to `detached` before
  /// you can delete the VPC or attach a different VPC to the virtual private
  /// gateway.
  ///
  /// [vpcId]: The ID of the VPC.
  ///
  /// [vpnGatewayId]: The ID of the virtual private gateway.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> detachVpnGateway(
      {@required String vpcId,
      @required String vpnGatewayId,
      bool dryRun}) async {
    await _client.send('DetachVpnGateway', {
      'VpcId': vpcId,
      'VpnGatewayId': vpnGatewayId,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Disables EBS encryption by default for your account in the current Region.
  ///
  /// After you disable encryption by default, you can still create encrypted
  /// volumes by enabling encryption when you create each volume.
  ///
  /// Disabling encryption by default does not change the encryption status of
  /// your existing volumes.
  ///
  /// For more information, see
  /// [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DisableEbsEncryptionByDefaultResult> disableEbsEncryptionByDefault(
      {bool dryRun}) async {
    var response_ = await _client.send('DisableEbsEncryptionByDefault', {
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DisableEbsEncryptionByDefaultResult.fromJson(response_);
  }

  /// Disables the specified resource attachment from propagating routes to the
  /// specified propagation route table.
  ///
  /// [transitGatewayRouteTableId]: The ID of the propagation route table.
  ///
  /// [transitGatewayAttachmentId]: The ID of the attachment.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DisableTransitGatewayRouteTablePropagationResult>
      disableTransitGatewayRouteTablePropagation(
          {@required String transitGatewayRouteTableId,
          @required String transitGatewayAttachmentId,
          bool dryRun}) async {
    var response_ =
        await _client.send('DisableTransitGatewayRouteTablePropagation', {
      'TransitGatewayRouteTableId': transitGatewayRouteTableId,
      'TransitGatewayAttachmentId': transitGatewayAttachmentId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DisableTransitGatewayRouteTablePropagationResult.fromJson(response_);
  }

  /// Disables a virtual private gateway (VGW) from propagating routes to a
  /// specified route table of a VPC.
  ///
  /// [gatewayId]: The ID of the virtual private gateway.
  ///
  /// [routeTableId]: The ID of the route table.
  Future<void> disableVgwRoutePropagation(
      {@required String gatewayId, @required String routeTableId}) async {
    await _client.send('DisableVgwRoutePropagation', {
      'GatewayId': gatewayId,
      'RouteTableId': routeTableId,
    });
  }

  /// Disables ClassicLink for a VPC. You cannot disable ClassicLink for a VPC
  /// that has EC2-Classic instances linked to it.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [vpcId]: The ID of the VPC.
  Future<DisableVpcClassicLinkResult> disableVpcClassicLink(String vpcId,
      {bool dryRun}) async {
    var response_ = await _client.send('DisableVpcClassicLink', {
      if (dryRun != null) 'DryRun': dryRun,
      'VpcId': vpcId,
    });
    return DisableVpcClassicLinkResult.fromJson(response_);
  }

  /// Disables ClassicLink DNS support for a VPC. If disabled, DNS hostnames
  /// resolve to public IP addresses when addressed between a linked EC2-Classic
  /// instance and instances in the VPC to which it's linked. For more
  /// information, see
  /// [ClassicLink](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [vpcId]: The ID of the VPC.
  Future<DisableVpcClassicLinkDnsSupportResult> disableVpcClassicLinkDnsSupport(
      {String vpcId}) async {
    var response_ = await _client.send('DisableVpcClassicLinkDnsSupport', {
      if (vpcId != null) 'VpcId': vpcId,
    });
    return DisableVpcClassicLinkDnsSupportResult.fromJson(response_);
  }

  /// Disassociates an Elastic IP address from the instance or network interface
  /// it's associated with.
  ///
  /// An Elastic IP address is for use in either the EC2-Classic platform or in
  /// a VPC. For more information, see
  /// [Elastic IP Addresses](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// This is an idempotent operation. If you perform the operation more than
  /// once, Amazon EC2 doesn't return an error.
  ///
  /// [associationId]: [EC2-VPC] The association ID. Required for EC2-VPC.
  ///
  /// [publicIp]: [EC2-Classic] The Elastic IP address. Required for
  /// EC2-Classic.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> disassociateAddress(
      {String associationId, String publicIp, bool dryRun}) async {
    await _client.send('DisassociateAddress', {
      if (associationId != null) 'AssociationId': associationId,
      if (publicIp != null) 'PublicIp': publicIp,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Disassociates a target network from the specified Client VPN endpoint.
  /// When you disassociate the last target network from a Client VPN, the
  /// following happens:
  ///
  /// *   The route that was automatically added for the VPC is deleted
  ///
  /// *   All active client connections are terminated
  ///
  /// *   New client connections are disallowed
  ///
  /// *   The Client VPN endpoint's status changes to `pending-associate`
  ///
  /// [clientVpnEndpointId]: The ID of the Client VPN endpoint from which to
  /// disassociate the target network.
  ///
  /// [associationId]: The ID of the target network association.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DisassociateClientVpnTargetNetworkResult>
      disassociateClientVpnTargetNetwork(
          {@required String clientVpnEndpointId,
          @required String associationId,
          bool dryRun}) async {
    var response_ = await _client.send('DisassociateClientVpnTargetNetwork', {
      'ClientVpnEndpointId': clientVpnEndpointId,
      'AssociationId': associationId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DisassociateClientVpnTargetNetworkResult.fromJson(response_);
  }

  /// Disassociates an IAM instance profile from a running or stopped instance.
  ///
  /// Use DescribeIamInstanceProfileAssociations to get the association ID.
  ///
  /// [associationId]: The ID of the IAM instance profile association.
  Future<DisassociateIamInstanceProfileResult> disassociateIamInstanceProfile(
      String associationId) async {
    var response_ = await _client.send('DisassociateIamInstanceProfile', {
      'AssociationId': associationId,
    });
    return DisassociateIamInstanceProfileResult.fromJson(response_);
  }

  /// Disassociates a subnet from a route table.
  ///
  /// After you perform this action, the subnet no longer uses the routes in the
  /// route table. Instead, it uses the routes in the VPC's main route table.
  /// For more information about route tables, see
  /// [Route Tables](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Route_Tables.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [associationId]: The association ID representing the current association
  /// between the route table and subnet.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> disassociateRouteTable(String associationId,
      {bool dryRun}) async {
    await _client.send('DisassociateRouteTable', {
      'AssociationId': associationId,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Disassociates a CIDR block from a subnet. Currently, you can disassociate
  /// an IPv6 CIDR block only. You must detach or delete all gateways and
  /// resources that are associated with the CIDR block before you can
  /// disassociate it.
  ///
  /// [associationId]: The association ID for the CIDR block.
  Future<DisassociateSubnetCidrBlockResult> disassociateSubnetCidrBlock(
      String associationId) async {
    var response_ = await _client.send('DisassociateSubnetCidrBlock', {
      'AssociationId': associationId,
    });
    return DisassociateSubnetCidrBlockResult.fromJson(response_);
  }

  /// Disassociates a resource attachment from a transit gateway route table.
  ///
  /// [transitGatewayRouteTableId]: The ID of the transit gateway route table.
  ///
  /// [transitGatewayAttachmentId]: The ID of the attachment.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<DisassociateTransitGatewayRouteTableResult>
      disassociateTransitGatewayRouteTable(
          {@required String transitGatewayRouteTableId,
          @required String transitGatewayAttachmentId,
          bool dryRun}) async {
    var response_ = await _client.send('DisassociateTransitGatewayRouteTable', {
      'TransitGatewayRouteTableId': transitGatewayRouteTableId,
      'TransitGatewayAttachmentId': transitGatewayAttachmentId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return DisassociateTransitGatewayRouteTableResult.fromJson(response_);
  }

  /// Disassociates a CIDR block from a VPC. To disassociate the CIDR block, you
  /// must specify its association ID. You can get the association ID by using
  /// DescribeVpcs. You must detach or delete all gateways and resources that
  /// are associated with the CIDR block before you can disassociate it.
  ///
  /// You cannot disassociate the CIDR block with which you originally created
  /// the VPC (the primary CIDR block).
  ///
  /// [associationId]: The association ID for the CIDR block.
  Future<DisassociateVpcCidrBlockResult> disassociateVpcCidrBlock(
      String associationId) async {
    var response_ = await _client.send('DisassociateVpcCidrBlock', {
      'AssociationId': associationId,
    });
    return DisassociateVpcCidrBlockResult.fromJson(response_);
  }

  /// Enables EBS encryption by default for your account in the current Region.
  ///
  /// After you enable encryption by default, the EBS volumes that you create
  /// are are always encrypted, either using the default CMK or the CMK that you
  /// specified when you created each volume. For more information, see
  /// [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// You can specify the default CMK for encryption by default using
  /// ModifyEbsDefaultKmsKeyId or ResetEbsDefaultKmsKeyId.
  ///
  /// Enabling encryption by default has no effect on the encryption status of
  /// your existing volumes.
  ///
  /// After you enable encryption by default, you can no longer launch instances
  /// using instance types that do not support encryption. For more information,
  /// see
  /// [Supported Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<EnableEbsEncryptionByDefaultResult> enableEbsEncryptionByDefault(
      {bool dryRun}) async {
    var response_ = await _client.send('EnableEbsEncryptionByDefault', {
      if (dryRun != null) 'DryRun': dryRun,
    });
    return EnableEbsEncryptionByDefaultResult.fromJson(response_);
  }

  /// Enables the specified attachment to propagate routes to the specified
  /// propagation route table.
  ///
  /// [transitGatewayRouteTableId]: The ID of the propagation route table.
  ///
  /// [transitGatewayAttachmentId]: The ID of the attachment.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<EnableTransitGatewayRouteTablePropagationResult>
      enableTransitGatewayRouteTablePropagation(
          {@required String transitGatewayRouteTableId,
          @required String transitGatewayAttachmentId,
          bool dryRun}) async {
    var response_ =
        await _client.send('EnableTransitGatewayRouteTablePropagation', {
      'TransitGatewayRouteTableId': transitGatewayRouteTableId,
      'TransitGatewayAttachmentId': transitGatewayAttachmentId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return EnableTransitGatewayRouteTablePropagationResult.fromJson(response_);
  }

  /// Enables a virtual private gateway (VGW) to propagate routes to the
  /// specified route table of a VPC.
  ///
  /// [gatewayId]: The ID of the virtual private gateway that is attached to a
  /// VPC. The virtual private gateway must be attached to the same VPC that the
  /// routing tables are associated with.
  ///
  /// [routeTableId]: The ID of the route table. The routing table must be
  /// associated with the same VPC that the virtual private gateway is attached
  /// to.
  Future<void> enableVgwRoutePropagation(
      {@required String gatewayId, @required String routeTableId}) async {
    await _client.send('EnableVgwRoutePropagation', {
      'GatewayId': gatewayId,
      'RouteTableId': routeTableId,
    });
  }

  /// Enables I/O operations for a volume that had I/O operations disabled
  /// because the data on the volume was potentially inconsistent.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [volumeId]: The ID of the volume.
  Future<void> enableVolumeIO(String volumeId, {bool dryRun}) async {
    await _client.send('EnableVolumeIO', {
      if (dryRun != null) 'DryRun': dryRun,
      'VolumeId': volumeId,
    });
  }

  /// Enables a VPC for ClassicLink. You can then link EC2-Classic instances to
  /// your ClassicLink-enabled VPC to allow communication over private IP
  /// addresses. You cannot enable your VPC for ClassicLink if any of your VPC
  /// route tables have existing routes for address ranges within the
  /// `10.0.0.0/8` IP address range, excluding local routes for VPCs in the
  /// `10.0.0.0/16` and `10.1.0.0/16` IP address ranges. For more information,
  /// see
  /// [ClassicLink](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [vpcId]: The ID of the VPC.
  Future<EnableVpcClassicLinkResult> enableVpcClassicLink(String vpcId,
      {bool dryRun}) async {
    var response_ = await _client.send('EnableVpcClassicLink', {
      if (dryRun != null) 'DryRun': dryRun,
      'VpcId': vpcId,
    });
    return EnableVpcClassicLinkResult.fromJson(response_);
  }

  /// Enables a VPC to support DNS hostname resolution for ClassicLink. If
  /// enabled, the DNS hostname of a linked EC2-Classic instance resolves to its
  /// private IP address when addressed from an instance in the VPC to which
  /// it's linked. Similarly, the DNS hostname of an instance in a VPC resolves
  /// to its private IP address when addressed from a linked EC2-Classic
  /// instance. For more information, see
  /// [ClassicLink](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [vpcId]: The ID of the VPC.
  Future<EnableVpcClassicLinkDnsSupportResult> enableVpcClassicLinkDnsSupport(
      {String vpcId}) async {
    var response_ = await _client.send('EnableVpcClassicLinkDnsSupport', {
      if (vpcId != null) 'VpcId': vpcId,
    });
    return EnableVpcClassicLinkDnsSupportResult.fromJson(response_);
  }

  /// Downloads the client certificate revocation list for the specified Client
  /// VPN endpoint.
  ///
  /// [clientVpnEndpointId]: The ID of the Client VPN endpoint.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ExportClientVpnClientCertificateRevocationListResult>
      exportClientVpnClientCertificateRevocationList(String clientVpnEndpointId,
          {bool dryRun}) async {
    var response_ =
        await _client.send('ExportClientVpnClientCertificateRevocationList', {
      'ClientVpnEndpointId': clientVpnEndpointId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ExportClientVpnClientCertificateRevocationListResult.fromJson(
        response_);
  }

  /// Downloads the contents of the Client VPN endpoint configuration file for
  /// the specified Client VPN endpoint. The Client VPN endpoint configuration
  /// file includes the Client VPN endpoint and certificate information clients
  /// need to establish a connection with the Client VPN endpoint.
  ///
  /// [clientVpnEndpointId]: The ID of the Client VPN endpoint.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ExportClientVpnClientConfigurationResult>
      exportClientVpnClientConfiguration(String clientVpnEndpointId,
          {bool dryRun}) async {
    var response_ = await _client.send('ExportClientVpnClientConfiguration', {
      'ClientVpnEndpointId': clientVpnEndpointId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ExportClientVpnClientConfigurationResult.fromJson(response_);
  }

  /// Exports an Amazon Machine Image (AMI) to a VM file. For more information,
  /// see
  /// [Exporting a VM Directory from an Amazon Machine Image (AMI)](https://docs.aws.amazon.com/vm-import/latest/userguide/vmexport_image.html)
  /// in the _VM Import/Export User Guide_.
  ///
  /// [clientToken]: Token to enable idempotency for export image requests.
  ///
  /// [description]: A description of the image being exported. The maximum
  /// length is 255 bytes.
  ///
  /// [diskImageFormat]: The disk image format.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [imageId]: The ID of the image.
  ///
  /// [s3ExportLocation]: Information about the destination S3 bucket. The
  /// bucket must exist and grant WRITE and READ_ACP permissions to the AWS
  /// account vm-import-export@amazon.com.
  ///
  /// [roleName]: The name of the role that grants VM Import/Export permission
  /// to export images to your S3 bucket. If this parameter is not specified,
  /// the default role is named 'vmimport'.
  Future<ExportImageResult> exportImage(
      {String clientToken,
      String description,
      @required String diskImageFormat,
      bool dryRun,
      @required String imageId,
      @required ExportTaskS3LocationRequest s3ExportLocation,
      String roleName}) async {
    var response_ = await _client.send('ExportImage', {
      if (clientToken != null) 'ClientToken': clientToken,
      if (description != null) 'Description': description,
      'DiskImageFormat': diskImageFormat,
      if (dryRun != null) 'DryRun': dryRun,
      'ImageId': imageId,
      'S3ExportLocation': s3ExportLocation,
      if (roleName != null) 'RoleName': roleName,
    });
    return ExportImageResult.fromJson(response_);
  }

  /// Exports routes from the specified transit gateway route table to the
  /// specified S3 bucket. By default, all routes are exported. Alternatively,
  /// you can filter by CIDR range.
  ///
  /// [transitGatewayRouteTableId]: The ID of the route table.
  ///
  /// [filters]: One or more filters. The possible values are:
  ///
  /// *    `attachment.transit-gateway-attachment-id` - The id of the transit
  /// gateway attachment.
  ///
  /// *    `attachment.resource-id` - The resource id of the transit gateway
  /// attachment.
  ///
  /// *    `route-search.exact-match` - The exact match of the specified filter.
  ///
  /// *    `route-search.longest-prefix-match` - The longest prefix that matches
  /// the route.
  ///
  /// *    `route-search.subnet-of-match` - The routes with a subnet that match
  /// the specified CIDR filter.
  ///
  /// *    `route-search.supernet-of-match` - The routes with a CIDR that
  /// encompass the CIDR filter. For example, if you have 10.0.1.0/29 and
  /// 10.0.1.0/31 routes in your route table and you specify supernet-of-match
  /// as 10.0.1.0/30, then the result returns 10.0.1.0/29.
  ///
  /// *    `state` - The state of the attachment (`available` | `deleted` |
  /// `deleting` | `failed` | `modifying` | `pendingAcceptance` | `pending` |
  /// `rollingBack` | `rejected` | `rejecting`).
  ///
  /// *    `transit-gateway-route-destination-cidr-block` - The CIDR range.
  ///
  /// *    `type` - The type of route (`active` | `blackhole`).
  ///
  /// [s3Bucket]: The name of the S3 bucket.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ExportTransitGatewayRoutesResult> exportTransitGatewayRoutes(
      {@required String transitGatewayRouteTableId,
      List<Filter> filters,
      @required String s3Bucket,
      bool dryRun}) async {
    var response_ = await _client.send('ExportTransitGatewayRoutes', {
      'TransitGatewayRouteTableId': transitGatewayRouteTableId,
      if (filters != null) 'Filters': filters,
      'S3Bucket': s3Bucket,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ExportTransitGatewayRoutesResult.fromJson(response_);
  }

  /// Gets usage information about a Capacity Reservation. If the Capacity
  /// Reservation is shared, it shows usage information for the Capacity
  /// Reservation owner and each AWS account that is currently using the shared
  /// capacity. If the Capacity Reservation is not shared, it shows only the
  /// Capacity Reservation owner's usage.
  ///
  /// [capacityReservationId]: The ID of the Capacity Reservation.
  ///
  /// [nextToken]: The token to retrieve the next page of results.
  ///
  /// [maxResults]: The maximum number of results to return for the request in a
  /// single page. The remaining results can be seen by sending another request
  /// with the returned nextToken value.
  ///
  /// Valid range: Minimum value of 1. Maximum value of 1000.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<GetCapacityReservationUsageResult> getCapacityReservationUsage(
      String capacityReservationId,
      {String nextToken,
      int maxResults,
      bool dryRun}) async {
    var response_ = await _client.send('GetCapacityReservationUsage', {
      'CapacityReservationId': capacityReservationId,
      if (nextToken != null) 'NextToken': nextToken,
      if (maxResults != null) 'MaxResults': maxResults,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return GetCapacityReservationUsageResult.fromJson(response_);
  }

  /// Gets the console output for the specified instance. For Linux instances,
  /// the instance console output displays the exact console output that would
  /// normally be displayed on a physical monitor attached to a computer. For
  /// Windows instances, the instance console output includes the last three
  /// system event log errors.
  ///
  /// By default, the console output returns buffered information that was
  /// posted shortly after an instance transition state (start, stop, reboot, or
  /// terminate). This information is available for at least one hour after the
  /// most recent post. Only the most recent 64 KB of console output is
  /// available.
  ///
  /// You can optionally retrieve the latest serial console output at any time
  /// during the instance lifecycle. This option is supported on instance types
  /// that use the Nitro hypervisor.
  ///
  /// For more information, see
  /// [Instance Console Output](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-console.html#instance-console-console-output)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [instanceId]: The ID of the instance.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [latest]: When enabled, retrieves the latest console output for the
  /// instance.
  ///
  /// Default: disabled (`false`)
  Future<GetConsoleOutputResult> getConsoleOutput(String instanceId,
      {bool dryRun, bool latest}) async {
    var response_ = await _client.send('GetConsoleOutput', {
      'InstanceId': instanceId,
      if (dryRun != null) 'DryRun': dryRun,
      if (latest != null) 'Latest': latest,
    });
    return GetConsoleOutputResult.fromJson(response_);
  }

  /// Retrieve a JPG-format screenshot of a running instance to help with
  /// troubleshooting.
  ///
  /// The returned content is Base64-encoded.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [instanceId]: The ID of the instance.
  ///
  /// [wakeUp]: When set to `true`, acts as keystroke input and wakes up an
  /// instance that's in standby or "sleep" mode.
  Future<GetConsoleScreenshotResult> getConsoleScreenshot(String instanceId,
      {bool dryRun, bool wakeUp}) async {
    var response_ = await _client.send('GetConsoleScreenshot', {
      if (dryRun != null) 'DryRun': dryRun,
      'InstanceId': instanceId,
      if (wakeUp != null) 'WakeUp': wakeUp,
    });
    return GetConsoleScreenshotResult.fromJson(response_);
  }

  /// Describes the default customer master key (CMK) for EBS encryption by
  /// default for your account in this Region. You can change the default CMK
  /// for encryption by default using ModifyEbsDefaultKmsKeyId or
  /// ResetEbsDefaultKmsKeyId.
  ///
  /// For more information, see
  /// [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<GetEbsDefaultKmsKeyIdResult> getEbsDefaultKmsKeyId(
      {bool dryRun}) async {
    var response_ = await _client.send('GetEbsDefaultKmsKeyId', {
      if (dryRun != null) 'DryRun': dryRun,
    });
    return GetEbsDefaultKmsKeyIdResult.fromJson(response_);
  }

  /// Describes whether EBS encryption by default is enabled for your account in
  /// the current Region.
  ///
  /// For more information, see
  /// [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<GetEbsEncryptionByDefaultResult> getEbsEncryptionByDefault(
      {bool dryRun}) async {
    var response_ = await _client.send('GetEbsEncryptionByDefault', {
      if (dryRun != null) 'DryRun': dryRun,
    });
    return GetEbsEncryptionByDefaultResult.fromJson(response_);
  }

  /// Preview a reservation purchase with configurations that match those of
  /// your Dedicated Host. You must have active Dedicated Hosts in your account
  /// before you purchase a reservation.
  ///
  /// This is a preview of the PurchaseHostReservation action and does not
  /// result in the offering being purchased.
  ///
  /// [hostIdSet]: The IDs of the Dedicated Hosts with which the reservation is
  /// associated.
  ///
  /// [offeringId]: The offering ID of the reservation.
  Future<GetHostReservationPurchasePreviewResult>
      getHostReservationPurchasePreview(
          {@required List<String> hostIdSet,
          @required String offeringId}) async {
    var response_ = await _client.send('GetHostReservationPurchasePreview', {
      'HostIdSet': hostIdSet,
      'OfferingId': offeringId,
    });
    return GetHostReservationPurchasePreviewResult.fromJson(response_);
  }

  /// Retrieves the configuration data of the specified instance. You can use
  /// this data to create a launch template.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [instanceId]: The ID of the instance.
  Future<GetLaunchTemplateDataResult> getLaunchTemplateData(String instanceId,
      {bool dryRun}) async {
    var response_ = await _client.send('GetLaunchTemplateData', {
      if (dryRun != null) 'DryRun': dryRun,
      'InstanceId': instanceId,
    });
    return GetLaunchTemplateDataResult.fromJson(response_);
  }

  /// Retrieves the encrypted administrator password for a running Windows
  /// instance.
  ///
  /// The Windows password is generated at boot by the `EC2Config` service or
  /// `EC2Launch` scripts (Windows Server 2016 and later). This usually only
  /// happens the first time an instance is launched. For more information, see
  /// [EC2Config](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/UsingConfig_WinAMI.html)
  /// and
  /// [EC2Launch](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2launch.html)
  /// in the Amazon Elastic Compute Cloud User Guide.
  ///
  /// For the `EC2Config` service, the password is not generated for rebundled
  /// AMIs unless `Ec2SetPassword` is enabled before bundling.
  ///
  /// The password is encrypted using the key pair that you specified when you
  /// launched the instance. You must provide the corresponding key pair file.
  ///
  /// When you launch an instance, password generation and encryption may take a
  /// few minutes. If you try to retrieve the password before it's available,
  /// the output returns an empty string. We recommend that you wait up to 15
  /// minutes after launching an instance before trying to retrieve the
  /// generated password.
  ///
  /// [instanceId]: The ID of the Windows instance.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<GetPasswordDataResult> getPasswordData(String instanceId,
      {bool dryRun}) async {
    var response_ = await _client.send('GetPasswordData', {
      'InstanceId': instanceId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return GetPasswordDataResult.fromJson(response_);
  }

  /// Returns a quote and exchange information for exchanging one or more
  /// specified Convertible Reserved Instances for a new Convertible Reserved
  /// Instance. If the exchange cannot be performed, the reason is returned in
  /// the response. Use AcceptReservedInstancesExchangeQuote to perform the
  /// exchange.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [reservedInstanceIds]: The IDs of the Convertible Reserved Instances to
  /// exchange.
  ///
  /// [targetConfigurations]: The configuration of the target Convertible
  /// Reserved Instance to exchange for your current Convertible Reserved
  /// Instances.
  Future<GetReservedInstancesExchangeQuoteResult>
      getReservedInstancesExchangeQuote(List<String> reservedInstanceIds,
          {bool dryRun,
          List<TargetConfigurationRequest> targetConfigurations}) async {
    var response_ = await _client.send('GetReservedInstancesExchangeQuote', {
      if (dryRun != null) 'DryRun': dryRun,
      'ReservedInstanceIds': reservedInstanceIds,
      if (targetConfigurations != null)
        'TargetConfigurations': targetConfigurations,
    });
    return GetReservedInstancesExchangeQuoteResult.fromJson(response_);
  }

  /// Lists the route tables to which the specified resource attachment
  /// propagates routes.
  ///
  /// [transitGatewayAttachmentId]: The ID of the attachment.
  ///
  /// [filters]: One or more filters. The possible values are:
  ///
  /// *    `transit-gateway-route-table-id` - The ID of the transit gateway
  /// route table.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  ///
  /// [nextToken]: The token for the next page of results.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<GetTransitGatewayAttachmentPropagationsResult>
      getTransitGatewayAttachmentPropagations(String transitGatewayAttachmentId,
          {List<Filter> filters,
          int maxResults,
          String nextToken,
          bool dryRun}) async {
    var response_ =
        await _client.send('GetTransitGatewayAttachmentPropagations', {
      'TransitGatewayAttachmentId': transitGatewayAttachmentId,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return GetTransitGatewayAttachmentPropagationsResult.fromJson(response_);
  }

  /// Gets information about the associations for the specified transit gateway
  /// route table.
  ///
  /// [transitGatewayRouteTableId]: The ID of the transit gateway route table.
  ///
  /// [filters]: One or more filters. The possible values are:
  ///
  /// *    `resource-id` - The ID of the resource.
  ///
  /// *    `resource-type` - The resource type (`vpc` | `vpn`).
  ///
  /// *    `transit-gateway-attachment-id` - The ID of the attachment.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  ///
  /// [nextToken]: The token for the next page of results.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<GetTransitGatewayRouteTableAssociationsResult>
      getTransitGatewayRouteTableAssociations(String transitGatewayRouteTableId,
          {List<Filter> filters,
          int maxResults,
          String nextToken,
          bool dryRun}) async {
    var response_ =
        await _client.send('GetTransitGatewayRouteTableAssociations', {
      'TransitGatewayRouteTableId': transitGatewayRouteTableId,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return GetTransitGatewayRouteTableAssociationsResult.fromJson(response_);
  }

  /// Gets information about the route table propagations for the specified
  /// transit gateway route table.
  ///
  /// [transitGatewayRouteTableId]: The ID of the transit gateway route table.
  ///
  /// [filters]: One or more filters. The possible values are:
  ///
  /// *    `resource-id` - The ID of the resource.
  ///
  /// *    `resource-type` - The resource type (`vpc` | `vpn`).
  ///
  /// *    `transit-gateway-attachment-id` - The ID of the attachment.
  ///
  /// [maxResults]: The maximum number of results to return with a single call.
  /// To retrieve the remaining results, make another call with the returned
  /// `nextToken` value.
  ///
  /// [nextToken]: The token for the next page of results.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<GetTransitGatewayRouteTablePropagationsResult>
      getTransitGatewayRouteTablePropagations(String transitGatewayRouteTableId,
          {List<Filter> filters,
          int maxResults,
          String nextToken,
          bool dryRun}) async {
    var response_ =
        await _client.send('GetTransitGatewayRouteTablePropagations', {
      'TransitGatewayRouteTableId': transitGatewayRouteTableId,
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return GetTransitGatewayRouteTablePropagationsResult.fromJson(response_);
  }

  /// Uploads a client certificate revocation list to the specified Client VPN
  /// endpoint. Uploading a client certificate revocation list overwrites the
  /// existing client certificate revocation list.
  ///
  /// Uploading a client certificate revocation list resets existing client
  /// connections.
  ///
  /// [clientVpnEndpointId]: The ID of the Client VPN endpoint to which the
  /// client certificate revocation list applies.
  ///
  /// [certificateRevocationList]: The client certificate revocation list file.
  /// For more information, see
  /// [Generate a Client Certificate Revocation List](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/cvpn-working-certificates.html#cvpn-working-certificates-generate)
  /// in the _AWS Client VPN Administrator Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ImportClientVpnClientCertificateRevocationListResult>
      importClientVpnClientCertificateRevocationList(
          {@required String clientVpnEndpointId,
          @required String certificateRevocationList,
          bool dryRun}) async {
    var response_ =
        await _client.send('ImportClientVpnClientCertificateRevocationList', {
      'ClientVpnEndpointId': clientVpnEndpointId,
      'CertificateRevocationList': certificateRevocationList,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ImportClientVpnClientCertificateRevocationListResult.fromJson(
        response_);
  }

  /// Import single or multi-volume disk images or EBS snapshots into an Amazon
  /// Machine Image (AMI). For more information, see
  /// [Importing a VM as an Image Using VM Import/Export](https://docs.aws.amazon.com/vm-import/latest/userguide/vmimport-image-import.html)
  /// in the _VM Import/Export User Guide_.
  ///
  /// [architecture]: The architecture of the virtual machine.
  ///
  /// Valid values: `i386` | `x86_64` | `arm64`
  ///
  /// [clientData]: The client-specific data.
  ///
  /// [clientToken]: The token to enable idempotency for VM import requests.
  ///
  /// [description]: A description string for the import image task.
  ///
  /// [diskContainers]: Information about the disk containers.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [encrypted]: Specifies whether the destination AMI of the imported image
  /// should be encrypted. The default CMK for EBS is used unless you specify a
  /// non-default AWS Key Management Service (AWS KMS) CMK using `KmsKeyId`. For
  /// more information, see
  /// [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [hypervisor]: The target hypervisor platform.
  ///
  /// Valid values: `xen`
  ///
  /// [kmsKeyId]: An identifier for the AWS Key Management Service (AWS KMS)
  /// customer master key (CMK) to use when creating the encrypted AMI. This
  /// parameter is only required if you want to use a non-default CMK; if this
  /// parameter is not specified, the default CMK for EBS is used. If a
  /// `KmsKeyId` is specified, the `Encrypted` flag must also be set.
  ///
  /// The CMK identifier may be provided in any of the following formats:
  ///
  /// *   Key ID
  ///
  /// *   Key alias. The alias ARN contains the `arn:aws:kms` namespace,
  /// followed by the Region of the CMK, the AWS account ID of the CMK owner,
  /// the `alias` namespace, and then the CMK alias. For example,
  /// arn:aws:kms:_us-east-1_:_012345678910_:alias/_ExampleAlias_.
  ///
  /// *   ARN using key ID. The ID ARN contains the `arn:aws:kms` namespace,
  /// followed by the Region of the CMK, the AWS account ID of the CMK owner,
  /// the `key` namespace, and then the CMK ID. For example,
  /// arn:aws:kms:_us-east-1_:_012345678910_:key/_abcd1234-a123-456a-a12b-a123b4cd56ef_.
  ///
  /// *   ARN using key alias. The alias ARN contains the `arn:aws:kms`
  /// namespace, followed by the Region of the CMK, the AWS account ID of the
  /// CMK owner, the `alias` namespace, and then the CMK alias. For example,
  /// arn:aws:kms:_us-east-1_:_012345678910_:alias/_ExampleAlias_.
  ///
  ///
  /// AWS parses `KmsKeyId` asynchronously, meaning that the action you call may
  /// appear to complete even though you provided an invalid identifier. This
  /// action will eventually report failure.
  ///
  /// The specified CMK must exist in the Region that the AMI is being copied
  /// to.
  ///
  /// [licenseType]: The license type to be used for the Amazon Machine Image
  /// (AMI) after importing.
  ///
  /// By default, we detect the source-system operating system (OS) and apply
  /// the appropriate license. Specify `AWS` to replace the source-system
  /// license with an AWS license, if appropriate. Specify `BYOL` to retain the
  /// source-system license, if appropriate.
  ///
  /// To use `BYOL`, you must have existing licenses with rights to use these
  /// licenses in a third party cloud, such as AWS. For more information, see
  /// [Prerequisites](https://docs.aws.amazon.com/vm-import/latest/userguide/vmimport-image-import.html#prerequisites-image)
  /// in the VM Import/Export User Guide.
  ///
  /// [platform]: The operating system of the virtual machine.
  ///
  /// Valid values: `Windows` | `Linux`
  ///
  /// [roleName]: The name of the role to use when not using the default role,
  /// 'vmimport'.
  Future<ImportImageResult> importImage(
      {String architecture,
      ClientData clientData,
      String clientToken,
      String description,
      List<ImageDiskContainer> diskContainers,
      bool dryRun,
      bool encrypted,
      String hypervisor,
      String kmsKeyId,
      String licenseType,
      String platform,
      String roleName}) async {
    var response_ = await _client.send('ImportImage', {
      if (architecture != null) 'Architecture': architecture,
      if (clientData != null) 'ClientData': clientData,
      if (clientToken != null) 'ClientToken': clientToken,
      if (description != null) 'Description': description,
      if (diskContainers != null) 'DiskContainers': diskContainers,
      if (dryRun != null) 'DryRun': dryRun,
      if (encrypted != null) 'Encrypted': encrypted,
      if (hypervisor != null) 'Hypervisor': hypervisor,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      if (licenseType != null) 'LicenseType': licenseType,
      if (platform != null) 'Platform': platform,
      if (roleName != null) 'RoleName': roleName,
    });
    return ImportImageResult.fromJson(response_);
  }

  /// Creates an import instance task using metadata from the specified disk
  /// image. `ImportInstance` only supports single-volume VMs. To import
  /// multi-volume VMs, use ImportImage. For more information, see
  /// [Importing a Virtual Machine Using the Amazon EC2 CLI](https://docs.aws.amazon.com/AWSEC2/latest/CommandLineReference/ec2-cli-vmimport-export.html).
  ///
  /// For information about the import manifest referenced by this API action,
  /// see
  /// [VM Import Manifest](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html).
  ///
  /// [description]: A description for the instance being imported.
  ///
  /// [diskImages]: The disk image.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [launchSpecification]: The launch specification.
  ///
  /// [platform]: The instance operating system.
  Future<ImportInstanceResult> importInstance(String platform,
      {String description,
      List<DiskImage> diskImages,
      bool dryRun,
      ImportInstanceLaunchSpecification launchSpecification}) async {
    var response_ = await _client.send('ImportInstance', {
      if (description != null) 'Description': description,
      if (diskImages != null) 'DiskImages': diskImages,
      if (dryRun != null) 'DryRun': dryRun,
      if (launchSpecification != null)
        'LaunchSpecification': launchSpecification,
      'Platform': platform,
    });
    return ImportInstanceResult.fromJson(response_);
  }

  /// Imports the public key from an RSA key pair that you created with a
  /// third-party tool. Compare this with CreateKeyPair, in which AWS creates
  /// the key pair and gives the keys to you (AWS keeps a copy of the public
  /// key). With ImportKeyPair, you create the key pair and give AWS just the
  /// public key. The private key is never transferred between you and AWS.
  ///
  /// For more information about key pairs, see
  /// [Key Pairs](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [keyName]: A unique name for the key pair.
  ///
  /// [publicKeyMaterial]: The public key. For API calls, the text must be
  /// base64-encoded. For command line tools, base64 encoding is performed for
  /// you.
  Future<ImportKeyPairResult> importKeyPair(
      {bool dryRun,
      @required String keyName,
      @required Uint8List publicKeyMaterial}) async {
    var response_ = await _client.send('ImportKeyPair', {
      if (dryRun != null) 'DryRun': dryRun,
      'KeyName': keyName,
      'PublicKeyMaterial': publicKeyMaterial,
    });
    return ImportKeyPairResult.fromJson(response_);
  }

  /// Imports a disk into an EBS snapshot.
  ///
  /// [clientData]: The client-specific data.
  ///
  /// [clientToken]: Token to enable idempotency for VM import requests.
  ///
  /// [description]: The description string for the import snapshot task.
  ///
  /// [diskContainer]: Information about the disk container.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [encrypted]: Specifies whether the destination snapshot of the imported
  /// image should be encrypted. The default CMK for EBS is used unless you
  /// specify a non-default AWS Key Management Service (AWS KMS) CMK using
  /// `KmsKeyId`. For more information, see
  /// [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [kmsKeyId]: An identifier for the AWS Key Management Service (AWS KMS)
  /// customer master key (CMK) to use when creating the encrypted snapshot.
  /// This parameter is only required if you want to use a non-default CMK; if
  /// this parameter is not specified, the default CMK for EBS is used. If a
  /// `KmsKeyId` is specified, the `Encrypted` flag must also be set.
  ///
  /// The CMK identifier may be provided in any of the following formats:
  ///
  /// *   Key ID
  ///
  /// *   Key alias. The alias ARN contains the `arn:aws:kms` namespace,
  /// followed by the Region of the CMK, the AWS account ID of the CMK owner,
  /// the `alias` namespace, and then the CMK alias. For example,
  /// arn:aws:kms:_us-east-1_:_012345678910_:alias/_ExampleAlias_.
  ///
  /// *   ARN using key ID. The ID ARN contains the `arn:aws:kms` namespace,
  /// followed by the Region of the CMK, the AWS account ID of the CMK owner,
  /// the `key` namespace, and then the CMK ID. For example,
  /// arn:aws:kms:_us-east-1_:_012345678910_:key/_abcd1234-a123-456a-a12b-a123b4cd56ef_.
  ///
  /// *   ARN using key alias. The alias ARN contains the `arn:aws:kms`
  /// namespace, followed by the Region of the CMK, the AWS account ID of the
  /// CMK owner, the `alias` namespace, and then the CMK alias. For example,
  /// arn:aws:kms:_us-east-1_:_012345678910_:alias/_ExampleAlias_.
  ///
  ///
  /// AWS parses `KmsKeyId` asynchronously, meaning that the action you call may
  /// appear to complete even though you provided an invalid identifier. This
  /// action will eventually report failure.
  ///
  /// The specified CMK must exist in the Region that the snapshot is being
  /// copied to.
  ///
  /// [roleName]: The name of the role to use when not using the default role,
  /// 'vmimport'.
  Future<ImportSnapshotResult> importSnapshot(
      {ClientData clientData,
      String clientToken,
      String description,
      SnapshotDiskContainer diskContainer,
      bool dryRun,
      bool encrypted,
      String kmsKeyId,
      String roleName}) async {
    var response_ = await _client.send('ImportSnapshot', {
      if (clientData != null) 'ClientData': clientData,
      if (clientToken != null) 'ClientToken': clientToken,
      if (description != null) 'Description': description,
      if (diskContainer != null) 'DiskContainer': diskContainer,
      if (dryRun != null) 'DryRun': dryRun,
      if (encrypted != null) 'Encrypted': encrypted,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      if (roleName != null) 'RoleName': roleName,
    });
    return ImportSnapshotResult.fromJson(response_);
  }

  /// Creates an import volume task using metadata from the specified disk
  /// image.For more information, see
  /// [Importing Disks to Amazon EBS](https://docs.aws.amazon.com/AWSEC2/latest/CommandLineReference/importing-your-volumes-into-amazon-ebs.html).
  ///
  /// For information about the import manifest referenced by this API action,
  /// see
  /// [VM Import Manifest](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html).
  ///
  /// [availabilityZone]: The Availability Zone for the resulting EBS volume.
  ///
  /// [description]: A description of the volume.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [image]: The disk image.
  ///
  /// [volume]: The volume size.
  Future<ImportVolumeResult> importVolume(
      {@required String availabilityZone,
      String description,
      bool dryRun,
      @required DiskImageDetail image,
      @required VolumeDetail volume}) async {
    var response_ = await _client.send('ImportVolume', {
      'AvailabilityZone': availabilityZone,
      if (description != null) 'Description': description,
      if (dryRun != null) 'DryRun': dryRun,
      'Image': image,
      'Volume': volume,
    });
    return ImportVolumeResult.fromJson(response_);
  }

  /// Modifies a Capacity Reservation's capacity and the conditions under which
  /// it is to be released. You cannot change a Capacity Reservation's instance
  /// type, EBS optimization, instance store settings, platform, Availability
  /// Zone, or instance eligibility. If you need to modify any of these
  /// attributes, we recommend that you cancel the Capacity Reservation, and
  /// then create a new one with the required attributes.
  ///
  /// [capacityReservationId]: The ID of the Capacity Reservation.
  ///
  /// [instanceCount]: The number of instances for which to reserve capacity.
  ///
  /// [endDate]: The date and time at which the Capacity Reservation expires.
  /// When a Capacity Reservation expires, the reserved capacity is released and
  /// you can no longer launch instances into it. The Capacity Reservation's
  /// state changes to `expired` when it reaches its end date and time.
  ///
  /// The Capacity Reservation is cancelled within an hour from the specified
  /// time. For example, if you specify 5/31/2019, 13:30:55, the Capacity
  /// Reservation is guaranteed to end between 13:30:55 and 14:30:55 on
  /// 5/31/2019.
  ///
  /// You must provide an `EndDate` value if `EndDateType` is `limited`. Omit
  /// `EndDate` if `EndDateType` is `unlimited`.
  ///
  /// [endDateType]: Indicates the way in which the Capacity Reservation ends. A
  /// Capacity Reservation can have one of the following end types:
  ///
  /// *    `unlimited` - The Capacity Reservation remains active until you
  /// explicitly cancel it. Do not provide an `EndDate` value if `EndDateType`
  /// is `unlimited`.
  ///
  /// *    `limited` - The Capacity Reservation expires automatically at a
  /// specified date and time. You must provide an `EndDate` value if
  /// `EndDateType` is `limited`.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ModifyCapacityReservationResult> modifyCapacityReservation(
      String capacityReservationId,
      {int instanceCount,
      DateTime endDate,
      String endDateType,
      bool dryRun}) async {
    var response_ = await _client.send('ModifyCapacityReservation', {
      'CapacityReservationId': capacityReservationId,
      if (instanceCount != null) 'InstanceCount': instanceCount,
      if (endDate != null) 'EndDate': endDate,
      if (endDateType != null) 'EndDateType': endDateType,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ModifyCapacityReservationResult.fromJson(response_);
  }

  /// Modifies the specified Client VPN endpoint. You can only modify an
  /// endpoint's server certificate information, client connection logging
  /// information, DNS server, and description. Modifying the DNS server resets
  /// existing client connections.
  ///
  /// [clientVpnEndpointId]: The ID of the Client VPN endpoint to modify.
  ///
  /// [serverCertificateArn]: The ARN of the server certificate to be used. The
  /// server certificate must be provisioned in AWS Certificate Manager (ACM).
  ///
  /// [connectionLogOptions]: Information about the client connection logging
  /// options.
  ///
  /// If you enable client connection logging, data about client connections is
  /// sent to a Cloudwatch Logs log stream. The following information is logged:
  ///
  /// *   Client connection requests
  ///
  /// *   Client connection results (successful and unsuccessful)
  ///
  /// *   Reasons for unsuccessful client connection requests
  ///
  /// *   Client connection termination time
  ///
  /// [dnsServers]: Information about the DNS servers to be used by Client VPN
  /// connections. A Client VPN endpoint can have up to two DNS servers.
  ///
  /// [description]: A brief description of the Client VPN endpoint.
  ///
  /// [splitTunnel]: Indicates whether the VPN is split-tunnel.
  ///
  /// For information about split-tunnel VPN endpoints, see
  /// [Split-Tunnel AWS Client VPN Endpoint](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html)
  /// in the _AWS Client VPN Administrator Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ModifyClientVpnEndpointResult> modifyClientVpnEndpoint(
      String clientVpnEndpointId,
      {String serverCertificateArn,
      ConnectionLogOptions connectionLogOptions,
      DnsServersOptionsModifyStructure dnsServers,
      String description,
      bool splitTunnel,
      bool dryRun}) async {
    var response_ = await _client.send('ModifyClientVpnEndpoint', {
      'ClientVpnEndpointId': clientVpnEndpointId,
      if (serverCertificateArn != null)
        'ServerCertificateArn': serverCertificateArn,
      if (connectionLogOptions != null)
        'ConnectionLogOptions': connectionLogOptions,
      if (dnsServers != null) 'DnsServers': dnsServers,
      if (description != null) 'Description': description,
      if (splitTunnel != null) 'SplitTunnel': splitTunnel,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ModifyClientVpnEndpointResult.fromJson(response_);
  }

  /// Changes the default customer master key (CMK) for EBS encryption by
  /// default for your account in this Region.
  ///
  /// AWS creates a unique AWS managed CMK in each Region for use with
  /// encryption by default. If you change the default CMK to a customer managed
  /// CMK, it is used instead of the AWS managed CMK. To reset the default CMK
  /// to the AWS managed CMK for EBS, use ResetEbsDefaultKmsKeyId.
  ///
  /// If you delete or disable the customer managed CMK that you specified for
  /// use with encryption by default, your instances will fail to launch.
  ///
  /// For more information, see
  /// [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [kmsKeyId]: The identifier of the AWS Key Management Service (AWS KMS)
  /// customer master key (CMK) to use for Amazon EBS encryption. If this
  /// parameter is not specified, your AWS managed CMK for EBS is used. If
  /// `KmsKeyId` is specified, the encrypted state must be `true`.
  ///
  /// You can specify the CMK using any of the following:
  ///
  /// *   Key ID. For example, key/1234abcd-12ab-34cd-56ef-1234567890ab.
  ///
  /// *   Key alias. For example, alias/ExampleAlias.
  ///
  /// *   Key ARN. For example,
  /// arn:aws:kms:_us-east-1_:_012345678910_:key/_abcd1234-a123-456a-a12b-a123b4cd56ef_.
  ///
  /// *   Alias ARN. For example,
  /// arn:aws:kms:_us-east-1_:_012345678910_:alias/_ExampleAlias_.
  ///
  ///
  /// AWS authenticates the CMK asynchronously. Therefore, if you specify an ID,
  /// alias, or ARN that is not valid, the action can appear to complete, but
  /// eventually fails.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ModifyEbsDefaultKmsKeyIdResult> modifyEbsDefaultKmsKeyId(
      String kmsKeyId,
      {bool dryRun}) async {
    var response_ = await _client.send('ModifyEbsDefaultKmsKeyId', {
      'KmsKeyId': kmsKeyId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ModifyEbsDefaultKmsKeyIdResult.fromJson(response_);
  }

  /// Modifies the specified EC2 Fleet.
  ///
  /// You can only modify an EC2 Fleet request of type `maintain`.
  ///
  /// While the EC2 Fleet is being modified, it is in the `modifying` state.
  ///
  /// To scale up your EC2 Fleet, increase its target capacity. The EC2 Fleet
  /// launches the additional Spot Instances according to the allocation
  /// strategy for the EC2 Fleet request. If the allocation strategy is
  /// `lowestPrice`, the EC2 Fleet launches instances using the Spot Instance
  /// pool with the lowest price. If the allocation strategy is `diversified`,
  /// the EC2 Fleet distributes the instances across the Spot Instance pools. If
  /// the allocation strategy is `capacityOptimized`, EC2 Fleet launches
  /// instances from Spot Instance pools with optimal capacity for the number of
  /// instances that are launching.
  ///
  /// To scale down your EC2 Fleet, decrease its target capacity. First, the EC2
  /// Fleet cancels any open requests that exceed the new target capacity. You
  /// can request that the EC2 Fleet terminate Spot Instances until the size of
  /// the fleet no longer exceeds the new target capacity. If the allocation
  /// strategy is `lowestPrice`, the EC2 Fleet terminates the instances with the
  /// highest price per unit. If the allocation strategy is `capacityOptimized`,
  /// the EC2 Fleet terminates the instances in the Spot Instance pools that
  /// have the least available Spot Instance capacity. If the allocation
  /// strategy is `diversified`, the EC2 Fleet terminates instances across the
  /// Spot Instance pools. Alternatively, you can request that the EC2 Fleet
  /// keep the fleet at its current size, but not replace any Spot Instances
  /// that are interrupted or that you terminate manually.
  ///
  /// If you are finished with your EC2 Fleet for now, but will use it again
  /// later, you can set the target capacity to 0.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [excessCapacityTerminationPolicy]: Indicates whether running instances
  /// should be terminated if the total target capacity of the EC2 Fleet is
  /// decreased below the current size of the EC2 Fleet.
  ///
  /// [fleetId]: The ID of the EC2 Fleet.
  ///
  /// [targetCapacitySpecification]: The size of the EC2 Fleet.
  Future<ModifyFleetResult> modifyFleet(
      {bool dryRun,
      String excessCapacityTerminationPolicy,
      @required
          String fleetId,
      @required
          TargetCapacitySpecificationRequest
              targetCapacitySpecification}) async {
    var response_ = await _client.send('ModifyFleet', {
      if (dryRun != null) 'DryRun': dryRun,
      if (excessCapacityTerminationPolicy != null)
        'ExcessCapacityTerminationPolicy': excessCapacityTerminationPolicy,
      'FleetId': fleetId,
      'TargetCapacitySpecification': targetCapacitySpecification,
    });
    return ModifyFleetResult.fromJson(response_);
  }

  /// Modifies the specified attribute of the specified Amazon FPGA Image (AFI).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [fpgaImageId]: The ID of the AFI.
  ///
  /// [attribute]: The name of the attribute.
  ///
  /// [operationType]: The operation type.
  ///
  /// [userIds]: The AWS account IDs. This parameter is valid only when
  /// modifying the `loadPermission` attribute.
  ///
  /// [userGroups]: The user groups. This parameter is valid only when modifying
  /// the `loadPermission` attribute.
  ///
  /// [productCodes]: The product codes. After you add a product code to an AFI,
  /// it can't be removed. This parameter is valid only when modifying the
  /// `productCodes` attribute.
  ///
  /// [loadPermission]: The load permission for the AFI.
  ///
  /// [description]: A description for the AFI.
  ///
  /// [name]: A name for the AFI.
  Future<ModifyFpgaImageAttributeResult> modifyFpgaImageAttribute(
      String fpgaImageId,
      {bool dryRun,
      String attribute,
      String operationType,
      List<String> userIds,
      List<String> userGroups,
      List<String> productCodes,
      LoadPermissionModifications loadPermission,
      String description,
      String name}) async {
    var response_ = await _client.send('ModifyFpgaImageAttribute', {
      if (dryRun != null) 'DryRun': dryRun,
      'FpgaImageId': fpgaImageId,
      if (attribute != null) 'Attribute': attribute,
      if (operationType != null) 'OperationType': operationType,
      if (userIds != null) 'UserIds': userIds,
      if (userGroups != null) 'UserGroups': userGroups,
      if (productCodes != null) 'ProductCodes': productCodes,
      if (loadPermission != null) 'LoadPermission': loadPermission,
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
    });
    return ModifyFpgaImageAttributeResult.fromJson(response_);
  }

  /// Modify the auto-placement setting of a Dedicated Host. When auto-placement
  /// is enabled, any instances that you launch with a tenancy of `host` but
  /// without a specific host ID are placed onto any available Dedicated Host in
  /// your account that has auto-placement enabled. When auto-placement is
  /// disabled, you need to provide a host ID to have the instance launch onto a
  /// specific host. If no host ID is provided, the instance is launched onto a
  /// suitable host with auto-placement enabled.
  ///
  /// [autoPlacement]: Specify whether to enable or disable auto-placement.
  ///
  /// [hostIds]: The IDs of the Dedicated Hosts to modify.
  ///
  /// [hostRecovery]: Indicates whether to enable or disable host recovery for
  /// the Dedicated Host. For more information, see
  /// [Host Recovery](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-recovery.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  Future<ModifyHostsResult> modifyHosts(List<String> hostIds,
      {String autoPlacement, String hostRecovery}) async {
    var response_ = await _client.send('ModifyHosts', {
      if (autoPlacement != null) 'AutoPlacement': autoPlacement,
      'HostIds': hostIds,
      if (hostRecovery != null) 'HostRecovery': hostRecovery,
    });
    return ModifyHostsResult.fromJson(response_);
  }

  /// Modifies the ID format for the specified resource on a per-Region basis.
  /// You can specify that resources should receive longer IDs (17-character
  /// IDs) when they are created.
  ///
  /// This request can only be used to modify longer ID settings for resource
  /// types that are within the opt-in period. Resources currently in their
  /// opt-in period include: `bundle` | `conversion-task` | `customer-gateway` |
  /// `dhcp-options` | `elastic-ip-allocation` | `elastic-ip-association` |
  /// `export-task` | `flow-log` | `image` | `import-task` | `internet-gateway`
  /// | `network-acl` | `network-acl-association` | `network-interface` |
  /// `network-interface-attachment` | `prefix-list` | `route-table` |
  /// `route-table-association` | `security-group` | `subnet` |
  /// `subnet-cidr-block-association` | `vpc` | `vpc-cidr-block-association` |
  /// `vpc-endpoint` | `vpc-peering-connection` | `vpn-connection` |
  /// `vpn-gateway`.
  ///
  /// This setting applies to the IAM user who makes the request; it does not
  /// apply to the entire AWS account. By default, an IAM user defaults to the
  /// same settings as the root user. If you're using this action as the root
  /// user, then these settings apply to the entire account, unless an IAM user
  /// explicitly overrides these settings for themselves. For more information,
  /// see
  /// [Resource IDs](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/resource-ids.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// Resources created with longer IDs are visible to all IAM roles and users,
  /// regardless of these settings and provided that they have permission to use
  /// the relevant `Describe` command for the resource type.
  ///
  /// [resource]: The type of resource: `bundle` | `conversion-task` |
  /// `customer-gateway` | `dhcp-options` | `elastic-ip-allocation` |
  /// `elastic-ip-association` | `export-task` | `flow-log` | `image` |
  /// `import-task` | `internet-gateway` | `network-acl` |
  /// `network-acl-association` | `network-interface` |
  /// `network-interface-attachment` | `prefix-list` | `route-table` |
  /// `route-table-association` | `security-group` | `subnet` |
  /// `subnet-cidr-block-association` | `vpc` | `vpc-cidr-block-association` |
  /// `vpc-endpoint` | `vpc-peering-connection` | `vpn-connection` |
  /// `vpn-gateway`.
  ///
  /// Alternatively, use the `all-current` option to include all resource types
  /// that are currently within their opt-in period for longer IDs.
  ///
  /// [useLongIds]: Indicate whether the resource should use longer IDs
  /// (17-character IDs).
  Future<void> modifyIdFormat(
      {@required String resource, @required bool useLongIds}) async {
    await _client.send('ModifyIdFormat', {
      'Resource': resource,
      'UseLongIds': useLongIds,
    });
  }

  /// Modifies the ID format of a resource for a specified IAM user, IAM role,
  /// or the root user for an account; or all IAM users, IAM roles, and the root
  /// user for an account. You can specify that resources should receive longer
  /// IDs (17-character IDs) when they are created.
  ///
  /// This request can only be used to modify longer ID settings for resource
  /// types that are within the opt-in period. Resources currently in their
  /// opt-in period include: `bundle` | `conversion-task` | `customer-gateway` |
  /// `dhcp-options` | `elastic-ip-allocation` | `elastic-ip-association` |
  /// `export-task` | `flow-log` | `image` | `import-task` | `internet-gateway`
  /// | `network-acl` | `network-acl-association` | `network-interface` |
  /// `network-interface-attachment` | `prefix-list` | `route-table` |
  /// `route-table-association` | `security-group` | `subnet` |
  /// `subnet-cidr-block-association` | `vpc` | `vpc-cidr-block-association` |
  /// `vpc-endpoint` | `vpc-peering-connection` | `vpn-connection` |
  /// `vpn-gateway`.
  ///
  /// For more information, see
  /// [Resource IDs](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/resource-ids.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// This setting applies to the principal specified in the request; it does
  /// not apply to the principal that makes the request.
  ///
  /// Resources created with longer IDs are visible to all IAM roles and users,
  /// regardless of these settings and provided that they have permission to use
  /// the relevant `Describe` command for the resource type.
  ///
  /// [principalArn]: The ARN of the principal, which can be an IAM user, IAM
  /// role, or the root user. Specify `all` to modify the ID format for all IAM
  /// users, IAM roles, and the root user of the account.
  ///
  /// [resource]: The type of resource: `bundle` | `conversion-task` |
  /// `customer-gateway` | `dhcp-options` | `elastic-ip-allocation` |
  /// `elastic-ip-association` | `export-task` | `flow-log` | `image` |
  /// `import-task` | `internet-gateway` | `network-acl` |
  /// `network-acl-association` | `network-interface` |
  /// `network-interface-attachment` | `prefix-list` | `route-table` |
  /// `route-table-association` | `security-group` | `subnet` |
  /// `subnet-cidr-block-association` | `vpc` | `vpc-cidr-block-association` |
  /// `vpc-endpoint` | `vpc-peering-connection` | `vpn-connection` |
  /// `vpn-gateway`.
  ///
  /// Alternatively, use the `all-current` option to include all resource types
  /// that are currently within their opt-in period for longer IDs.
  ///
  /// [useLongIds]: Indicates whether the resource should use longer IDs
  /// (17-character IDs)
  Future<void> modifyIdentityIdFormat(
      {@required String principalArn,
      @required String resource,
      @required bool useLongIds}) async {
    await _client.send('ModifyIdentityIdFormat', {
      'PrincipalArn': principalArn,
      'Resource': resource,
      'UseLongIds': useLongIds,
    });
  }

  /// Modifies the specified attribute of the specified AMI. You can specify
  /// only one attribute at a time. You can use the `Attribute` parameter to
  /// specify the attribute or one of the following parameters: `Description`,
  /// `LaunchPermission`, or `ProductCode`.
  ///
  /// AWS Marketplace product codes cannot be modified. Images with an AWS
  /// Marketplace product code cannot be made public.
  ///
  /// To enable the SriovNetSupport enhanced networking attribute of an image,
  /// enable SriovNetSupport on an instance and create an AMI from the instance.
  ///
  /// [attribute]: The name of the attribute to modify. The valid values are
  /// `description`, `launchPermission`, and `productCodes`.
  ///
  /// [description]: A new description for the AMI.
  ///
  /// [imageId]: The ID of the AMI.
  ///
  /// [launchPermission]: A new launch permission for the AMI.
  ///
  /// [operationType]: The operation type. This parameter can be used only when
  /// the `Attribute` parameter is `launchPermission`.
  ///
  /// [productCodes]: The DevPay product codes. After you add a product code to
  /// an AMI, it can't be removed.
  ///
  /// [userGroups]: The user groups. This parameter can be used only when the
  /// `Attribute` parameter is `launchPermission`.
  ///
  /// [userIds]: The AWS account IDs. This parameter can be used only when the
  /// `Attribute` parameter is `launchPermission`.
  ///
  /// [value]: The value of the attribute being modified. This parameter can be
  /// used only when the `Attribute` parameter is `description` or
  /// `productCodes`.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> modifyImageAttribute(String imageId,
      {String attribute,
      AttributeValue description,
      LaunchPermissionModifications launchPermission,
      String operationType,
      List<String> productCodes,
      List<String> userGroups,
      List<String> userIds,
      String value,
      bool dryRun}) async {
    await _client.send('ModifyImageAttribute', {
      if (attribute != null) 'Attribute': attribute,
      if (description != null) 'Description': description,
      'ImageId': imageId,
      if (launchPermission != null) 'LaunchPermission': launchPermission,
      if (operationType != null) 'OperationType': operationType,
      if (productCodes != null) 'ProductCodes': productCodes,
      if (userGroups != null) 'UserGroups': userGroups,
      if (userIds != null) 'UserIds': userIds,
      if (value != null) 'Value': value,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Modifies the specified attribute of the specified instance. You can
  /// specify only one attribute at a time.
  ///
  ///  **Note:** Using this action to change the security groups associated with
  /// an elastic network interface (ENI) attached to an instance in a VPC can
  /// result in an error if the instance has more than one ENI. To change the
  /// security groups associated with an ENI attached to an instance that has
  /// multiple ENIs, we recommend that you use the
  /// ModifyNetworkInterfaceAttribute action.
  ///
  /// To modify some attributes, the instance must be stopped. For more
  /// information, see
  /// [Modifying Attributes of a Stopped Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_ChangingAttributesWhileInstanceStopped.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [sourceDestCheck]: Specifies whether source/destination checking is
  /// enabled. A value of `true` means that checking is enabled, and `false`
  /// means that checking is disabled. This value must be `false` for a NAT
  /// instance to perform NAT.
  ///
  /// [attribute]: The name of the attribute.
  ///
  /// [blockDeviceMappings]: Modifies the `DeleteOnTermination` attribute for
  /// volumes that are currently attached. The volume must be owned by the
  /// caller. If no value is specified for `DeleteOnTermination`, the default is
  /// `true` and the volume is deleted when the instance is terminated.
  ///
  /// To add instance store volumes to an Amazon EBS-backed instance, you must
  /// add them when you launch the instance. For more information, see
  /// [Updating the Block Device Mapping when Launching an Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html#Using_OverridingAMIBDM)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [disableApiTermination]: If the value is `true`, you can't terminate the
  /// instance using the Amazon EC2 console, CLI, or API; otherwise, you can.
  /// You cannot use this parameter for Spot Instances.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [ebsOptimized]: Specifies whether the instance is optimized for Amazon EBS
  /// I/O. This optimization provides dedicated throughput to Amazon EBS and an
  /// optimized configuration stack to provide optimal EBS I/O performance. This
  /// optimization isn't available with all instance types. Additional usage
  /// charges apply when using an EBS Optimized instance.
  ///
  /// [enaSupport]: Set to `true` to enable enhanced networking with ENA for the
  /// instance.
  ///
  /// This option is supported only for HVM instances. Specifying this option
  /// with a PV instance can make it unreachable.
  ///
  /// [groups]: [EC2-VPC] Changes the security groups of the instance. You must
  /// specify at least one security group, even if it's just the default
  /// security group for the VPC. You must specify the security group ID, not
  /// the security group name.
  ///
  /// [instanceId]: The ID of the instance.
  ///
  /// [instanceInitiatedShutdownBehavior]: Specifies whether an instance stops
  /// or terminates when you initiate shutdown from the instance (using the
  /// operating system command for system shutdown).
  ///
  /// [instanceType]: Changes the instance type to the specified value. For more
  /// information, see
  /// [Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html).
  /// If the instance type is not valid, the error returned is
  /// `InvalidInstanceAttributeValue`.
  ///
  /// [kernel]: Changes the instance's kernel to the specified value. We
  /// recommend that you use PV-GRUB instead of kernels and RAM disks. For more
  /// information, see
  /// [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedKernels.html).
  ///
  /// [ramdisk]: Changes the instance's RAM disk to the specified value. We
  /// recommend that you use PV-GRUB instead of kernels and RAM disks. For more
  /// information, see
  /// [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedKernels.html).
  ///
  /// [sriovNetSupport]: Set to `simple` to enable enhanced networking with the
  /// Intel 82599 Virtual Function interface for the instance.
  ///
  /// There is no way to disable enhanced networking with the Intel 82599
  /// Virtual Function interface at this time.
  ///
  /// This option is supported only for HVM instances. Specifying this option
  /// with a PV instance can make it unreachable.
  ///
  /// [userData]: Changes the instance's user data to the specified value. If
  /// you are using an AWS SDK or command line tool, base64-encoding is
  /// performed for you, and you can load the text from a file. Otherwise, you
  /// must provide base64-encoded text.
  ///
  /// [value]: A new value for the attribute. Use only with the `kernel`,
  /// `ramdisk`, `userData`, `disableApiTermination`, or
  /// `instanceInitiatedShutdownBehavior` attribute.
  Future<void> modifyInstanceAttribute(String instanceId,
      {AttributeBooleanValue sourceDestCheck,
      String attribute,
      List<InstanceBlockDeviceMappingSpecification> blockDeviceMappings,
      AttributeBooleanValue disableApiTermination,
      bool dryRun,
      AttributeBooleanValue ebsOptimized,
      AttributeBooleanValue enaSupport,
      List<String> groups,
      AttributeValue instanceInitiatedShutdownBehavior,
      AttributeValue instanceType,
      AttributeValue kernel,
      AttributeValue ramdisk,
      AttributeValue sriovNetSupport,
      BlobAttributeValue userData,
      String value}) async {
    await _client.send('ModifyInstanceAttribute', {
      if (sourceDestCheck != null) 'SourceDestCheck': sourceDestCheck,
      if (attribute != null) 'Attribute': attribute,
      if (blockDeviceMappings != null)
        'BlockDeviceMappings': blockDeviceMappings,
      if (disableApiTermination != null)
        'DisableApiTermination': disableApiTermination,
      if (dryRun != null) 'DryRun': dryRun,
      if (ebsOptimized != null) 'EbsOptimized': ebsOptimized,
      if (enaSupport != null) 'EnaSupport': enaSupport,
      if (groups != null) 'Groups': groups,
      'InstanceId': instanceId,
      if (instanceInitiatedShutdownBehavior != null)
        'InstanceInitiatedShutdownBehavior': instanceInitiatedShutdownBehavior,
      if (instanceType != null) 'InstanceType': instanceType,
      if (kernel != null) 'Kernel': kernel,
      if (ramdisk != null) 'Ramdisk': ramdisk,
      if (sriovNetSupport != null) 'SriovNetSupport': sriovNetSupport,
      if (userData != null) 'UserData': userData,
      if (value != null) 'Value': value,
    });
  }

  /// Modifies the Capacity Reservation settings for a stopped instance. Use
  /// this action to configure an instance to target a specific Capacity
  /// Reservation, run in any `open` Capacity Reservation with matching
  /// attributes, or run On-Demand Instance capacity.
  ///
  /// [instanceId]: The ID of the instance to be modified.
  ///
  /// [capacityReservationSpecification]: Information about the Capacity
  /// Reservation targeting option.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ModifyInstanceCapacityReservationAttributesResult>
      modifyInstanceCapacityReservationAttributes(
          {@required
              String instanceId,
          @required
              CapacityReservationSpecification capacityReservationSpecification,
          bool dryRun}) async {
    var response_ =
        await _client.send('ModifyInstanceCapacityReservationAttributes', {
      'InstanceId': instanceId,
      'CapacityReservationSpecification': capacityReservationSpecification,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ModifyInstanceCapacityReservationAttributesResult.fromJson(
        response_);
  }

  /// Modifies the credit option for CPU usage on a running or stopped T2 or T3
  /// instance. The credit options are `standard` and `unlimited`.
  ///
  /// For more information, see
  /// [Burstable Performance Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [clientToken]: A unique, case-sensitive token that you provide to ensure
  /// idempotency of your modification request. For more information, see
  /// [Ensuring Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// [instanceCreditSpecifications]: Information about the credit option for
  /// CPU usage.
  Future<ModifyInstanceCreditSpecificationResult>
      modifyInstanceCreditSpecification(
          List<InstanceCreditSpecificationRequest> instanceCreditSpecifications,
          {bool dryRun,
          String clientToken}) async {
    var response_ = await _client.send('ModifyInstanceCreditSpecification', {
      if (dryRun != null) 'DryRun': dryRun,
      if (clientToken != null) 'ClientToken': clientToken,
      'InstanceCreditSpecifications': instanceCreditSpecifications,
    });
    return ModifyInstanceCreditSpecificationResult.fromJson(response_);
  }

  /// Modifies the start time for a scheduled Amazon EC2 instance event.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [instanceId]: The ID of the instance with the scheduled event.
  ///
  /// [instanceEventId]: The ID of the event whose date and time you are
  /// modifying.
  ///
  /// [notBefore]: The new date and time when the event will take place.
  Future<ModifyInstanceEventStartTimeResult> modifyInstanceEventStartTime(
      {bool dryRun,
      @required String instanceId,
      @required String instanceEventId,
      @required DateTime notBefore}) async {
    var response_ = await _client.send('ModifyInstanceEventStartTime', {
      if (dryRun != null) 'DryRun': dryRun,
      'InstanceId': instanceId,
      'InstanceEventId': instanceEventId,
      'NotBefore': notBefore,
    });
    return ModifyInstanceEventStartTimeResult.fromJson(response_);
  }

  /// Modifies the placement attributes for a specified instance. You can do the
  /// following:
  ///
  /// *   Modify the affinity between an instance and a
  /// [Dedicated Host](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-overview.html).
  /// When affinity is set to `host` and the instance is not associated with a
  /// specific Dedicated Host, the next time the instance is launched, it is
  /// automatically associated with the host on which it lands. If the instance
  /// is restarted or rebooted, this relationship persists.
  ///
  /// *   Change the Dedicated Host with which an instance is associated.
  ///
  /// *   Change the instance tenancy of an instance from `host` to `dedicated`,
  /// or from `dedicated` to `host`.
  ///
  /// *   Move an instance to or from a
  /// [placement group](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html).
  ///
  ///
  /// At least one attribute for affinity, host ID, tenancy, or placement group
  /// name must be specified in the request. Affinity and tenancy can be
  /// modified in the same request.
  ///
  /// To modify the host ID, tenancy, placement group, or partition for an
  /// instance, the instance must be in the `stopped` state.
  ///
  /// [affinity]: The affinity setting for the instance.
  ///
  /// [groupName]: The name of the placement group in which to place the
  /// instance. For spread placement groups, the instance must have a tenancy of
  /// `default`. For cluster and partition placement groups, the instance must
  /// have a tenancy of `default` or `dedicated`.
  ///
  /// To remove an instance from a placement group, specify an empty string
  /// ("").
  ///
  /// [hostId]: The ID of the Dedicated Host with which to associate the
  /// instance.
  ///
  /// [instanceId]: The ID of the instance that you are modifying.
  ///
  /// [tenancy]: The tenancy for the instance.
  ///
  /// [partitionNumber]: Reserved for future use.
  Future<ModifyInstancePlacementResult> modifyInstancePlacement(
      String instanceId,
      {String affinity,
      String groupName,
      String hostId,
      String tenancy,
      int partitionNumber}) async {
    var response_ = await _client.send('ModifyInstancePlacement', {
      if (affinity != null) 'Affinity': affinity,
      if (groupName != null) 'GroupName': groupName,
      if (hostId != null) 'HostId': hostId,
      'InstanceId': instanceId,
      if (tenancy != null) 'Tenancy': tenancy,
      if (partitionNumber != null) 'PartitionNumber': partitionNumber,
    });
    return ModifyInstancePlacementResult.fromJson(response_);
  }

  /// Modifies a launch template. You can specify which version of the launch
  /// template to set as the default version. When launching an instance, the
  /// default version applies when a launch template version is not specified.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [clientToken]: Unique, case-sensitive identifier you provide to ensure the
  /// idempotency of the request. For more information, see
  /// [Ensuring Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// Constraint: Maximum 128 ASCII characters.
  ///
  /// [launchTemplateId]: The ID of the launch template. You must specify either
  /// the launch template ID or launch template name in the request.
  ///
  /// [launchTemplateName]: The name of the launch template. You must specify
  /// either the launch template ID or launch template name in the request.
  ///
  /// [defaultVersion]: The version number of the launch template to set as the
  /// default version.
  Future<ModifyLaunchTemplateResult> modifyLaunchTemplate(
      {bool dryRun,
      String clientToken,
      String launchTemplateId,
      String launchTemplateName,
      String defaultVersion}) async {
    var response_ = await _client.send('ModifyLaunchTemplate', {
      if (dryRun != null) 'DryRun': dryRun,
      if (clientToken != null) 'ClientToken': clientToken,
      if (launchTemplateId != null) 'LaunchTemplateId': launchTemplateId,
      if (launchTemplateName != null) 'LaunchTemplateName': launchTemplateName,
      if (defaultVersion != null) 'DefaultVersion': defaultVersion,
    });
    return ModifyLaunchTemplateResult.fromJson(response_);
  }

  /// Modifies the specified network interface attribute. You can specify only
  /// one attribute at a time. You can use this action to attach and detach
  /// security groups from an existing EC2 instance.
  ///
  /// [attachment]: Information about the interface attachment. If modifying the
  /// 'delete on termination' attribute, you must specify the ID of the
  /// interface attachment.
  ///
  /// [description]: A description for the network interface.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [groups]: Changes the security groups for the network interface. The new
  /// set of groups you specify replaces the current set. You must specify at
  /// least one group, even if it's just the default security group in the VPC.
  /// You must specify the ID of the security group, not the name.
  ///
  /// [networkInterfaceId]: The ID of the network interface.
  ///
  /// [sourceDestCheck]: Indicates whether source/destination checking is
  /// enabled. A value of `true` means checking is enabled, and `false` means
  /// checking is disabled. This value must be `false` for a NAT instance to
  /// perform NAT. For more information, see
  /// [NAT Instances](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_NAT_Instance.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  Future<void> modifyNetworkInterfaceAttribute(String networkInterfaceId,
      {NetworkInterfaceAttachmentChanges attachment,
      AttributeValue description,
      bool dryRun,
      List<String> groups,
      AttributeBooleanValue sourceDestCheck}) async {
    await _client.send('ModifyNetworkInterfaceAttribute', {
      if (attachment != null) 'Attachment': attachment,
      if (description != null) 'Description': description,
      if (dryRun != null) 'DryRun': dryRun,
      if (groups != null) 'Groups': groups,
      'NetworkInterfaceId': networkInterfaceId,
      if (sourceDestCheck != null) 'SourceDestCheck': sourceDestCheck,
    });
  }

  /// Modifies the Availability Zone, instance count, instance type, or network
  /// platform (EC2-Classic or EC2-VPC) of your Reserved Instances. The Reserved
  /// Instances to be modified must be identical, except for Availability Zone,
  /// network platform, and instance type.
  ///
  /// For more information, see
  /// [Modifying Reserved Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-modifying.html)
  /// in the Amazon Elastic Compute Cloud User Guide.
  ///
  /// [reservedInstancesIds]: The IDs of the Reserved Instances to modify.
  ///
  /// [clientToken]: A unique, case-sensitive token you provide to ensure
  /// idempotency of your modification request. For more information, see
  /// [Ensuring Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// [targetConfigurations]: The configuration settings for the Reserved
  /// Instances to modify.
  Future<ModifyReservedInstancesResult> modifyReservedInstances(
      {@required
          List<String> reservedInstancesIds,
      String clientToken,
      @required
          List<ReservedInstancesConfiguration> targetConfigurations}) async {
    var response_ = await _client.send('ModifyReservedInstances', {
      'ReservedInstancesIds': reservedInstancesIds,
      if (clientToken != null) 'ClientToken': clientToken,
      'TargetConfigurations': targetConfigurations,
    });
    return ModifyReservedInstancesResult.fromJson(response_);
  }

  /// Adds or removes permission settings for the specified snapshot. You may
  /// add or remove specified AWS account IDs from a snapshot's list of create
  /// volume permissions, but you cannot do both in a single operation. If you
  /// need to both add and remove account IDs for a snapshot, you must use
  /// multiple operations. You can make up to 500 modifications to a snapshot in
  /// a single operation.
  ///
  /// Encrypted snapshots and snapshots with AWS Marketplace product codes
  /// cannot be made public. Snapshots encrypted with your default CMK cannot be
  /// shared with other accounts.
  ///
  /// For more information about modifying snapshot permissions, see
  /// [Sharing Snapshots](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-modifying-snapshot-permissions.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [attribute]: The snapshot attribute to modify. Only volume creation
  /// permissions can be modified.
  ///
  /// [createVolumePermission]: A JSON representation of the snapshot attribute
  /// modification.
  ///
  /// [groupNames]: The group to modify for the snapshot.
  ///
  /// [operationType]: The type of operation to perform to the attribute.
  ///
  /// [snapshotId]: The ID of the snapshot.
  ///
  /// [userIds]: The account ID to modify for the snapshot.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> modifySnapshotAttribute(String snapshotId,
      {String attribute,
      CreateVolumePermissionModifications createVolumePermission,
      List<String> groupNames,
      String operationType,
      List<String> userIds,
      bool dryRun}) async {
    await _client.send('ModifySnapshotAttribute', {
      if (attribute != null) 'Attribute': attribute,
      if (createVolumePermission != null)
        'CreateVolumePermission': createVolumePermission,
      if (groupNames != null) 'GroupNames': groupNames,
      if (operationType != null) 'OperationType': operationType,
      'SnapshotId': snapshotId,
      if (userIds != null) 'UserIds': userIds,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Modifies the specified Spot Fleet request.
  ///
  /// You can only modify a Spot Fleet request of type `maintain`.
  ///
  /// While the Spot Fleet request is being modified, it is in the `modifying`
  /// state.
  ///
  /// To scale up your Spot Fleet, increase its target capacity. The Spot Fleet
  /// launches the additional Spot Instances according to the allocation
  /// strategy for the Spot Fleet request. If the allocation strategy is
  /// `lowestPrice`, the Spot Fleet launches instances using the Spot Instance
  /// pool with the lowest price. If the allocation strategy is `diversified`,
  /// the Spot Fleet distributes the instances across the Spot Instance pools.
  /// If the allocation strategy is `capacityOptimized`, Spot Fleet launches
  /// instances from Spot Instance pools with optimal capacity for the number of
  /// instances that are launching.
  ///
  /// To scale down your Spot Fleet, decrease its target capacity. First, the
  /// Spot Fleet cancels any open requests that exceed the new target capacity.
  /// You can request that the Spot Fleet terminate Spot Instances until the
  /// size of the fleet no longer exceeds the new target capacity. If the
  /// allocation strategy is `lowestPrice`, the Spot Fleet terminates the
  /// instances with the highest price per unit. If the allocation strategy is
  /// `capacityOptimized`, the Spot Fleet terminates the instances in the Spot
  /// Instance pools that have the least available Spot Instance capacity. If
  /// the allocation strategy is `diversified`, the Spot Fleet terminates
  /// instances across the Spot Instance pools. Alternatively, you can request
  /// that the Spot Fleet keep the fleet at its current size, but not replace
  /// any Spot Instances that are interrupted or that you terminate manually.
  ///
  /// If you are finished with your Spot Fleet for now, but will use it again
  /// later, you can set the target capacity to 0.
  ///
  /// [excessCapacityTerminationPolicy]: Indicates whether running Spot
  /// Instances should be terminated if the target capacity of the Spot Fleet
  /// request is decreased below the current size of the Spot Fleet.
  ///
  /// [spotFleetRequestId]: The ID of the Spot Fleet request.
  ///
  /// [targetCapacity]: The size of the fleet.
  ///
  /// [onDemandTargetCapacity]: The number of On-Demand Instances in the fleet.
  Future<ModifySpotFleetRequestResponse> modifySpotFleetRequest(
      String spotFleetRequestId,
      {String excessCapacityTerminationPolicy,
      int targetCapacity,
      int onDemandTargetCapacity}) async {
    var response_ = await _client.send('ModifySpotFleetRequest', {
      if (excessCapacityTerminationPolicy != null)
        'ExcessCapacityTerminationPolicy': excessCapacityTerminationPolicy,
      'SpotFleetRequestId': spotFleetRequestId,
      if (targetCapacity != null) 'TargetCapacity': targetCapacity,
      if (onDemandTargetCapacity != null)
        'OnDemandTargetCapacity': onDemandTargetCapacity,
    });
    return ModifySpotFleetRequestResponse.fromJson(response_);
  }

  /// Modifies a subnet attribute. You can only modify one attribute at a time.
  ///
  /// [assignIpv6AddressOnCreation]: Specify `true` to indicate that network
  /// interfaces created in the specified subnet should be assigned an IPv6
  /// address. This includes a network interface that's created when launching
  /// an instance into the subnet (the instance therefore receives an IPv6
  /// address).
  ///
  /// If you enable the IPv6 addressing feature for your subnet, your network
  /// interface or instance only receives an IPv6 address if it's created using
  /// version `2016-11-15` or later of the Amazon EC2 API.
  ///
  /// [mapPublicIpOnLaunch]: Specify `true` to indicate that ENIs attached to
  /// instances created in the specified subnet should be assigned a public IPv4
  /// address.
  ///
  /// [subnetId]: The ID of the subnet.
  Future<void> modifySubnetAttribute(String subnetId,
      {AttributeBooleanValue assignIpv6AddressOnCreation,
      AttributeBooleanValue mapPublicIpOnLaunch}) async {
    await _client.send('ModifySubnetAttribute', {
      if (assignIpv6AddressOnCreation != null)
        'AssignIpv6AddressOnCreation': assignIpv6AddressOnCreation,
      if (mapPublicIpOnLaunch != null)
        'MapPublicIpOnLaunch': mapPublicIpOnLaunch,
      'SubnetId': subnetId,
    });
  }

  /// Allows or restricts mirroring network services.
  ///
  ///  By default, Amazon DNS network services are not eligible for Traffic
  /// Mirror. Use `AddNetworkServices` to add network services to a Traffic
  /// Mirror filter. When a network service is added to the Traffic Mirror
  /// filter, all traffic related to that network service will be mirrored. When
  /// you no longer want to mirror network services, use `RemoveNetworkServices`
  /// to remove the network services from the Traffic Mirror filter.
  ///
  /// FFor information about filter rule properties, see
  /// [Network Services](https://docs.aws.amazon.com/vpc/latest/mirroring/traffic-mirroring-considerations.html#traffic-mirroring-network-services)
  /// in the _Traffic Mirroring User Guide_ .
  ///
  /// [trafficMirrorFilterId]: The ID of the Traffic Mirror filter.
  ///
  /// [addNetworkServices]: The network service, for example Amazon DNS, that
  /// you want to mirror.
  ///
  /// [removeNetworkServices]: The network service, for example Amazon DNS, that
  /// you no longer want to mirror.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ModifyTrafficMirrorFilterNetworkServicesResult>
      modifyTrafficMirrorFilterNetworkServices(String trafficMirrorFilterId,
          {List<String> addNetworkServices,
          List<String> removeNetworkServices,
          bool dryRun}) async {
    var response_ =
        await _client.send('ModifyTrafficMirrorFilterNetworkServices', {
      'TrafficMirrorFilterId': trafficMirrorFilterId,
      if (addNetworkServices != null) 'AddNetworkServices': addNetworkServices,
      if (removeNetworkServices != null)
        'RemoveNetworkServices': removeNetworkServices,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ModifyTrafficMirrorFilterNetworkServicesResult.fromJson(response_);
  }

  /// Modifies the specified Traffic Mirror rule.
  ///
  ///  `DestinationCidrBlock` and `SourceCidrBlock` must both be an IPv4 range
  /// or an IPv6 range.
  ///
  /// [trafficMirrorFilterRuleId]: The ID of the Traffic Mirror rule.
  ///
  /// [trafficDirection]: The type of traffic (`ingress` | `egress`) to assign
  /// to the rule.
  ///
  /// [ruleNumber]: The number of the Traffic Mirror rule. This number must be
  /// unique for each Traffic Mirror rule in a given direction. The rules are
  /// processed in ascending order by rule number.
  ///
  /// [ruleAction]: The action to assign to the rule.
  ///
  /// [destinationPortRange]: The destination ports that are associated with the
  /// Traffic Mirror rule.
  ///
  /// [sourcePortRange]: The port range to assign to the Traffic Mirror rule.
  ///
  /// [protocol]: The protocol, for example TCP, to assign to the Traffic Mirror
  /// rule.
  ///
  /// [destinationCidrBlock]: The destination CIDR block to assign to the
  /// Traffic Mirror rule.
  ///
  /// [sourceCidrBlock]: The source CIDR block to assign to the Traffic Mirror
  /// rule.
  ///
  /// [description]: The description to assign to the Traffic Mirror rule.
  ///
  /// [removeFields]: The properties that you want to remove from the Traffic
  /// Mirror filter rule.
  ///
  /// When you remove a property from a Traffic Mirror filter rule, the property
  /// is set to the default.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ModifyTrafficMirrorFilterRuleResult> modifyTrafficMirrorFilterRule(
      String trafficMirrorFilterRuleId,
      {String trafficDirection,
      int ruleNumber,
      String ruleAction,
      TrafficMirrorPortRangeRequest destinationPortRange,
      TrafficMirrorPortRangeRequest sourcePortRange,
      int protocol,
      String destinationCidrBlock,
      String sourceCidrBlock,
      String description,
      List<String> removeFields,
      bool dryRun}) async {
    var response_ = await _client.send('ModifyTrafficMirrorFilterRule', {
      'TrafficMirrorFilterRuleId': trafficMirrorFilterRuleId,
      if (trafficDirection != null) 'TrafficDirection': trafficDirection,
      if (ruleNumber != null) 'RuleNumber': ruleNumber,
      if (ruleAction != null) 'RuleAction': ruleAction,
      if (destinationPortRange != null)
        'DestinationPortRange': destinationPortRange,
      if (sourcePortRange != null) 'SourcePortRange': sourcePortRange,
      if (protocol != null) 'Protocol': protocol,
      if (destinationCidrBlock != null)
        'DestinationCidrBlock': destinationCidrBlock,
      if (sourceCidrBlock != null) 'SourceCidrBlock': sourceCidrBlock,
      if (description != null) 'Description': description,
      if (removeFields != null) 'RemoveFields': removeFields,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ModifyTrafficMirrorFilterRuleResult.fromJson(response_);
  }

  /// Modifies a Traffic Mirror session.
  ///
  /// [trafficMirrorSessionId]: The ID of the Traffic Mirror session.
  ///
  /// [trafficMirrorTargetId]: The Traffic Mirror target. The target must be in
  /// the same VPC as the source, or have a VPC peering connection with the
  /// source.
  ///
  /// [trafficMirrorFilterId]: The ID of the Traffic Mirror filter.
  ///
  /// [packetLength]: The number of bytes in each packet to mirror. These are
  /// bytes after the VXLAN header. To mirror a subset, set this to the length
  /// (in bytes) to mirror. For example, if you set this value to 100, then the
  /// first 100 bytes that meet the filter criteria are copied to the target. Do
  /// not specify this parameter when you want to mirror the entire packet.
  ///
  /// [sessionNumber]: The session number determines the order in which sessions
  /// are evaluated when an interface is used by multiple sessions. The first
  /// session with a matching filter is the one that mirrors the packets.
  ///
  /// Valid values are 1-32766.
  ///
  /// [virtualNetworkId]: The virtual network ID of the Traffic Mirror session.
  ///
  /// [description]: The description to assign to the Traffic Mirror session.
  ///
  /// [removeFields]: The properties that you want to remove from the Traffic
  /// Mirror session.
  ///
  /// When you remove a property from a Traffic Mirror session, the property is
  /// set to the default.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ModifyTrafficMirrorSessionResult> modifyTrafficMirrorSession(
      String trafficMirrorSessionId,
      {String trafficMirrorTargetId,
      String trafficMirrorFilterId,
      int packetLength,
      int sessionNumber,
      int virtualNetworkId,
      String description,
      List<String> removeFields,
      bool dryRun}) async {
    var response_ = await _client.send('ModifyTrafficMirrorSession', {
      'TrafficMirrorSessionId': trafficMirrorSessionId,
      if (trafficMirrorTargetId != null)
        'TrafficMirrorTargetId': trafficMirrorTargetId,
      if (trafficMirrorFilterId != null)
        'TrafficMirrorFilterId': trafficMirrorFilterId,
      if (packetLength != null) 'PacketLength': packetLength,
      if (sessionNumber != null) 'SessionNumber': sessionNumber,
      if (virtualNetworkId != null) 'VirtualNetworkId': virtualNetworkId,
      if (description != null) 'Description': description,
      if (removeFields != null) 'RemoveFields': removeFields,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ModifyTrafficMirrorSessionResult.fromJson(response_);
  }

  /// Modifies the specified VPC attachment.
  ///
  /// [transitGatewayAttachmentId]: The ID of the attachment.
  ///
  /// [addSubnetIds]: The IDs of one or more subnets to add. You can specify at
  /// most one subnet per Availability Zone.
  ///
  /// [removeSubnetIds]: The IDs of one or more subnets to remove.
  ///
  /// [options]: The new VPC attachment options.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ModifyTransitGatewayVpcAttachmentResult>
      modifyTransitGatewayVpcAttachment(String transitGatewayAttachmentId,
          {List<String> addSubnetIds,
          List<String> removeSubnetIds,
          ModifyTransitGatewayVpcAttachmentRequestOptions options,
          bool dryRun}) async {
    var response_ = await _client.send('ModifyTransitGatewayVpcAttachment', {
      'TransitGatewayAttachmentId': transitGatewayAttachmentId,
      if (addSubnetIds != null) 'AddSubnetIds': addSubnetIds,
      if (removeSubnetIds != null) 'RemoveSubnetIds': removeSubnetIds,
      if (options != null) 'Options': options,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ModifyTransitGatewayVpcAttachmentResult.fromJson(response_);
  }

  /// You can modify several parameters of an existing EBS volume, including
  /// volume size, volume type, and IOPS capacity. If your EBS volume is
  /// attached to a current-generation EC2 instance type, you may be able to
  /// apply these changes without stopping the instance or detaching the volume
  /// from it. For more information about modifying an EBS volume running Linux,
  /// see
  /// [Modifying the Size, IOPS, or Type of an EBS Volume on Linux](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-expand-volume.html).
  /// For more information about modifying an EBS volume running Windows, see
  /// [Modifying the Size, IOPS, or Type of an EBS Volume on Windows](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ebs-expand-volume.html).
  ///
  ///  When you complete a resize operation on your volume, you need to extend
  /// the volume's file-system size to take advantage of the new storage
  /// capacity. For information about extending a Linux file system, see
  /// [Extending a Linux File System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-expand-volume.html#recognize-expanded-volume-linux).
  /// For information about extending a Windows file system, see
  /// [Extending a Windows File System](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ebs-expand-volume.html#recognize-expanded-volume-windows).
  ///
  ///  You can use CloudWatch Events to check the status of a modification to an
  /// EBS volume. For information about CloudWatch Events, see the
  /// [Amazon CloudWatch Events User Guide](https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/).
  /// You can also track the status of a modification using
  /// DescribeVolumesModifications. For information about tracking status
  /// changes using either method, see
  /// [Monitoring Volume Modifications](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-expand-volume.html#monitoring_mods).
  ///
  /// With previous-generation instance types, resizing an EBS volume may
  /// require detaching and reattaching the volume or stopping and restarting
  /// the instance. For more information, see
  /// [Modifying the Size, IOPS, or Type of an EBS Volume on Linux](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-expand-volume.html)
  /// and
  /// [Modifying the Size, IOPS, or Type of an EBS Volume on Windows](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ebs-expand-volume.html).
  ///
  /// If you reach the maximum volume modification rate per volume limit, you
  /// will need to wait at least six hours before applying further modifications
  /// to the affected EBS volume.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [volumeId]: The ID of the volume.
  ///
  /// [size]: The target size of the volume, in GiB. The target volume size must
  /// be greater than or equal to than the existing size of the volume. For
  /// information about available EBS volume sizes, see
  /// [Amazon EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
  ///
  /// Default: If no size is specified, the existing size is retained.
  ///
  /// [volumeType]: The target EBS volume type of the volume.
  ///
  /// Default: If no type is specified, the existing type is retained.
  ///
  /// [iops]: The target IOPS rate of the volume.
  ///
  /// This is only valid for Provisioned IOPS SSD (`io1`) volumes. For more
  /// information, see
  /// [Provisioned IOPS SSD (io1) Volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html#EBSVolumeTypes_piops).
  ///
  /// Default: If no IOPS value is specified, the existing value is retained.
  Future<ModifyVolumeResult> modifyVolume(String volumeId,
      {bool dryRun, int size, String volumeType, int iops}) async {
    var response_ = await _client.send('ModifyVolume', {
      if (dryRun != null) 'DryRun': dryRun,
      'VolumeId': volumeId,
      if (size != null) 'Size': size,
      if (volumeType != null) 'VolumeType': volumeType,
      if (iops != null) 'Iops': iops,
    });
    return ModifyVolumeResult.fromJson(response_);
  }

  /// Modifies a volume attribute.
  ///
  /// By default, all I/O operations for the volume are suspended when the data
  /// on the volume is determined to be potentially inconsistent, to prevent
  /// undetectable, latent data corruption. The I/O access to the volume can be
  /// resumed by first enabling I/O access and then checking the data
  /// consistency on your volume.
  ///
  /// You can change the default behavior to resume I/O operations. We recommend
  /// that you change this only for boot volumes or for volumes that are
  /// stateless or disposable.
  ///
  /// [autoEnableIO]: Indicates whether the volume should be auto-enabled for
  /// I/O operations.
  ///
  /// [volumeId]: The ID of the volume.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> modifyVolumeAttribute(String volumeId,
      {AttributeBooleanValue autoEnableIO, bool dryRun}) async {
    await _client.send('ModifyVolumeAttribute', {
      if (autoEnableIO != null) 'AutoEnableIO': autoEnableIO,
      'VolumeId': volumeId,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Modifies the specified attribute of the specified VPC.
  ///
  /// [enableDnsHostnames]: Indicates whether the instances launched in the VPC
  /// get DNS hostnames. If enabled, instances in the VPC get DNS hostnames;
  /// otherwise, they do not.
  ///
  /// You cannot modify the DNS resolution and DNS hostnames attributes in the
  /// same request. Use separate requests for each attribute. You can only
  /// enable DNS hostnames if you've enabled DNS support.
  ///
  /// [enableDnsSupport]: Indicates whether the DNS resolution is supported for
  /// the VPC. If enabled, queries to the Amazon provided DNS server at the
  /// 169.254.169.253 IP address, or the reserved IP address at the base of the
  /// VPC network range "plus two" succeed. If disabled, the Amazon provided DNS
  /// service in the VPC that resolves public DNS hostnames to IP addresses is
  /// not enabled.
  ///
  /// You cannot modify the DNS resolution and DNS hostnames attributes in the
  /// same request. Use separate requests for each attribute.
  ///
  /// [vpcId]: The ID of the VPC.
  Future<void> modifyVpcAttribute(String vpcId,
      {AttributeBooleanValue enableDnsHostnames,
      AttributeBooleanValue enableDnsSupport}) async {
    await _client.send('ModifyVpcAttribute', {
      if (enableDnsHostnames != null) 'EnableDnsHostnames': enableDnsHostnames,
      if (enableDnsSupport != null) 'EnableDnsSupport': enableDnsSupport,
      'VpcId': vpcId,
    });
  }

  /// Modifies attributes of a specified VPC endpoint. The attributes that you
  /// can modify depend on the type of VPC endpoint (interface or gateway). For
  /// more information, see
  /// [VPC Endpoints](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-endpoints.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [vpcEndpointId]: The ID of the endpoint.
  ///
  /// [resetPolicy]: (Gateway endpoint) Specify `true` to reset the policy
  /// document to the default policy. The default policy allows full access to
  /// the service.
  ///
  /// [policyDocument]: A policy to attach to the endpoint that controls access
  /// to the service. The policy must be in valid JSON format.
  ///
  /// [addRouteTableIds]: (Gateway endpoint) One or more route tables IDs to
  /// associate with the endpoint.
  ///
  /// [removeRouteTableIds]: (Gateway endpoint) One or more route table IDs to
  /// disassociate from the endpoint.
  ///
  /// [addSubnetIds]: (Interface endpoint) One or more subnet IDs in which to
  /// serve the endpoint.
  ///
  /// [removeSubnetIds]: (Interface endpoint) One or more subnets IDs in which
  /// to remove the endpoint.
  ///
  /// [addSecurityGroupIds]: (Interface endpoint) One or more security group IDs
  /// to associate with the network interface.
  ///
  /// [removeSecurityGroupIds]: (Interface endpoint) One or more security group
  /// IDs to disassociate from the network interface.
  ///
  /// [privateDnsEnabled]: (Interface endpoint) Indicate whether a private
  /// hosted zone is associated with the VPC.
  Future<ModifyVpcEndpointResult> modifyVpcEndpoint(String vpcEndpointId,
      {bool dryRun,
      bool resetPolicy,
      String policyDocument,
      List<String> addRouteTableIds,
      List<String> removeRouteTableIds,
      List<String> addSubnetIds,
      List<String> removeSubnetIds,
      List<String> addSecurityGroupIds,
      List<String> removeSecurityGroupIds,
      bool privateDnsEnabled}) async {
    var response_ = await _client.send('ModifyVpcEndpoint', {
      if (dryRun != null) 'DryRun': dryRun,
      'VpcEndpointId': vpcEndpointId,
      if (resetPolicy != null) 'ResetPolicy': resetPolicy,
      if (policyDocument != null) 'PolicyDocument': policyDocument,
      if (addRouteTableIds != null) 'AddRouteTableIds': addRouteTableIds,
      if (removeRouteTableIds != null)
        'RemoveRouteTableIds': removeRouteTableIds,
      if (addSubnetIds != null) 'AddSubnetIds': addSubnetIds,
      if (removeSubnetIds != null) 'RemoveSubnetIds': removeSubnetIds,
      if (addSecurityGroupIds != null)
        'AddSecurityGroupIds': addSecurityGroupIds,
      if (removeSecurityGroupIds != null)
        'RemoveSecurityGroupIds': removeSecurityGroupIds,
      if (privateDnsEnabled != null) 'PrivateDnsEnabled': privateDnsEnabled,
    });
    return ModifyVpcEndpointResult.fromJson(response_);
  }

  /// Modifies a connection notification for VPC endpoint or VPC endpoint
  /// service. You can change the SNS topic for the notification, or the events
  /// for which to be notified.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [connectionNotificationId]: The ID of the notification.
  ///
  /// [connectionNotificationArn]: The ARN for the SNS topic for the
  /// notification.
  ///
  /// [connectionEvents]: One or more events for the endpoint. Valid values are
  /// `Accept`, `Connect`, `Delete`, and `Reject`.
  Future<ModifyVpcEndpointConnectionNotificationResult>
      modifyVpcEndpointConnectionNotification(String connectionNotificationId,
          {bool dryRun,
          String connectionNotificationArn,
          List<String> connectionEvents}) async {
    var response_ =
        await _client.send('ModifyVpcEndpointConnectionNotification', {
      if (dryRun != null) 'DryRun': dryRun,
      'ConnectionNotificationId': connectionNotificationId,
      if (connectionNotificationArn != null)
        'ConnectionNotificationArn': connectionNotificationArn,
      if (connectionEvents != null) 'ConnectionEvents': connectionEvents,
    });
    return ModifyVpcEndpointConnectionNotificationResult.fromJson(response_);
  }

  /// Modifies the attributes of your VPC endpoint service configuration. You
  /// can change the Network Load Balancers for your service, and you can
  /// specify whether acceptance is required for requests to connect to your
  /// endpoint service through an interface VPC endpoint.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [serviceId]: The ID of the service.
  ///
  /// [acceptanceRequired]: Indicate whether requests to create an endpoint to
  /// your service must be accepted.
  ///
  /// [addNetworkLoadBalancerArns]: The Amazon Resource Names (ARNs) of Network
  /// Load Balancers to add to your service configuration.
  ///
  /// [removeNetworkLoadBalancerArns]: The Amazon Resource Names (ARNs) of
  /// Network Load Balancers to remove from your service configuration.
  Future<ModifyVpcEndpointServiceConfigurationResult>
      modifyVpcEndpointServiceConfiguration(String serviceId,
          {bool dryRun,
          bool acceptanceRequired,
          List<String> addNetworkLoadBalancerArns,
          List<String> removeNetworkLoadBalancerArns}) async {
    var response_ =
        await _client.send('ModifyVpcEndpointServiceConfiguration', {
      if (dryRun != null) 'DryRun': dryRun,
      'ServiceId': serviceId,
      if (acceptanceRequired != null) 'AcceptanceRequired': acceptanceRequired,
      if (addNetworkLoadBalancerArns != null)
        'AddNetworkLoadBalancerArns': addNetworkLoadBalancerArns,
      if (removeNetworkLoadBalancerArns != null)
        'RemoveNetworkLoadBalancerArns': removeNetworkLoadBalancerArns,
    });
    return ModifyVpcEndpointServiceConfigurationResult.fromJson(response_);
  }

  /// Modifies the permissions for your
  /// [VPC endpoint service](https://docs.aws.amazon.com/vpc/latest/userguide/endpoint-service.html).
  /// You can add or remove permissions for service consumers (IAM users, IAM
  /// roles, and AWS accounts) to connect to your endpoint service.
  ///
  /// If you grant permissions to all principals, the service is public. Any
  /// users who know the name of a public service can send a request to attach
  /// an endpoint. If the service does not require manual approval, attachments
  /// are automatically approved.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [serviceId]: The ID of the service.
  ///
  /// [addAllowedPrincipals]: The Amazon Resource Names (ARN) of one or more
  /// principals. Permissions are granted to the principals in this list. To
  /// grant permissions to all principals, specify an asterisk (*).
  ///
  /// [removeAllowedPrincipals]: The Amazon Resource Names (ARN) of one or more
  /// principals. Permissions are revoked for principals in this list.
  Future<ModifyVpcEndpointServicePermissionsResult>
      modifyVpcEndpointServicePermissions(String serviceId,
          {bool dryRun,
          List<String> addAllowedPrincipals,
          List<String> removeAllowedPrincipals}) async {
    var response_ = await _client.send('ModifyVpcEndpointServicePermissions', {
      if (dryRun != null) 'DryRun': dryRun,
      'ServiceId': serviceId,
      if (addAllowedPrincipals != null)
        'AddAllowedPrincipals': addAllowedPrincipals,
      if (removeAllowedPrincipals != null)
        'RemoveAllowedPrincipals': removeAllowedPrincipals,
    });
    return ModifyVpcEndpointServicePermissionsResult.fromJson(response_);
  }

  /// Modifies the VPC peering connection options on one side of a VPC peering
  /// connection. You can do the following:
  ///
  /// *   Enable/disable communication over the peering connection between an
  /// EC2-Classic instance that's linked to your VPC (using ClassicLink) and
  /// instances in the peer VPC.
  ///
  /// *   Enable/disable communication over the peering connection between
  /// instances in your VPC and an EC2-Classic instance that's linked to the
  /// peer VPC.
  ///
  /// *   Enable/disable the ability to resolve public DNS hostnames to private
  /// IP addresses when queried from instances in the peer VPC.
  ///
  ///
  /// If the peered VPCs are in the same AWS account, you can enable DNS
  /// resolution for queries from the local VPC. This ensures that queries from
  /// the local VPC resolve to private IP addresses in the peer VPC. This option
  /// is not available if the peered VPCs are in different AWS accounts or
  /// different Regions. For peered VPCs in different AWS accounts, each AWS
  /// account owner must initiate a separate request to modify the peering
  /// connection options. For inter-region peering connections, you must use the
  /// Region for the requester VPC to modify the requester VPC peering options
  /// and the Region for the accepter VPC to modify the accepter VPC peering
  /// options. To verify which VPCs are the accepter and the requester for a VPC
  /// peering connection, use the DescribeVpcPeeringConnections command.
  ///
  /// [accepterPeeringConnectionOptions]: The VPC peering connection options for
  /// the accepter VPC.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [requesterPeeringConnectionOptions]: The VPC peering connection options
  /// for the requester VPC.
  ///
  /// [vpcPeeringConnectionId]: The ID of the VPC peering connection.
  Future<ModifyVpcPeeringConnectionOptionsResult>
      modifyVpcPeeringConnectionOptions(String vpcPeeringConnectionId,
          {PeeringConnectionOptionsRequest accepterPeeringConnectionOptions,
          bool dryRun,
          PeeringConnectionOptionsRequest
              requesterPeeringConnectionOptions}) async {
    var response_ = await _client.send('ModifyVpcPeeringConnectionOptions', {
      if (accepterPeeringConnectionOptions != null)
        'AccepterPeeringConnectionOptions': accepterPeeringConnectionOptions,
      if (dryRun != null) 'DryRun': dryRun,
      if (requesterPeeringConnectionOptions != null)
        'RequesterPeeringConnectionOptions': requesterPeeringConnectionOptions,
      'VpcPeeringConnectionId': vpcPeeringConnectionId,
    });
    return ModifyVpcPeeringConnectionOptionsResult.fromJson(response_);
  }

  /// Modifies the instance tenancy attribute of the specified VPC. You can
  /// change the instance tenancy attribute of a VPC to `default` only. You
  /// cannot change the instance tenancy attribute to `dedicated`.
  ///
  /// After you modify the tenancy of the VPC, any new instances that you launch
  /// into the VPC have a tenancy of `default`, unless you specify otherwise
  /// during launch. The tenancy of any existing instances in the VPC is not
  /// affected.
  ///
  /// For more information, see
  /// [Dedicated Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-instance.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [vpcId]: The ID of the VPC.
  ///
  /// [instanceTenancy]: The instance tenancy attribute for the VPC.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ModifyVpcTenancyResult> modifyVpcTenancy(
      {@required String vpcId,
      @required String instanceTenancy,
      bool dryRun}) async {
    var response_ = await _client.send('ModifyVpcTenancy', {
      'VpcId': vpcId,
      'InstanceTenancy': instanceTenancy,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ModifyVpcTenancyResult.fromJson(response_);
  }

  /// Modifies the target gateway of an AWS Site-to-Site VPN connection. The
  /// following migration options are available:
  ///
  /// *   An existing virtual private gateway to a new virtual private gateway
  ///
  /// *   An existing virtual private gateway to a transit gateway
  ///
  /// *   An existing transit gateway to a new transit gateway
  ///
  /// *   An existing transit gateway to a virtual private gateway
  ///
  ///
  /// Before you perform the migration to the new gateway, you must configure
  /// the new gateway. Use CreateVpnGateway to create a virtual private gateway,
  /// or CreateTransitGateway to create a transit gateway.
  ///
  /// This step is required when you migrate from a virtual private gateway with
  /// static routes to a transit gateway.
  ///
  /// You must delete the static routes before you migrate to the new gateway.
  ///
  /// Keep a copy of the static route before you delete it. You will need to add
  /// back these routes to the transit gateway after the VPN connection
  /// migration is complete.
  ///
  /// After you migrate to the new gateway, you might need to modify your VPC
  /// route table. Use CreateRoute and DeleteRoute to make the changes described
  /// in
  /// [VPN Gateway Target Modification Required VPC Route Table Updates](https://docs.aws.amazon.com/vpn/latest/s2svpn/modify-vpn-target.html#step-update-routing)
  /// in the _AWS Site-to-Site VPN User Guide_.
  ///
  ///  When the new gateway is a transit gateway, modify the transit gateway
  /// route table to allow traffic between the VPC and the AWS Site-to-Site VPN
  /// connection. Use CreateTransitGatewayRoute to add the routes.
  ///
  ///  If you deleted VPN static routes, you must add the static routes to the
  /// transit gateway route table.
  ///
  /// After you perform this operation, the AWS VPN endpoint's IP addresses on
  /// the AWS side and the tunnel options remain intact. Your s2slong;
  /// connection will be temporarily unavailable for approximately 10 minutes
  /// while we provision the new endpoints
  ///
  /// [vpnConnectionId]: The ID of the VPN connection.
  ///
  /// [transitGatewayId]: The ID of the transit gateway.
  ///
  /// [customerGatewayId]: The ID of the customer gateway at your end of the VPN
  /// connection.
  ///
  /// [vpnGatewayId]: The ID of the virtual private gateway at the AWS side of
  /// the VPN connection.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ModifyVpnConnectionResult> modifyVpnConnection(String vpnConnectionId,
      {String transitGatewayId,
      String customerGatewayId,
      String vpnGatewayId,
      bool dryRun}) async {
    var response_ = await _client.send('ModifyVpnConnection', {
      'VpnConnectionId': vpnConnectionId,
      if (transitGatewayId != null) 'TransitGatewayId': transitGatewayId,
      if (customerGatewayId != null) 'CustomerGatewayId': customerGatewayId,
      if (vpnGatewayId != null) 'VpnGatewayId': vpnGatewayId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ModifyVpnConnectionResult.fromJson(response_);
  }

  /// Modifies the VPN tunnel endpoint certificate.
  ///
  /// [vpnConnectionId]: The ID of the AWS Site-to-Site VPN connection.
  ///
  /// [vpnTunnelOutsideIpAddress]: The external IP address of the VPN tunnel.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ModifyVpnTunnelCertificateResult> modifyVpnTunnelCertificate(
      {@required String vpnConnectionId,
      @required String vpnTunnelOutsideIpAddress,
      bool dryRun}) async {
    var response_ = await _client.send('ModifyVpnTunnelCertificate', {
      'VpnConnectionId': vpnConnectionId,
      'VpnTunnelOutsideIpAddress': vpnTunnelOutsideIpAddress,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ModifyVpnTunnelCertificateResult.fromJson(response_);
  }

  /// Modifies the options for a VPN tunnel in an AWS Site-to-Site VPN
  /// connection. You can modify multiple options for a tunnel in a single
  /// request, but you can only modify one tunnel at a time. For more
  /// information, see
  /// [Site-to-Site VPN Tunnel Options for Your Site-to-Site VPN Connection](https://docs.aws.amazon.com/vpn/latest/s2svpn/VPNTunnels.html)
  /// in the _AWS Site-to-Site VPN User Guide_.
  ///
  /// [vpnConnectionId]: The ID of the AWS Site-to-Site VPN connection.
  ///
  /// [vpnTunnelOutsideIpAddress]: The external IP address of the VPN tunnel.
  ///
  /// [tunnelOptions]: The tunnel options to modify.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ModifyVpnTunnelOptionsResult> modifyVpnTunnelOptions(
      {@required String vpnConnectionId,
      @required String vpnTunnelOutsideIpAddress,
      @required ModifyVpnTunnelOptionsSpecification tunnelOptions,
      bool dryRun}) async {
    var response_ = await _client.send('ModifyVpnTunnelOptions', {
      'VpnConnectionId': vpnConnectionId,
      'VpnTunnelOutsideIpAddress': vpnTunnelOutsideIpAddress,
      'TunnelOptions': tunnelOptions,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ModifyVpnTunnelOptionsResult.fromJson(response_);
  }

  /// Enables detailed monitoring for a running instance. Otherwise, basic
  /// monitoring is enabled. For more information, see
  /// [Monitoring Your Instances and Volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// To disable detailed monitoring, see .
  ///
  /// [instanceIds]: The IDs of the instances.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<MonitorInstancesResult> monitorInstances(List<String> instanceIds,
      {bool dryRun}) async {
    var response_ = await _client.send('MonitorInstances', {
      'InstanceIds': instanceIds,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return MonitorInstancesResult.fromJson(response_);
  }

  /// Moves an Elastic IP address from the EC2-Classic platform to the EC2-VPC
  /// platform. The Elastic IP address must be allocated to your account for
  /// more than 24 hours, and it must not be associated with an instance. After
  /// the Elastic IP address is moved, it is no longer available for use in the
  /// EC2-Classic platform, unless you move it back using the
  /// RestoreAddressToClassic request. You cannot move an Elastic IP address
  /// that was originally allocated for use in the EC2-VPC platform to the
  /// EC2-Classic platform.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [publicIp]: The Elastic IP address.
  Future<MoveAddressToVpcResult> moveAddressToVpc(String publicIp,
      {bool dryRun}) async {
    var response_ = await _client.send('MoveAddressToVpc', {
      if (dryRun != null) 'DryRun': dryRun,
      'PublicIp': publicIp,
    });
    return MoveAddressToVpcResult.fromJson(response_);
  }

  /// Provisions an address range for use with your AWS resources through bring
  /// your own IP addresses (BYOIP) and creates a corresponding address pool.
  /// After the address range is provisioned, it is ready to be advertised using
  /// AdvertiseByoipCidr.
  ///
  /// AWS verifies that you own the address range and are authorized to
  /// advertise it. You must ensure that the address range is registered to you
  /// and that you created an RPKI ROA to authorize Amazon ASNs 16509 and 14618
  /// to advertise the address range. For more information, see
  /// [Bring Your Own IP Addresses (BYOIP)](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-byoip.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// Provisioning an address range is an asynchronous operation, so the call
  /// returns immediately, but the address range is not ready to use until its
  /// status changes from `pending-provision` to `provisioned`. To monitor the
  /// status of an address range, use DescribeByoipCidrs. To allocate an Elastic
  /// IP address from your address pool, use AllocateAddress with either the
  /// specific address from the address pool or the ID of the address pool.
  ///
  /// [cidr]: The public IPv4 address range, in CIDR notation. The most specific
  /// prefix that you can specify is /24. The address range cannot overlap with
  /// another address range that you've brought to this or another Region.
  ///
  /// [cidrAuthorizationContext]: A signed document that proves that you are
  /// authorized to bring the specified IP address range to Amazon using BYOIP.
  ///
  /// [description]: A description for the address range and the address pool.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ProvisionByoipCidrResult> provisionByoipCidr(String cidr,
      {CidrAuthorizationContext cidrAuthorizationContext,
      String description,
      bool dryRun}) async {
    var response_ = await _client.send('ProvisionByoipCidr', {
      'Cidr': cidr,
      if (cidrAuthorizationContext != null)
        'CidrAuthorizationContext': cidrAuthorizationContext,
      if (description != null) 'Description': description,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ProvisionByoipCidrResult.fromJson(response_);
  }

  /// Purchase a reservation with configurations that match those of your
  /// Dedicated Host. You must have active Dedicated Hosts in your account
  /// before you purchase a reservation. This action results in the specified
  /// reservation being purchased and charged to your account.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that you provide to
  /// ensure the idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// [currencyCode]: The currency in which the `totalUpfrontPrice`,
  /// `LimitPrice`, and `totalHourlyPrice` amounts are specified. At this time,
  /// the only supported currency is `USD`.
  ///
  /// [hostIdSet]: The IDs of the Dedicated Hosts with which the reservation
  /// will be associated.
  ///
  /// [limitPrice]: The specified limit is checked against the total upfront
  /// cost of the reservation (calculated as the offering's upfront cost
  /// multiplied by the host count). If the total upfront cost is greater than
  /// the specified price limit, the request fails. This is used to ensure that
  /// the purchase does not exceed the expected upfront cost of the purchase. At
  /// this time, the only supported currency is `USD`. For example, to indicate
  /// a limit price of USD 100, specify 100.00.
  ///
  /// [offeringId]: The ID of the offering.
  Future<PurchaseHostReservationResult> purchaseHostReservation(
      {String clientToken,
      String currencyCode,
      @required List<String> hostIdSet,
      String limitPrice,
      @required String offeringId}) async {
    var response_ = await _client.send('PurchaseHostReservation', {
      if (clientToken != null) 'ClientToken': clientToken,
      if (currencyCode != null) 'CurrencyCode': currencyCode,
      'HostIdSet': hostIdSet,
      if (limitPrice != null) 'LimitPrice': limitPrice,
      'OfferingId': offeringId,
    });
    return PurchaseHostReservationResult.fromJson(response_);
  }

  /// Purchases a Reserved Instance for use with your account. With Reserved
  /// Instances, you pay a lower hourly rate compared to On-Demand instance
  /// pricing.
  ///
  /// Use DescribeReservedInstancesOfferings to get a list of Reserved Instance
  /// offerings that match your specifications. After you've purchased a
  /// Reserved Instance, you can check for your new Reserved Instance with
  /// DescribeReservedInstances.
  ///
  /// For more information, see
  /// [Reserved Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/concepts-on-demand-reserved-instances.html)
  /// and
  /// [Reserved Instance Marketplace](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-market-general.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [instanceCount]: The number of Reserved Instances to purchase.
  ///
  /// [reservedInstancesOfferingId]: The ID of the Reserved Instance offering to
  /// purchase.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [limitPrice]: Specified for Reserved Instance Marketplace offerings to
  /// limit the total order and ensure that the Reserved Instances are not
  /// purchased at unexpected prices.
  Future<PurchaseReservedInstancesOfferingResult>
      purchaseReservedInstancesOffering(
          {@required int instanceCount,
          @required String reservedInstancesOfferingId,
          bool dryRun,
          ReservedInstanceLimitPrice limitPrice}) async {
    var response_ = await _client.send('PurchaseReservedInstancesOffering', {
      'InstanceCount': instanceCount,
      'ReservedInstancesOfferingId': reservedInstancesOfferingId,
      if (dryRun != null) 'DryRun': dryRun,
      if (limitPrice != null) 'LimitPrice': limitPrice,
    });
    return PurchaseReservedInstancesOfferingResult.fromJson(response_);
  }

  /// Purchases the Scheduled Instances with the specified schedule.
  ///
  /// Scheduled Instances enable you to purchase Amazon EC2 compute capacity by
  /// the hour for a one-year term. Before you can purchase a Scheduled
  /// Instance, you must call DescribeScheduledInstanceAvailability to check for
  /// available schedules and obtain a purchase token. After you purchase a
  /// Scheduled Instance, you must call RunScheduledInstances during each
  /// scheduled time period.
  ///
  /// After you purchase a Scheduled Instance, you can't cancel, modify, or
  /// resell your purchase.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that ensures the
  /// idempotency of the request. For more information, see
  /// [Ensuring Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [purchaseRequests]: The purchase requests.
  Future<PurchaseScheduledInstancesResult> purchaseScheduledInstances(
      List<PurchaseRequest> purchaseRequests,
      {String clientToken,
      bool dryRun}) async {
    var response_ = await _client.send('PurchaseScheduledInstances', {
      if (clientToken != null) 'ClientToken': clientToken,
      if (dryRun != null) 'DryRun': dryRun,
      'PurchaseRequests': purchaseRequests,
    });
    return PurchaseScheduledInstancesResult.fromJson(response_);
  }

  /// Requests a reboot of the specified instances. This operation is
  /// asynchronous; it only queues a request to reboot the specified instances.
  /// The operation succeeds if the instances are valid and belong to you.
  /// Requests to reboot terminated instances are ignored.
  ///
  /// If an instance does not cleanly shut down within four minutes, Amazon EC2
  /// performs a hard reboot.
  ///
  /// For more information about troubleshooting, see
  /// [Getting Console Output and Rebooting Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-console.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [instanceIds]: The instance IDs.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> rebootInstances(List<String> instanceIds, {bool dryRun}) async {
    await _client.send('RebootInstances', {
      'InstanceIds': instanceIds,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Registers an AMI. When you're creating an AMI, this is the final step you
  /// must complete before you can launch an instance from the AMI. For more
  /// information about creating AMIs, see
  /// [Creating Your Own AMIs](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/creating-an-ami.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  ///  For Amazon EBS-backed instances, CreateImage creates and registers the
  /// AMI in a single request, so you don't have to register the AMI yourself.
  ///
  /// You can also use `RegisterImage` to create an Amazon EBS-backed Linux AMI
  /// from a snapshot of a root device volume. You specify the snapshot using
  /// the block device mapping. For more information, see
  /// [Launching a Linux Instance from a Backup](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-launch-snapshot.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// You can't register an image where a secondary (non-root) snapshot has AWS
  /// Marketplace product codes.
  ///
  /// Some Linux distributions, such as Red Hat Enterprise Linux (RHEL) and SUSE
  /// Linux Enterprise Server (SLES), use the EC2 billing product code
  /// associated with an AMI to verify the subscription status for package
  /// updates. Creating an AMI from an EBS snapshot does not maintain this
  /// billing code, and instances launched from such an AMI are not able to
  /// connect to package update infrastructure. If you purchase a Reserved
  /// Instance offering for one of these Linux distributions and launch
  /// instances using an AMI that does not contain the required billing code,
  /// your Reserved Instance is not applied to these instances.
  ///
  /// To create an AMI for operating systems that require a billing code, see
  /// CreateImage.
  ///
  /// If needed, you can deregister an AMI at any time. Any modifications you
  /// make to an AMI backed by an instance store volume invalidates its
  /// registration. If you make changes to an image, deregister the previous
  /// image and register the new image.
  ///
  /// [imageLocation]: The full path to your AMI manifest in Amazon S3 storage.
  /// The specified bucket must have the `aws-exec-read` canned access control
  /// list (ACL) to ensure that it can be accessed by Amazon EC2. For more
  /// information, see
  /// [Canned ACLs](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl)
  /// in the _Amazon S3 Service Developer Guide_.
  ///
  /// [architecture]: The architecture of the AMI.
  ///
  /// Default: For Amazon EBS-backed AMIs, `i386`. For instance store-backed
  /// AMIs, the architecture specified in the manifest file.
  ///
  /// [blockDeviceMappings]: The block device mapping entries.
  ///
  /// [description]: A description for your AMI.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [enaSupport]: Set to `true` to enable enhanced networking with ENA for the
  /// AMI and any instances that you launch from the AMI.
  ///
  /// This option is supported only for HVM AMIs. Specifying this option with a
  /// PV AMI can make instances launched from the AMI unreachable.
  ///
  /// [kernelId]: The ID of the kernel.
  ///
  /// [name]: A name for your AMI.
  ///
  /// Constraints: 3-128 alphanumeric characters, parentheses (()), square
  /// brackets ([]), spaces ( ), periods (.), slashes (/), dashes (-), single
  /// quotes ('), at-signs (@), or underscores(_)
  ///
  /// [billingProducts]: The billing product codes. Your account must be
  /// authorized to specify billing product codes. Otherwise, you can use the
  /// AWS Marketplace to bill for the use of an AMI.
  ///
  /// [ramdiskId]: The ID of the RAM disk.
  ///
  /// [rootDeviceName]: The device name of the root device volume (for example,
  /// `/dev/sda1`).
  ///
  /// [sriovNetSupport]: Set to `simple` to enable enhanced networking with the
  /// Intel 82599 Virtual Function interface for the AMI and any instances that
  /// you launch from the AMI.
  ///
  /// There is no way to disable `sriovNetSupport` at this time.
  ///
  /// This option is supported only for HVM AMIs. Specifying this option with a
  /// PV AMI can make instances launched from the AMI unreachable.
  ///
  /// [virtualizationType]: The type of virtualization (`hvm` | `paravirtual`).
  ///
  /// Default: `paravirtual`
  Future<RegisterImageResult> registerImage(String name,
      {String imageLocation,
      String architecture,
      List<BlockDeviceMapping> blockDeviceMappings,
      String description,
      bool dryRun,
      bool enaSupport,
      String kernelId,
      List<String> billingProducts,
      String ramdiskId,
      String rootDeviceName,
      String sriovNetSupport,
      String virtualizationType}) async {
    var response_ = await _client.send('RegisterImage', {
      if (imageLocation != null) 'ImageLocation': imageLocation,
      if (architecture != null) 'Architecture': architecture,
      if (blockDeviceMappings != null)
        'BlockDeviceMappings': blockDeviceMappings,
      if (description != null) 'Description': description,
      if (dryRun != null) 'DryRun': dryRun,
      if (enaSupport != null) 'EnaSupport': enaSupport,
      if (kernelId != null) 'KernelId': kernelId,
      'Name': name,
      if (billingProducts != null) 'BillingProducts': billingProducts,
      if (ramdiskId != null) 'RamdiskId': ramdiskId,
      if (rootDeviceName != null) 'RootDeviceName': rootDeviceName,
      if (sriovNetSupport != null) 'SriovNetSupport': sriovNetSupport,
      if (virtualizationType != null) 'VirtualizationType': virtualizationType,
    });
    return RegisterImageResult.fromJson(response_);
  }

  /// Rejects a request to attach a VPC to a transit gateway.
  ///
  /// The VPC attachment must be in the `pendingAcceptance` state. Use
  /// DescribeTransitGatewayVpcAttachments to view your pending VPC attachment
  /// requests. Use AcceptTransitGatewayVpcAttachment to accept a VPC attachment
  /// request.
  ///
  /// [transitGatewayAttachmentId]: The ID of the attachment.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<RejectTransitGatewayVpcAttachmentResult>
      rejectTransitGatewayVpcAttachment(String transitGatewayAttachmentId,
          {bool dryRun}) async {
    var response_ = await _client.send('RejectTransitGatewayVpcAttachment', {
      'TransitGatewayAttachmentId': transitGatewayAttachmentId,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return RejectTransitGatewayVpcAttachmentResult.fromJson(response_);
  }

  /// Rejects one or more VPC endpoint connection requests to your VPC endpoint
  /// service.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [serviceId]: The ID of the service.
  ///
  /// [vpcEndpointIds]: The IDs of one or more VPC endpoints.
  Future<RejectVpcEndpointConnectionsResult> rejectVpcEndpointConnections(
      {bool dryRun,
      @required String serviceId,
      @required List<String> vpcEndpointIds}) async {
    var response_ = await _client.send('RejectVpcEndpointConnections', {
      if (dryRun != null) 'DryRun': dryRun,
      'ServiceId': serviceId,
      'VpcEndpointIds': vpcEndpointIds,
    });
    return RejectVpcEndpointConnectionsResult.fromJson(response_);
  }

  /// Rejects a VPC peering connection request. The VPC peering connection must
  /// be in the `pending-acceptance` state. Use the
  /// DescribeVpcPeeringConnections request to view your outstanding VPC peering
  /// connection requests. To delete an active VPC peering connection, or to
  /// delete a VPC peering connection request that you initiated, use
  /// DeleteVpcPeeringConnection.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [vpcPeeringConnectionId]: The ID of the VPC peering connection.
  Future<RejectVpcPeeringConnectionResult> rejectVpcPeeringConnection(
      String vpcPeeringConnectionId,
      {bool dryRun}) async {
    var response_ = await _client.send('RejectVpcPeeringConnection', {
      if (dryRun != null) 'DryRun': dryRun,
      'VpcPeeringConnectionId': vpcPeeringConnectionId,
    });
    return RejectVpcPeeringConnectionResult.fromJson(response_);
  }

  /// Releases the specified Elastic IP address.
  ///
  /// [EC2-Classic, default VPC] Releasing an Elastic IP address automatically
  /// disassociates it from any instance that it's associated with. To
  /// disassociate an Elastic IP address without releasing it, use
  /// DisassociateAddress.
  ///
  /// [Nondefault VPC] You must use DisassociateAddress to disassociate the
  /// Elastic IP address before you can release it. Otherwise, Amazon EC2
  /// returns an error (`InvalidIPAddress.InUse`).
  ///
  /// After releasing an Elastic IP address, it is released to the IP address
  /// pool. Be sure to update your DNS records and any servers or devices that
  /// communicate with the address. If you attempt to release an Elastic IP
  /// address that you already released, you'll get an `AuthFailure` error if
  /// the address is already allocated to another AWS account.
  ///
  /// [EC2-VPC] After you release an Elastic IP address for use in a VPC, you
  /// might be able to recover it. For more information, see AllocateAddress.
  ///
  /// [allocationId]: [EC2-VPC] The allocation ID. Required for EC2-VPC.
  ///
  /// [publicIp]: [EC2-Classic] The Elastic IP address. Required for
  /// EC2-Classic.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> releaseAddress(
      {String allocationId, String publicIp, bool dryRun}) async {
    await _client.send('ReleaseAddress', {
      if (allocationId != null) 'AllocationId': allocationId,
      if (publicIp != null) 'PublicIp': publicIp,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// When you no longer want to use an On-Demand Dedicated Host it can be
  /// released. On-Demand billing is stopped and the host goes into `released`
  /// state. The host ID of Dedicated Hosts that have been released can no
  /// longer be specified in another request, for example, to modify the host.
  /// You must stop or terminate all instances on a host before it can be
  /// released.
  ///
  /// When Dedicated Hosts are released, it may take some time for them to stop
  /// counting toward your limit and you may receive capacity errors when trying
  /// to allocate new Dedicated Hosts. Wait a few minutes and then try again.
  ///
  /// Released hosts still appear in a DescribeHosts response.
  ///
  /// [hostIds]: The IDs of the Dedicated Hosts to release.
  Future<ReleaseHostsResult> releaseHosts(List<String> hostIds) async {
    var response_ = await _client.send('ReleaseHosts', {
      'HostIds': hostIds,
    });
    return ReleaseHostsResult.fromJson(response_);
  }

  /// Replaces an IAM instance profile for the specified running instance. You
  /// can use this action to change the IAM instance profile that's associated
  /// with an instance without having to disassociate the existing IAM instance
  /// profile first.
  ///
  /// Use DescribeIamInstanceProfileAssociations to get the association ID.
  ///
  /// [iamInstanceProfile]: The IAM instance profile.
  ///
  /// [associationId]: The ID of the existing IAM instance profile association.
  Future<ReplaceIamInstanceProfileAssociationResult>
      replaceIamInstanceProfileAssociation(
          {@required IamInstanceProfileSpecification iamInstanceProfile,
          @required String associationId}) async {
    var response_ = await _client.send('ReplaceIamInstanceProfileAssociation', {
      'IamInstanceProfile': iamInstanceProfile,
      'AssociationId': associationId,
    });
    return ReplaceIamInstanceProfileAssociationResult.fromJson(response_);
  }

  /// Changes which network ACL a subnet is associated with. By default when you
  /// create a subnet, it's automatically associated with the default network
  /// ACL. For more information, see
  /// [Network ACLs](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_ACLs.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// This is an idempotent operation.
  ///
  /// [associationId]: The ID of the current association between the original
  /// network ACL and the subnet.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [networkAclId]: The ID of the new network ACL to associate with the
  /// subnet.
  Future<ReplaceNetworkAclAssociationResult> replaceNetworkAclAssociation(
      {@required String associationId,
      bool dryRun,
      @required String networkAclId}) async {
    var response_ = await _client.send('ReplaceNetworkAclAssociation', {
      'AssociationId': associationId,
      if (dryRun != null) 'DryRun': dryRun,
      'NetworkAclId': networkAclId,
    });
    return ReplaceNetworkAclAssociationResult.fromJson(response_);
  }

  /// Replaces an entry (rule) in a network ACL. For more information, see
  /// [Network ACLs](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_ACLs.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [cidrBlock]: The IPv4 network range to allow or deny, in CIDR notation
  /// (for example `172.16.0.0/24`).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [egress]: Indicates whether to replace the egress rule.
  ///
  /// Default: If no value is specified, we replace the ingress rule.
  ///
  /// [icmpTypeCode]: ICMP protocol: The ICMP or ICMPv6 type and code. Required
  /// if specifying protocol 1 (ICMP) or protocol 58 (ICMPv6) with an IPv6 CIDR
  /// block.
  ///
  /// [ipv6CidrBlock]: The IPv6 network range to allow or deny, in CIDR notation
  /// (for example `2001:bd8:1234:1a00::/64`).
  ///
  /// [networkAclId]: The ID of the ACL.
  ///
  /// [portRange]: TCP or UDP protocols: The range of ports the rule applies to.
  /// Required if specifying protocol 6 (TCP) or 17 (UDP).
  ///
  /// [protocol]: The protocol number. A value of "-1" means all protocols. If
  /// you specify "-1" or a protocol number other than "6" (TCP), "17" (UDP), or
  /// "1" (ICMP), traffic on all ports is allowed, regardless of any ports or
  /// ICMP types or codes that you specify. If you specify protocol "58"
  /// (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and
  /// codes allowed, regardless of any that you specify. If you specify protocol
  /// "58" (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP
  /// type and code.
  ///
  /// [ruleAction]: Indicates whether to allow or deny the traffic that matches
  /// the rule.
  ///
  /// [ruleNumber]: The rule number of the entry to replace.
  Future<void> replaceNetworkAclEntry(
      {String cidrBlock,
      bool dryRun,
      @required bool egress,
      IcmpTypeCode icmpTypeCode,
      String ipv6CidrBlock,
      @required String networkAclId,
      PortRange portRange,
      @required String protocol,
      @required String ruleAction,
      @required int ruleNumber}) async {
    await _client.send('ReplaceNetworkAclEntry', {
      if (cidrBlock != null) 'CidrBlock': cidrBlock,
      if (dryRun != null) 'DryRun': dryRun,
      'Egress': egress,
      if (icmpTypeCode != null) 'IcmpTypeCode': icmpTypeCode,
      if (ipv6CidrBlock != null) 'Ipv6CidrBlock': ipv6CidrBlock,
      'NetworkAclId': networkAclId,
      if (portRange != null) 'PortRange': portRange,
      'Protocol': protocol,
      'RuleAction': ruleAction,
      'RuleNumber': ruleNumber,
    });
  }

  /// Replaces an existing route within a route table in a VPC. You must provide
  /// only one of the following: internet gateway or virtual private gateway,
  /// NAT instance, NAT gateway, VPC peering connection, network interface, or
  /// egress-only internet gateway.
  ///
  /// For more information, see
  /// [Route Tables](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Route_Tables.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [destinationCidrBlock]: The IPv4 CIDR address block used for the
  /// destination match. The value that you provide must match the CIDR of an
  /// existing route in the table.
  ///
  /// [destinationIpv6CidrBlock]: The IPv6 CIDR address block used for the
  /// destination match. The value that you provide must match the CIDR of an
  /// existing route in the table.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [egressOnlyInternetGatewayId]: [IPv6 traffic only] The ID of an
  /// egress-only internet gateway.
  ///
  /// [gatewayId]: The ID of an internet gateway or virtual private gateway.
  ///
  /// [instanceId]: The ID of a NAT instance in your VPC.
  ///
  /// [natGatewayId]: [IPv4 traffic only] The ID of a NAT gateway.
  ///
  /// [transitGatewayId]: The ID of a transit gateway.
  ///
  /// [networkInterfaceId]: The ID of a network interface.
  ///
  /// [routeTableId]: The ID of the route table.
  ///
  /// [vpcPeeringConnectionId]: The ID of a VPC peering connection.
  Future<void> replaceRoute(String routeTableId,
      {String destinationCidrBlock,
      String destinationIpv6CidrBlock,
      bool dryRun,
      String egressOnlyInternetGatewayId,
      String gatewayId,
      String instanceId,
      String natGatewayId,
      String transitGatewayId,
      String networkInterfaceId,
      String vpcPeeringConnectionId}) async {
    await _client.send('ReplaceRoute', {
      if (destinationCidrBlock != null)
        'DestinationCidrBlock': destinationCidrBlock,
      if (destinationIpv6CidrBlock != null)
        'DestinationIpv6CidrBlock': destinationIpv6CidrBlock,
      if (dryRun != null) 'DryRun': dryRun,
      if (egressOnlyInternetGatewayId != null)
        'EgressOnlyInternetGatewayId': egressOnlyInternetGatewayId,
      if (gatewayId != null) 'GatewayId': gatewayId,
      if (instanceId != null) 'InstanceId': instanceId,
      if (natGatewayId != null) 'NatGatewayId': natGatewayId,
      if (transitGatewayId != null) 'TransitGatewayId': transitGatewayId,
      if (networkInterfaceId != null) 'NetworkInterfaceId': networkInterfaceId,
      'RouteTableId': routeTableId,
      if (vpcPeeringConnectionId != null)
        'VpcPeeringConnectionId': vpcPeeringConnectionId,
    });
  }

  /// Changes the route table associated with a given subnet in a VPC. After the
  /// operation completes, the subnet uses the routes in the new route table
  /// it's associated with. For more information about route tables, see
  /// [Route Tables](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Route_Tables.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// You can also use ReplaceRouteTableAssociation to change which table is the
  /// main route table in the VPC. You just specify the main route table's
  /// association ID and the route table to be the new main route table.
  ///
  /// [associationId]: The association ID.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [routeTableId]: The ID of the new route table to associate with the
  /// subnet.
  Future<ReplaceRouteTableAssociationResult> replaceRouteTableAssociation(
      {@required String associationId,
      bool dryRun,
      @required String routeTableId}) async {
    var response_ = await _client.send('ReplaceRouteTableAssociation', {
      'AssociationId': associationId,
      if (dryRun != null) 'DryRun': dryRun,
      'RouteTableId': routeTableId,
    });
    return ReplaceRouteTableAssociationResult.fromJson(response_);
  }

  /// Replaces the specified route in the specified transit gateway route table.
  ///
  /// [destinationCidrBlock]: The CIDR range used for the destination match.
  /// Routing decisions are based on the most specific match.
  ///
  /// [transitGatewayRouteTableId]: The ID of the route table.
  ///
  /// [transitGatewayAttachmentId]: The ID of the attachment.
  ///
  /// [blackhole]: Indicates whether traffic matching this route is to be
  /// dropped.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ReplaceTransitGatewayRouteResult> replaceTransitGatewayRoute(
      {@required String destinationCidrBlock,
      @required String transitGatewayRouteTableId,
      String transitGatewayAttachmentId,
      bool blackhole,
      bool dryRun}) async {
    var response_ = await _client.send('ReplaceTransitGatewayRoute', {
      'DestinationCidrBlock': destinationCidrBlock,
      'TransitGatewayRouteTableId': transitGatewayRouteTableId,
      if (transitGatewayAttachmentId != null)
        'TransitGatewayAttachmentId': transitGatewayAttachmentId,
      if (blackhole != null) 'Blackhole': blackhole,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ReplaceTransitGatewayRouteResult.fromJson(response_);
  }

  /// Submits feedback about the status of an instance. The instance must be in
  /// the `running` state. If your experience with the instance differs from the
  /// instance status returned by DescribeInstanceStatus, use
  /// ReportInstanceStatus to report your experience with the instance. Amazon
  /// EC2 collects this information to improve the accuracy of status checks.
  ///
  /// Use of this action does not change the value returned by
  /// DescribeInstanceStatus.
  ///
  /// [description]: Descriptive text about the health state of your instance.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [endTime]: The time at which the reported instance health state ended.
  ///
  /// [instances]: The instances.
  ///
  /// [reasonCodes]: The reason codes that describe the health state of your
  /// instance.
  ///
  /// *    `instance-stuck-in-state`: My instance is stuck in a state.
  ///
  /// *    `unresponsive`: My instance is unresponsive.
  ///
  /// *    `not-accepting-credentials`: My instance is not accepting my
  /// credentials.
  ///
  /// *    `password-not-available`: A password is not available for my
  /// instance.
  ///
  /// *    `performance-network`: My instance is experiencing performance
  /// problems that I believe are network related.
  ///
  /// *    `performance-instance-store`: My instance is experiencing performance
  /// problems that I believe are related to the instance stores.
  ///
  /// *    `performance-ebs-volume`: My instance is experiencing performance
  /// problems that I believe are related to an EBS volume.
  ///
  /// *    `performance-other`: My instance is experiencing performance
  /// problems.
  ///
  /// *    `other`: [explain using the description parameter]
  ///
  /// [startTime]: The time at which the reported instance health state began.
  ///
  /// [status]: The status of all instances listed.
  Future<void> reportInstanceStatus(
      {String description,
      bool dryRun,
      DateTime endTime,
      @required List<String> instances,
      @required List<String> reasonCodes,
      DateTime startTime,
      @required String status}) async {
    await _client.send('ReportInstanceStatus', {
      if (description != null) 'Description': description,
      if (dryRun != null) 'DryRun': dryRun,
      if (endTime != null) 'EndTime': endTime,
      'Instances': instances,
      'ReasonCodes': reasonCodes,
      if (startTime != null) 'StartTime': startTime,
      'Status': status,
    });
  }

  /// Creates a Spot Fleet request.
  ///
  /// The Spot Fleet request specifies the total target capacity and the
  /// On-Demand target capacity. Amazon EC2 calculates the difference between
  /// the total capacity and On-Demand capacity, and launches the difference as
  /// Spot capacity.
  ///
  /// You can submit a single request that includes multiple launch
  /// specifications that vary by instance type, AMI, Availability Zone, or
  /// subnet.
  ///
  /// By default, the Spot Fleet requests Spot Instances in the Spot Instance
  /// pool where the price per unit is the lowest. Each launch specification can
  /// include its own instance weighting that reflects the value of the instance
  /// type to your application workload.
  ///
  /// Alternatively, you can specify that the Spot Fleet distribute the target
  /// capacity across the Spot pools included in its launch specifications. By
  /// ensuring that the Spot Instances in your Spot Fleet are in different Spot
  /// pools, you can improve the availability of your fleet.
  ///
  /// You can specify tags for the Spot Instances. You cannot tag other resource
  /// types in a Spot Fleet request because only the `instance` resource type is
  /// supported.
  ///
  /// For more information, see
  /// [Spot Fleet Requests](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html)
  /// in the _Amazon EC2 User Guide for Linux Instances_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [spotFleetRequestConfig]: The configuration for the Spot Fleet request.
  Future<RequestSpotFleetResponse> requestSpotFleet(
      SpotFleetRequestConfigData spotFleetRequestConfig,
      {bool dryRun}) async {
    var response_ = await _client.send('RequestSpotFleet', {
      if (dryRun != null) 'DryRun': dryRun,
      'SpotFleetRequestConfig': spotFleetRequestConfig,
    });
    return RequestSpotFleetResponse.fromJson(response_);
  }

  /// Creates a Spot Instance request.
  ///
  /// For more information, see
  /// [Spot Instance Requests](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-requests.html)
  /// in the _Amazon EC2 User Guide for Linux Instances_.
  ///
  /// [availabilityZoneGroup]: The user-specified name for a logical grouping of
  /// requests.
  ///
  /// When you specify an Availability Zone group in a Spot Instance request,
  /// all Spot Instances in the request are launched in the same Availability
  /// Zone. Instance proximity is maintained with this parameter, but the choice
  /// of Availability Zone is not. The group applies only to requests for Spot
  /// Instances of the same instance type. Any additional Spot Instance requests
  /// that are specified with the same Availability Zone group name are launched
  /// in that same Availability Zone, as long as at least one instance from the
  /// group is still active.
  ///
  /// If there is no active instance running in the Availability Zone group that
  /// you specify for a new Spot Instance request (all instances are terminated,
  /// the request is expired, or the maximum price you specified falls below
  /// current Spot price), then Amazon EC2 launches the instance in any
  /// Availability Zone where the constraint can be met. Consequently, the
  /// subsequent set of Spot Instances could be placed in a different zone from
  /// the original request, even if you specified the same Availability Zone
  /// group.
  ///
  /// Default: Instances are launched in any available Availability Zone.
  ///
  /// [blockDurationMinutes]: The required duration for the Spot Instances (also
  /// known as Spot blocks), in minutes. This value must be a multiple of 60
  /// (60, 120, 180, 240, 300, or 360).
  ///
  /// The duration period starts as soon as your Spot Instance receives its
  /// instance ID. At the end of the duration period, Amazon EC2 marks the Spot
  /// Instance for termination and provides a Spot Instance termination notice,
  /// which gives the instance a two-minute warning before it terminates.
  ///
  /// You can't specify an Availability Zone group or a launch group if you
  /// specify a duration.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that you provide to
  /// ensure the idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html)
  /// in the _Amazon EC2 User Guide for Linux Instances_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [instanceCount]: The maximum number of Spot Instances to launch.
  ///
  /// Default: 1
  ///
  /// [launchGroup]: The instance launch group. Launch groups are Spot Instances
  /// that launch together and terminate together.
  ///
  /// Default: Instances are launched and terminated individually
  ///
  /// [launchSpecification]: The launch specification.
  ///
  /// [spotPrice]: The maximum price per hour that you are willing to pay for a
  /// Spot Instance. The default is the On-Demand price.
  ///
  /// [type]: The Spot Instance request type.
  ///
  /// Default: `one-time`
  ///
  /// [validFrom]: The start date of the request. If this is a one-time request,
  /// the request becomes active at this date and time and remains active until
  /// all instances launch, the request expires, or the request is canceled. If
  /// the request is persistent, the request becomes active at this date and
  /// time and remains active until it expires or is canceled.
  ///
  /// [validUntil]: The end date of the request. If this is a one-time request,
  /// the request remains active until all instances launch, the request is
  /// canceled, or this date is reached. If the request is persistent, it
  /// remains active until it is canceled or this date is reached. The default
  /// end date is 7 days from the current date.
  ///
  /// [instanceInterruptionBehavior]: The behavior when a Spot Instance is
  /// interrupted. The default is `terminate`.
  Future<RequestSpotInstancesResult> requestSpotInstances(
      {String availabilityZoneGroup,
      int blockDurationMinutes,
      String clientToken,
      bool dryRun,
      int instanceCount,
      String launchGroup,
      RequestSpotLaunchSpecification launchSpecification,
      String spotPrice,
      String type,
      DateTime validFrom,
      DateTime validUntil,
      String instanceInterruptionBehavior}) async {
    var response_ = await _client.send('RequestSpotInstances', {
      if (availabilityZoneGroup != null)
        'AvailabilityZoneGroup': availabilityZoneGroup,
      if (blockDurationMinutes != null)
        'BlockDurationMinutes': blockDurationMinutes,
      if (clientToken != null) 'ClientToken': clientToken,
      if (dryRun != null) 'DryRun': dryRun,
      if (instanceCount != null) 'InstanceCount': instanceCount,
      if (launchGroup != null) 'LaunchGroup': launchGroup,
      if (launchSpecification != null)
        'LaunchSpecification': launchSpecification,
      if (spotPrice != null) 'SpotPrice': spotPrice,
      if (type != null) 'Type': type,
      if (validFrom != null) 'ValidFrom': validFrom,
      if (validUntil != null) 'ValidUntil': validUntil,
      if (instanceInterruptionBehavior != null)
        'InstanceInterruptionBehavior': instanceInterruptionBehavior,
    });
    return RequestSpotInstancesResult.fromJson(response_);
  }

  /// Resets the default customer master key (CMK) for EBS encryption for your
  /// account in this Region to the AWS managed CMK for EBS.
  ///
  /// After resetting the default CMK to the AWS managed CMK, you can continue
  /// to encrypt by a customer managed CMK by specifying it when you create the
  /// volume. For more information, see
  /// [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<ResetEbsDefaultKmsKeyIdResult> resetEbsDefaultKmsKeyId(
      {bool dryRun}) async {
    var response_ = await _client.send('ResetEbsDefaultKmsKeyId', {
      if (dryRun != null) 'DryRun': dryRun,
    });
    return ResetEbsDefaultKmsKeyIdResult.fromJson(response_);
  }

  /// Resets the specified attribute of the specified Amazon FPGA Image (AFI) to
  /// its default value. You can only reset the load permission attribute.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [fpgaImageId]: The ID of the AFI.
  ///
  /// [attribute]: The attribute.
  Future<ResetFpgaImageAttributeResult> resetFpgaImageAttribute(
      String fpgaImageId,
      {bool dryRun,
      String attribute}) async {
    var response_ = await _client.send('ResetFpgaImageAttribute', {
      if (dryRun != null) 'DryRun': dryRun,
      'FpgaImageId': fpgaImageId,
      if (attribute != null) 'Attribute': attribute,
    });
    return ResetFpgaImageAttributeResult.fromJson(response_);
  }

  /// Resets an attribute of an AMI to its default value.
  ///
  ///
  ///
  /// The productCodes attribute can't be reset.
  ///
  /// [attribute]: The attribute to reset (currently you can only reset the
  /// launch permission attribute).
  ///
  /// [imageId]: The ID of the AMI.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> resetImageAttribute(
      {@required String attribute,
      @required String imageId,
      bool dryRun}) async {
    await _client.send('ResetImageAttribute', {
      'Attribute': attribute,
      'ImageId': imageId,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Resets an attribute of an instance to its default value. To reset the
  /// `kernel` or `ramdisk`, the instance must be in a stopped state. To reset
  /// the `sourceDestCheck`, the instance can be either running or stopped.
  ///
  /// The `sourceDestCheck` attribute controls whether source/destination
  /// checking is enabled. The default value is `true`, which means checking is
  /// enabled. This value must be `false` for a NAT instance to perform NAT. For
  /// more information, see
  /// [NAT Instances](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_NAT_Instance.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  ///
  /// [attribute]: The attribute to reset.
  ///
  ///
  ///
  /// You can only reset the following attributes: `kernel` | `ramdisk` |
  /// `sourceDestCheck`. To change an instance attribute, use
  /// ModifyInstanceAttribute.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [instanceId]: The ID of the instance.
  Future<void> resetInstanceAttribute(
      {@required String attribute,
      bool dryRun,
      @required String instanceId}) async {
    await _client.send('ResetInstanceAttribute', {
      'Attribute': attribute,
      if (dryRun != null) 'DryRun': dryRun,
      'InstanceId': instanceId,
    });
  }

  /// Resets a network interface attribute. You can specify only one attribute
  /// at a time.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [networkInterfaceId]: The ID of the network interface.
  ///
  /// [sourceDestCheck]: The source/destination checking attribute. Resets the
  /// value to `true`.
  Future<void> resetNetworkInterfaceAttribute(String networkInterfaceId,
      {bool dryRun, String sourceDestCheck}) async {
    await _client.send('ResetNetworkInterfaceAttribute', {
      if (dryRun != null) 'DryRun': dryRun,
      'NetworkInterfaceId': networkInterfaceId,
      if (sourceDestCheck != null) 'SourceDestCheck': sourceDestCheck,
    });
  }

  /// Resets permission settings for the specified snapshot.
  ///
  /// For more information about modifying snapshot permissions, see
  /// [Sharing Snapshots](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-modifying-snapshot-permissions.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [attribute]: The attribute to reset. Currently, only the attribute for
  /// permission to create volumes can be reset.
  ///
  /// [snapshotId]: The ID of the snapshot.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> resetSnapshotAttribute(
      {@required String attribute,
      @required String snapshotId,
      bool dryRun}) async {
    await _client.send('ResetSnapshotAttribute', {
      'Attribute': attribute,
      'SnapshotId': snapshotId,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Restores an Elastic IP address that was previously moved to the EC2-VPC
  /// platform back to the EC2-Classic platform. You cannot move an Elastic IP
  /// address that was originally allocated for use in EC2-VPC. The Elastic IP
  /// address must not be associated with an instance or network interface.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [publicIp]: The Elastic IP address.
  Future<RestoreAddressToClassicResult> restoreAddressToClassic(String publicIp,
      {bool dryRun}) async {
    var response_ = await _client.send('RestoreAddressToClassic', {
      if (dryRun != null) 'DryRun': dryRun,
      'PublicIp': publicIp,
    });
    return RestoreAddressToClassicResult.fromJson(response_);
  }

  /// Removes an ingress authorization rule from a Client VPN endpoint.
  ///
  /// [clientVpnEndpointId]: The ID of the Client VPN endpoint with which the
  /// authorization rule is associated.
  ///
  /// [targetNetworkCidr]: The IPv4 address range, in CIDR notation, of the
  /// network for which access is being removed.
  ///
  /// [accessGroupId]: The ID of the Active Directory group for which to revoke
  /// access.
  ///
  /// [revokeAllGroups]: Indicates whether access should be revoked for all
  /// clients.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<RevokeClientVpnIngressResult> revokeClientVpnIngress(
      {@required String clientVpnEndpointId,
      @required String targetNetworkCidr,
      String accessGroupId,
      bool revokeAllGroups,
      bool dryRun}) async {
    var response_ = await _client.send('RevokeClientVpnIngress', {
      'ClientVpnEndpointId': clientVpnEndpointId,
      'TargetNetworkCidr': targetNetworkCidr,
      if (accessGroupId != null) 'AccessGroupId': accessGroupId,
      if (revokeAllGroups != null) 'RevokeAllGroups': revokeAllGroups,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return RevokeClientVpnIngressResult.fromJson(response_);
  }

  /// [VPC only] Removes the specified egress rules from a security group for
  /// EC2-VPC. This action doesn't apply to security groups for use in
  /// EC2-Classic. To remove a rule, the values that you specify (for example,
  /// ports) must match the existing rule's values exactly.
  ///
  /// Each rule consists of the protocol and the IPv4 or IPv6 CIDR range or
  /// source security group. For the TCP and UDP protocols, you must also
  /// specify the destination port or range of ports. For the ICMP protocol, you
  /// must also specify the ICMP type and code. If the security group rule has a
  /// description, you do not have to specify the description to revoke the
  /// rule.
  ///
  /// Rule changes are propagated to instances within the security group as
  /// quickly as possible. However, a small delay might occur.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [groupId]: The ID of the security group.
  ///
  /// [ipPermissions]: The sets of IP permissions. You can't specify a
  /// destination security group and a CIDR IP address range in the same set of
  /// permissions.
  ///
  /// [cidrIp]: Not supported. Use a set of IP permissions to specify the CIDR.
  ///
  /// [fromPort]: Not supported. Use a set of IP permissions to specify the
  /// port.
  ///
  /// [ipProtocol]: Not supported. Use a set of IP permissions to specify the
  /// protocol name or number.
  ///
  /// [toPort]: Not supported. Use a set of IP permissions to specify the port.
  ///
  /// [sourceSecurityGroupName]: Not supported. Use a set of IP permissions to
  /// specify a destination security group.
  ///
  /// [sourceSecurityGroupOwnerId]: Not supported. Use a set of IP permissions
  /// to specify a destination security group.
  Future<void> revokeSecurityGroupEgress(String groupId,
      {bool dryRun,
      List<IpPermission> ipPermissions,
      String cidrIp,
      int fromPort,
      String ipProtocol,
      int toPort,
      String sourceSecurityGroupName,
      String sourceSecurityGroupOwnerId}) async {
    await _client.send('RevokeSecurityGroupEgress', {
      if (dryRun != null) 'DryRun': dryRun,
      'GroupId': groupId,
      if (ipPermissions != null) 'IpPermissions': ipPermissions,
      if (cidrIp != null) 'CidrIp': cidrIp,
      if (fromPort != null) 'FromPort': fromPort,
      if (ipProtocol != null) 'IpProtocol': ipProtocol,
      if (toPort != null) 'ToPort': toPort,
      if (sourceSecurityGroupName != null)
        'SourceSecurityGroupName': sourceSecurityGroupName,
      if (sourceSecurityGroupOwnerId != null)
        'SourceSecurityGroupOwnerId': sourceSecurityGroupOwnerId,
    });
  }

  /// Removes the specified ingress rules from a security group. To remove a
  /// rule, the values that you specify (for example, ports) must match the
  /// existing rule's values exactly.
  ///
  ///  [EC2-Classic only] If the values you specify do not match the existing
  /// rule's values, no error is returned. Use DescribeSecurityGroups to verify
  /// that the rule has been removed.
  ///
  /// Each rule consists of the protocol and the CIDR range or source security
  /// group. For the TCP and UDP protocols, you must also specify the
  /// destination port or range of ports. For the ICMP protocol, you must also
  /// specify the ICMP type and code. If the security group rule has a
  /// description, you do not have to specify the description to revoke the
  /// rule.
  ///
  /// Rule changes are propagated to instances within the security group as
  /// quickly as possible. However, a small delay might occur.
  ///
  /// [cidrIp]: The CIDR IP address range. You can't specify this parameter when
  /// specifying a source security group.
  ///
  /// [fromPort]: The start of port range for the TCP and UDP protocols, or an
  /// ICMP type number. For the ICMP type number, use `-1` to specify all ICMP
  /// types.
  ///
  /// [groupId]: The ID of the security group. You must specify either the
  /// security group ID or the security group name in the request. For security
  /// groups in a nondefault VPC, you must specify the security group ID.
  ///
  /// [groupName]: [EC2-Classic, default VPC] The name of the security group.
  /// You must specify either the security group ID or the security group name
  /// in the request.
  ///
  /// [ipPermissions]: The sets of IP permissions. You can't specify a source
  /// security group and a CIDR IP address range in the same set of permissions.
  ///
  /// [ipProtocol]: The IP protocol name (`tcp`, `udp`, `icmp`) or number (see
  /// [Protocol Numbers](http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)).
  /// Use `-1` to specify all.
  ///
  /// [sourceSecurityGroupName]: [EC2-Classic, default VPC] The name of the
  /// source security group. You can't specify this parameter in combination
  /// with the following parameters: the CIDR IP address range, the start of the
  /// port range, the IP protocol, and the end of the port range. For EC2-VPC,
  /// the source security group must be in the same VPC. To revoke a specific
  /// rule for an IP protocol and port range, use a set of IP permissions
  /// instead.
  ///
  /// [sourceSecurityGroupOwnerId]: [EC2-Classic] The AWS account ID of the
  /// source security group, if the source security group is in a different
  /// account. You can't specify this parameter in combination with the
  /// following parameters: the CIDR IP address range, the IP protocol, the
  /// start of the port range, and the end of the port range. To revoke a
  /// specific rule for an IP protocol and port range, use a set of IP
  /// permissions instead.
  ///
  /// [toPort]: The end of port range for the TCP and UDP protocols, or an ICMP
  /// code number. For the ICMP code number, use `-1` to specify all ICMP codes
  /// for the ICMP type.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> revokeSecurityGroupIngress(
      {String cidrIp,
      int fromPort,
      String groupId,
      String groupName,
      List<IpPermission> ipPermissions,
      String ipProtocol,
      String sourceSecurityGroupName,
      String sourceSecurityGroupOwnerId,
      int toPort,
      bool dryRun}) async {
    await _client.send('RevokeSecurityGroupIngress', {
      if (cidrIp != null) 'CidrIp': cidrIp,
      if (fromPort != null) 'FromPort': fromPort,
      if (groupId != null) 'GroupId': groupId,
      if (groupName != null) 'GroupName': groupName,
      if (ipPermissions != null) 'IpPermissions': ipPermissions,
      if (ipProtocol != null) 'IpProtocol': ipProtocol,
      if (sourceSecurityGroupName != null)
        'SourceSecurityGroupName': sourceSecurityGroupName,
      if (sourceSecurityGroupOwnerId != null)
        'SourceSecurityGroupOwnerId': sourceSecurityGroupOwnerId,
      if (toPort != null) 'ToPort': toPort,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Launches the specified number of instances using an AMI for which you have
  /// permissions.
  ///
  /// You can specify a number of options, or leave the default options. The
  /// following rules apply:
  ///
  /// *   [EC2-VPC] If you don't specify a subnet ID, we choose a default subnet
  /// from your default VPC for you. If you don't have a default VPC, you must
  /// specify a subnet ID in the request.
  ///
  /// *   [EC2-Classic] If don't specify an Availability Zone, we choose one for
  /// you.
  ///
  /// *   Some instance types must be launched into a VPC. If you do not have a
  /// default VPC, or if you do not specify a subnet ID, the request fails. For
  /// more information, see
  /// [Instance Types Available Only in a VPC](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-vpc.html#vpc-only-instance-types).
  ///
  /// *   [EC2-VPC] All instances have a network interface with a primary
  /// private IPv4 address. If you don't specify this address, we choose one
  /// from the IPv4 range of your subnet.
  ///
  /// *   Not all instance types support IPv6 addresses. For more information,
  /// see
  /// [Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html).
  ///
  /// *   If you don't specify a security group ID, we use the default security
  /// group. For more information, see
  /// [Security Groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html).
  ///
  /// *   If any of the AMIs have a product code attached for which the user has
  /// not subscribed, the request fails.
  ///
  ///
  /// You can create a
  /// [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html),
  /// which is a resource that contains the parameters to launch an instance.
  /// When you launch an instance using RunInstances, you can specify the launch
  /// template instead of specifying the launch parameters.
  ///
  /// To ensure faster instance launches, break up large requests into smaller
  /// batches. For example, create five separate launch requests for 100
  /// instances each instead of one launch request for 500 instances.
  ///
  /// An instance is ready for you to use when it's in the `running` state. You
  /// can check the state of your instance using DescribeInstances. You can tag
  /// instances and EBS volumes during launch, after launch, or both. For more
  /// information, see CreateTags and
  /// [Tagging Your Amazon EC2 Resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html).
  ///
  /// Linux instances have access to the public key of the key pair at boot. You
  /// can use this key to provide secure access to the instance. Amazon EC2
  /// public images use this feature to provide secure access without passwords.
  /// For more information, see
  /// [Key Pairs](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// For troubleshooting, see
  /// [What To Do If An Instance Immediately Terminates](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_InstanceStraightToTerminated.html),
  /// and
  /// [Troubleshooting Connecting to Your Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/TroubleshootingInstancesConnecting.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [blockDeviceMappings]: The block device mapping entries.
  ///
  /// [imageId]: The ID of the AMI. An AMI ID is required to launch an instance
  /// and must be specified here or in a launch template.
  ///
  /// [instanceType]: The instance type. For more information, see
  /// [Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// Default: `m1.small`
  ///
  /// [ipv6AddressCount]: [EC2-VPC] The number of IPv6 addresses to associate
  /// with the primary network interface. Amazon EC2 chooses the IPv6 addresses
  /// from the range of your subnet. You cannot specify this option and the
  /// option to assign specific IPv6 addresses in the same request. You can
  /// specify this option if you've specified a minimum number of instances to
  /// launch.
  ///
  /// You cannot specify this option and the network interfaces option in the
  /// same request.
  ///
  /// [ipv6Addresses]: [EC2-VPC] The IPv6 addresses from the range of the subnet
  /// to associate with the primary network interface. You cannot specify this
  /// option and the option to assign a number of IPv6 addresses in the same
  /// request. You cannot specify this option if you've specified a minimum
  /// number of instances to launch.
  ///
  /// You cannot specify this option and the network interfaces option in the
  /// same request.
  ///
  /// [kernelId]: The ID of the kernel.
  ///
  ///
  ///
  /// We recommend that you use PV-GRUB instead of kernels and RAM disks. For
  /// more information, see
  /// [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [keyName]: The name of the key pair. You can create a key pair using
  /// [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html)
  /// or
  /// [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html).
  ///
  ///
  ///
  /// If you do not specify a key pair, you can't connect to the instance unless
  /// you choose an AMI that is configured to allow users another way to log in.
  ///
  /// [maxCount]: The maximum number of instances to launch. If you specify more
  /// instances than Amazon EC2 can launch in the target Availability Zone,
  /// Amazon EC2 launches the largest possible number of instances above
  /// `MinCount`.
  ///
  /// Constraints: Between 1 and the maximum number you're allowed for the
  /// specified instance type. For more information about the default limits,
  /// and how to request an increase, see
  /// [How many instances can I run in Amazon EC2](http://aws.amazon.com/ec2/faqs/#How_many_instances_can_I_run_in_Amazon_EC2)
  /// in the Amazon EC2 FAQ.
  ///
  /// [minCount]: The minimum number of instances to launch. If you specify a
  /// minimum that is more instances than Amazon EC2 can launch in the target
  /// Availability Zone, Amazon EC2 launches no instances.
  ///
  /// Constraints: Between 1 and the maximum number you're allowed for the
  /// specified instance type. For more information about the default limits,
  /// and how to request an increase, see
  /// [How many instances can I run in Amazon EC2](http://aws.amazon.com/ec2/faqs/#How_many_instances_can_I_run_in_Amazon_EC2)
  /// in the Amazon EC2 General FAQ.
  ///
  /// [monitoring]: Specifies whether detailed monitoring is enabled for the
  /// instance.
  ///
  /// [placement]: The placement for the instance.
  ///
  /// [ramdiskId]: The ID of the RAM disk to select. Some kernels require
  /// additional drivers at launch. Check the kernel requirements for
  /// information about whether you need to specify a RAM disk. To find kernel
  /// requirements, go to the AWS Resource Center and search for the kernel ID.
  ///
  ///
  ///
  /// We recommend that you use PV-GRUB instead of kernels and RAM disks. For
  /// more information, see
  /// [PV-GRUB](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [securityGroupIds]: The IDs of the security groups. You can create a
  /// security group using
  /// [CreateSecurityGroup](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateSecurityGroup.html).
  ///
  /// If you specify a network interface, you must specify any security groups
  /// as part of the network interface.
  ///
  /// [securityGroups]: [EC2-Classic, default VPC] The names of the security
  /// groups. For a nondefault VPC, you must use security group IDs instead.
  ///
  /// If you specify a network interface, you must specify any security groups
  /// as part of the network interface.
  ///
  /// Default: Amazon EC2 uses the default security group.
  ///
  /// [subnetId]: [EC2-VPC] The ID of the subnet to launch the instance into.
  ///
  /// If you specify a network interface, you must specify any subnets as part
  /// of the network interface.
  ///
  /// [userData]: The user data to make available to the instance. For more
  /// information, see
  /// [Running Commands on Your Linux Instance at Launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html)
  /// (Linux) and
  /// [Adding User Data](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-metadata.html#instancedata-add-user-data)
  /// (Windows). If you are using a command line tool, base64-encoding is
  /// performed for you, and you can load the text from a file. Otherwise, you
  /// must provide base64-encoded text. User data is limited to 16 KB.
  ///
  /// [additionalInfo]: Reserved.
  ///
  /// [clientToken]: Unique, case-sensitive identifier you provide to ensure the
  /// idempotency of the request. For more information, see
  /// [Ensuring Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// Constraints: Maximum 64 ASCII characters
  ///
  /// [disableApiTermination]: If you set this parameter to `true`, you can't
  /// terminate the instance using the Amazon EC2 console, CLI, or API;
  /// otherwise, you can. To change this attribute after launch, use
  /// [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html).
  /// Alternatively, if you set `InstanceInitiatedShutdownBehavior` to
  /// `terminate`, you can terminate the instance by running the shutdown
  /// command from the instance.
  ///
  /// Default: `false`
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [ebsOptimized]: Indicates whether the instance is optimized for Amazon EBS
  /// I/O. This optimization provides dedicated throughput to Amazon EBS and an
  /// optimized configuration stack to provide optimal Amazon EBS I/O
  /// performance. This optimization isn't available with all instance types.
  /// Additional usage charges apply when using an EBS-optimized instance.
  ///
  /// Default: `false`
  ///
  /// [iamInstanceProfile]: The IAM instance profile.
  ///
  /// [instanceInitiatedShutdownBehavior]: Indicates whether an instance stops
  /// or terminates when you initiate shutdown from the instance (using the
  /// operating system command for system shutdown).
  ///
  /// Default: `stop`
  ///
  /// [networkInterfaces]: The network interfaces to associate with the
  /// instance. If you specify a network interface, you must specify any
  /// security groups and subnets as part of the network interface.
  ///
  /// [privateIpAddress]: [EC2-VPC] The primary IPv4 address. You must specify a
  /// value from the IPv4 address range of the subnet.
  ///
  /// Only one private IP address can be designated as primary. You can't
  /// specify this option if you've specified the option to designate a private
  /// IP address as the primary IP address in a network interface specification.
  /// You cannot specify this option if you're launching more than one instance
  /// in the request.
  ///
  /// You cannot specify this option and the network interfaces option in the
  /// same request.
  ///
  /// [elasticGpuSpecification]: An elastic GPU to associate with the instance.
  /// An Elastic GPU is a GPU resource that you can attach to your Windows
  /// instance to accelerate the graphics performance of your applications. For
  /// more information, see
  /// [Amazon EC2 Elastic GPUs](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [elasticInferenceAccelerators]: An elastic inference accelerator to
  /// associate with the instance. Elastic inference accelerators are a resource
  /// you can attach to your Amazon EC2 instances to accelerate your Deep
  /// Learning (DL) inference workloads.
  ///
  /// [tagSpecifications]: The tags to apply to the resources during launch. You
  /// can only tag instances and volumes on launch. The specified tags are
  /// applied to all instances or volumes that are created during launch. To tag
  /// a resource after it has been created, see
  /// [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html).
  ///
  /// [launchTemplate]: The launch template to use to launch the instances. Any
  /// parameters that you specify in RunInstances override the same parameters
  /// in the launch template. You can specify either the name or ID of a launch
  /// template, but not both.
  ///
  /// [instanceMarketOptions]: The market (purchasing) option for the instances.
  ///
  /// For RunInstances, persistent Spot Instance requests are only supported
  /// when **InstanceInterruptionBehavior** is set to either `hibernate` or
  /// `stop`.
  ///
  /// [creditSpecification]: The credit option for CPU usage of the T2 or T3
  /// instance. Valid values are `standard` and `unlimited`. To change this
  /// attribute after launch, use
  /// [ModifyInstanceCreditSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html).
  /// For more information, see
  /// [Burstable Performance Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// Default: `standard` (T2 instances) or `unlimited` (T3 instances)
  ///
  /// [cpuOptions]: The CPU options for the instance. For more information, see
  /// [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [capacityReservationSpecification]: Information about the Capacity
  /// Reservation targeting option. If you do not specify this parameter, the
  /// instance's Capacity Reservation preference defaults to `open`, which
  /// enables it to run in any open Capacity Reservation that has matching
  /// attributes (instance type, platform, Availability Zone).
  ///
  /// [hibernationOptions]: Indicates whether an instance is enabled for
  /// hibernation. For more information, see
  /// [Hibernate Your Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [licenseSpecifications]: The license configurations.
  Future<Reservation> runInstances(
      {List<BlockDeviceMapping> blockDeviceMappings,
      String imageId,
      String instanceType,
      int ipv6AddressCount,
      List<InstanceIpv6Address> ipv6Addresses,
      String kernelId,
      String keyName,
      @required int maxCount,
      @required int minCount,
      RunInstancesMonitoringEnabled monitoring,
      Placement placement,
      String ramdiskId,
      List<String> securityGroupIds,
      List<String> securityGroups,
      String subnetId,
      String userData,
      String additionalInfo,
      String clientToken,
      bool disableApiTermination,
      bool dryRun,
      bool ebsOptimized,
      IamInstanceProfileSpecification iamInstanceProfile,
      String instanceInitiatedShutdownBehavior,
      List<InstanceNetworkInterfaceSpecification> networkInterfaces,
      String privateIpAddress,
      List<ElasticGpuSpecification> elasticGpuSpecification,
      List<ElasticInferenceAccelerator> elasticInferenceAccelerators,
      List<TagSpecification> tagSpecifications,
      LaunchTemplateSpecification launchTemplate,
      InstanceMarketOptionsRequest instanceMarketOptions,
      CreditSpecificationRequest creditSpecification,
      CpuOptionsRequest cpuOptions,
      CapacityReservationSpecification capacityReservationSpecification,
      HibernationOptionsRequest hibernationOptions,
      List<LicenseConfigurationRequest> licenseSpecifications}) async {
    var response_ = await _client.send('RunInstances', {
      if (blockDeviceMappings != null)
        'BlockDeviceMappings': blockDeviceMappings,
      if (imageId != null) 'ImageId': imageId,
      if (instanceType != null) 'InstanceType': instanceType,
      if (ipv6AddressCount != null) 'Ipv6AddressCount': ipv6AddressCount,
      if (ipv6Addresses != null) 'Ipv6Addresses': ipv6Addresses,
      if (kernelId != null) 'KernelId': kernelId,
      if (keyName != null) 'KeyName': keyName,
      'MaxCount': maxCount,
      'MinCount': minCount,
      if (monitoring != null) 'Monitoring': monitoring,
      if (placement != null) 'Placement': placement,
      if (ramdiskId != null) 'RamdiskId': ramdiskId,
      if (securityGroupIds != null) 'SecurityGroupIds': securityGroupIds,
      if (securityGroups != null) 'SecurityGroups': securityGroups,
      if (subnetId != null) 'SubnetId': subnetId,
      if (userData != null) 'UserData': userData,
      if (additionalInfo != null) 'AdditionalInfo': additionalInfo,
      if (clientToken != null) 'ClientToken': clientToken,
      if (disableApiTermination != null)
        'DisableApiTermination': disableApiTermination,
      if (dryRun != null) 'DryRun': dryRun,
      if (ebsOptimized != null) 'EbsOptimized': ebsOptimized,
      if (iamInstanceProfile != null) 'IamInstanceProfile': iamInstanceProfile,
      if (instanceInitiatedShutdownBehavior != null)
        'InstanceInitiatedShutdownBehavior': instanceInitiatedShutdownBehavior,
      if (networkInterfaces != null) 'NetworkInterfaces': networkInterfaces,
      if (privateIpAddress != null) 'PrivateIpAddress': privateIpAddress,
      if (elasticGpuSpecification != null)
        'ElasticGpuSpecification': elasticGpuSpecification,
      if (elasticInferenceAccelerators != null)
        'ElasticInferenceAccelerators': elasticInferenceAccelerators,
      if (tagSpecifications != null) 'TagSpecifications': tagSpecifications,
      if (launchTemplate != null) 'LaunchTemplate': launchTemplate,
      if (instanceMarketOptions != null)
        'InstanceMarketOptions': instanceMarketOptions,
      if (creditSpecification != null)
        'CreditSpecification': creditSpecification,
      if (cpuOptions != null) 'CpuOptions': cpuOptions,
      if (capacityReservationSpecification != null)
        'CapacityReservationSpecification': capacityReservationSpecification,
      if (hibernationOptions != null) 'HibernationOptions': hibernationOptions,
      if (licenseSpecifications != null)
        'LicenseSpecifications': licenseSpecifications,
    });
    return Reservation.fromJson(response_);
  }

  /// Launches the specified Scheduled Instances.
  ///
  /// Before you can launch a Scheduled Instance, you must purchase it and
  /// obtain an identifier using PurchaseScheduledInstances.
  ///
  /// You must launch a Scheduled Instance during its scheduled time period. You
  /// can't stop or reboot a Scheduled Instance, but you can terminate it as
  /// needed. If you terminate a Scheduled Instance before the current scheduled
  /// time period ends, you can launch it again after a few minutes. For more
  /// information, see
  /// [Scheduled Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-scheduled-instances.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [clientToken]: Unique, case-sensitive identifier that ensures the
  /// idempotency of the request. For more information, see
  /// [Ensuring Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [instanceCount]: The number of instances.
  ///
  /// Default: 1
  ///
  /// [launchSpecification]: The launch specification. You must match the
  /// instance type, Availability Zone, network, and platform of the schedule
  /// that you purchased.
  ///
  /// [scheduledInstanceId]: The Scheduled Instance ID.
  Future<RunScheduledInstancesResult> runScheduledInstances(
      {String clientToken,
      bool dryRun,
      int instanceCount,
      @required ScheduledInstancesLaunchSpecification launchSpecification,
      @required String scheduledInstanceId}) async {
    var response_ = await _client.send('RunScheduledInstances', {
      if (clientToken != null) 'ClientToken': clientToken,
      if (dryRun != null) 'DryRun': dryRun,
      if (instanceCount != null) 'InstanceCount': instanceCount,
      'LaunchSpecification': launchSpecification,
      'ScheduledInstanceId': scheduledInstanceId,
    });
    return RunScheduledInstancesResult.fromJson(response_);
  }

  /// Searches for routes in the specified transit gateway route table.
  ///
  /// [transitGatewayRouteTableId]: The ID of the transit gateway route table.
  ///
  /// [filters]: One or more filters. The possible values are:
  ///
  /// *    `attachment.transit-gateway-attachment-id`- The id of the transit
  /// gateway attachment.
  ///
  /// *    `attachment.resource-id` - The resource id of the transit gateway
  /// attachment.
  ///
  /// *    `attachment.resource-type` - The attachment resource type (`vpc` |
  /// `vpn`).
  ///
  /// *    `route-search.exact-match` - The exact match of the specified filter.
  ///
  /// *    `route-search.longest-prefix-match` - The longest prefix that matches
  /// the route.
  ///
  /// *    `route-search.subnet-of-match` - The routes with a subnet that match
  /// the specified CIDR filter.
  ///
  /// *    `route-search.supernet-of-match` - The routes with a CIDR that
  /// encompass the CIDR filter. For example, if you have 10.0.1.0/29 and
  /// 10.0.1.0/31 routes in your route table and you specify supernet-of-match
  /// as 10.0.1.0/30, then the result returns 10.0.1.0/29.
  ///
  /// *    `state` - The state of the route (`active` | `blackhole`).
  ///
  /// *    `type` - The type of route (`propagated` | `static`).
  ///
  /// [maxResults]: The maximum number of routes to return.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<SearchTransitGatewayRoutesResult> searchTransitGatewayRoutes(
      {@required String transitGatewayRouteTableId,
      @required List<Filter> filters,
      int maxResults,
      bool dryRun}) async {
    var response_ = await _client.send('SearchTransitGatewayRoutes', {
      'TransitGatewayRouteTableId': transitGatewayRouteTableId,
      'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return SearchTransitGatewayRoutesResult.fromJson(response_);
  }

  /// Sends a diagnostic interrupt to the specified Amazon EC2 instance to
  /// trigger a _kernel panic_ (on Linux instances), or a _blue screen_/_stop
  /// error_ (on Windows instances). For instances based on Intel and AMD
  /// processors, the interrupt is received as a _non-maskable interrupt_ (NMI).
  ///
  /// In general, the operating system crashes and reboots when a kernel panic
  /// or stop error is triggered. The operating system can also be configured to
  /// perform diagnostic tasks, such as generating a memory dump file, loading a
  /// secondary kernel, or obtaining a call trace.
  ///
  /// Before sending a diagnostic interrupt to your instance, ensure that its
  /// operating system is configured to perform the required diagnostic tasks.
  ///
  /// For more information about configuring your operating system to generate a
  /// crash dump when a kernel panic or stop error occurs, see
  /// [Send a Diagnostic Interrupt](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/diagnostic-interrupt.html)
  /// (Linux instances) or
  /// [Send a Diagnostic Interrupt](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/diagnostic-interrupt.html)
  /// (Windows instances).
  ///
  /// [instanceId]: The ID of the instance.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<void> sendDiagnosticInterrupt(String instanceId, {bool dryRun}) async {
    await _client.send('SendDiagnosticInterrupt', {
      'InstanceId': instanceId,
      if (dryRun != null) 'DryRun': dryRun,
    });
  }

  /// Starts an Amazon EBS-backed instance that you've previously stopped.
  ///
  /// Instances that use Amazon EBS volumes as their root devices can be quickly
  /// stopped and started. When an instance is stopped, the compute resources
  /// are released and you are not billed for instance usage. However, your root
  /// partition Amazon EBS volume remains and continues to persist your data,
  /// and you are charged for Amazon EBS volume usage. You can restart your
  /// instance at any time. Every time you start your Windows instance, Amazon
  /// EC2 charges you for a full instance hour. If you stop and restart your
  /// Windows instance, a new instance hour begins and Amazon EC2 charges you
  /// for another full instance hour even if you are still within the same
  /// 60-minute period when it was stopped. Every time you start your Linux
  /// instance, Amazon EC2 charges a one-minute minimum for instance usage, and
  /// thereafter charges per second for instance usage.
  ///
  /// Before stopping an instance, make sure it is in a state from which it can
  /// be restarted. Stopping an instance does not preserve data stored in RAM.
  ///
  /// Performing this operation on an instance that uses an instance store as
  /// its root device returns an error.
  ///
  /// For more information, see
  /// [Stopping Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Stop_Start.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [instanceIds]: The IDs of the instances.
  ///
  /// [additionalInfo]: Reserved.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<StartInstancesResult> startInstances(List<String> instanceIds,
      {String additionalInfo, bool dryRun}) async {
    var response_ = await _client.send('StartInstances', {
      'InstanceIds': instanceIds,
      if (additionalInfo != null) 'AdditionalInfo': additionalInfo,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return StartInstancesResult.fromJson(response_);
  }

  /// Stops an Amazon EBS-backed instance.
  ///
  /// You can use the Stop action to hibernate an instance if the instance is
  /// [enabled for hibernation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#enabling-hibernation)
  /// and it meets the
  /// [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites).
  /// For more information, see
  /// [Hibernate Your Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// We don't charge usage for a stopped instance, or data transfer fees;
  /// however, your root partition Amazon EBS volume remains and continues to
  /// persist your data, and you are charged for Amazon EBS volume usage. Every
  /// time you start your Windows instance, Amazon EC2 charges you for a full
  /// instance hour. If you stop and restart your Windows instance, a new
  /// instance hour begins and Amazon EC2 charges you for another full instance
  /// hour even if you are still within the same 60-minute period when it was
  /// stopped. Every time you start your Linux instance, Amazon EC2 charges a
  /// one-minute minimum for instance usage, and thereafter charges per second
  /// for instance usage.
  ///
  /// You can't start, stop, or hibernate Spot Instances, and you can't stop or
  /// hibernate instance store-backed instances. For information about using
  /// hibernation for Spot Instances, see
  /// [Hibernating Interrupted Spot Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-interruptions.html#hibernate-spot-instances)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// When you stop or hibernate an instance, we shut it down. You can restart
  /// your instance at any time. Before stopping or hibernating an instance,
  /// make sure it is in a state from which it can be restarted. Stopping an
  /// instance does not preserve data stored in RAM, but hibernating an instance
  /// does preserve data stored in RAM. If an instance cannot hibernate
  /// successfully, a normal shutdown occurs.
  ///
  /// Stopping and hibernating an instance is different to rebooting or
  /// terminating it. For example, when you stop or hibernate an instance, the
  /// root device and any other devices attached to the instance persist. When
  /// you terminate an instance, the root device and any other devices attached
  /// during the instance launch are automatically deleted. For more information
  /// about the differences between rebooting, stopping, hibernating, and
  /// terminating instances, see
  /// [Instance Lifecycle](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-lifecycle.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// When you stop an instance, we attempt to shut it down forcibly after a
  /// short while. If your instance appears stuck in the stopping state after a
  /// period of time, there may be an issue with the underlying host computer.
  /// For more information, see
  /// [Troubleshooting Stopping Your Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/TroubleshootingInstancesStopping.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [instanceIds]: The IDs of the instances.
  ///
  /// [hibernate]: Hibernates the instance if the instance was enabled for
  /// hibernation at launch. If the instance cannot hibernate successfully, a
  /// normal shutdown occurs. For more information, see
  /// [Hibernate Your Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  ///  Default: `false`
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [force]: Forces the instances to stop. The instances do not have an
  /// opportunity to flush file system caches or file system metadata. If you
  /// use this option, you must perform file system check and repair procedures.
  /// This option is not recommended for Windows instances.
  ///
  /// Default: `false`
  Future<StopInstancesResult> stopInstances(List<String> instanceIds,
      {bool hibernate, bool dryRun, bool force}) async {
    var response_ = await _client.send('StopInstances', {
      'InstanceIds': instanceIds,
      if (hibernate != null) 'Hibernate': hibernate,
      if (dryRun != null) 'DryRun': dryRun,
      if (force != null) 'Force': force,
    });
    return StopInstancesResult.fromJson(response_);
  }

  /// Terminates active Client VPN endpoint connections. This action can be used
  /// to terminate a specific client connection, or up to five connections
  /// established by a specific user.
  ///
  /// [clientVpnEndpointId]: The ID of the Client VPN endpoint to which the
  /// client is connected.
  ///
  /// [connectionId]: The ID of the client connection to be terminated.
  ///
  /// [username]: The name of the user who initiated the connection. Use this
  /// option to terminate all active connections for the specified user. This
  /// option can only be used if the user has established up to five
  /// connections.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<TerminateClientVpnConnectionsResult> terminateClientVpnConnections(
      String clientVpnEndpointId,
      {String connectionId,
      String username,
      bool dryRun}) async {
    var response_ = await _client.send('TerminateClientVpnConnections', {
      'ClientVpnEndpointId': clientVpnEndpointId,
      if (connectionId != null) 'ConnectionId': connectionId,
      if (username != null) 'Username': username,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return TerminateClientVpnConnectionsResult.fromJson(response_);
  }

  /// Shuts down the specified instances. This operation is idempotent; if you
  /// terminate an instance more than once, each call succeeds.
  ///
  /// If you specify multiple instances and the request fails (for example,
  /// because of a single incorrect instance ID), none of the instances are
  /// terminated.
  ///
  /// Terminated instances remain visible after termination (for approximately
  /// one hour).
  ///
  /// By default, Amazon EC2 deletes all EBS volumes that were attached when the
  /// instance launched. Volumes attached after instance launch continue
  /// running.
  ///
  /// You can stop, start, and terminate EBS-backed instances. You can only
  /// terminate instance store-backed instances. What happens to an instance
  /// differs if you stop it or terminate it. For example, when you stop an
  /// instance, the root device and any other devices attached to the instance
  /// persist. When you terminate an instance, any attached EBS volumes with the
  /// `DeleteOnTermination` block device mapping parameter set to `true` are
  /// automatically deleted. For more information about the differences between
  /// stopping and terminating instances, see
  /// [Instance Lifecycle](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-lifecycle.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// For more information about troubleshooting, see
  /// [Troubleshooting Terminating Your Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/TroubleshootingInstancesShuttingDown.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [instanceIds]: The IDs of the instances.
  ///
  /// Constraints: Up to 1000 instance IDs. We recommend breaking up this
  /// request into smaller batches.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<TerminateInstancesResult> terminateInstances(List<String> instanceIds,
      {bool dryRun}) async {
    var response_ = await _client.send('TerminateInstances', {
      'InstanceIds': instanceIds,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return TerminateInstancesResult.fromJson(response_);
  }

  /// Unassigns one or more IPv6 addresses from a network interface.
  ///
  /// [ipv6Addresses]: The IPv6 addresses to unassign from the network
  /// interface.
  ///
  /// [networkInterfaceId]: The ID of the network interface.
  Future<UnassignIpv6AddressesResult> unassignIpv6Addresses(
      {@required List<String> ipv6Addresses,
      @required String networkInterfaceId}) async {
    var response_ = await _client.send('UnassignIpv6Addresses', {
      'Ipv6Addresses': ipv6Addresses,
      'NetworkInterfaceId': networkInterfaceId,
    });
    return UnassignIpv6AddressesResult.fromJson(response_);
  }

  /// Unassigns one or more secondary private IP addresses from a network
  /// interface.
  ///
  /// [networkInterfaceId]: The ID of the network interface.
  ///
  /// [privateIpAddresses]: The secondary private IP addresses to unassign from
  /// the network interface. You can specify this option multiple times to
  /// unassign more than one IP address.
  Future<void> unassignPrivateIpAddresses(
      {@required String networkInterfaceId,
      @required List<String> privateIpAddresses}) async {
    await _client.send('UnassignPrivateIpAddresses', {
      'NetworkInterfaceId': networkInterfaceId,
      'PrivateIpAddresses': privateIpAddresses,
    });
  }

  /// Disables detailed monitoring for a running instance. For more information,
  /// see
  /// [Monitoring Your Instances and Volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// [instanceIds]: The IDs of the instances.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<UnmonitorInstancesResult> unmonitorInstances(List<String> instanceIds,
      {bool dryRun}) async {
    var response_ = await _client.send('UnmonitorInstances', {
      'InstanceIds': instanceIds,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return UnmonitorInstancesResult.fromJson(response_);
  }

  /// [VPC only] Updates the description of an egress (outbound) security group
  /// rule. You can replace an existing description, or add a description to a
  /// rule that did not have one previously.
  ///
  /// You specify the description as part of the IP permissions structure. You
  /// can remove a description for a security group rule by omitting the
  /// description parameter in the request.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [groupId]: The ID of the security group. You must specify either the
  /// security group ID or the security group name in the request. For security
  /// groups in a nondefault VPC, you must specify the security group ID.
  ///
  /// [groupName]: [Default VPC] The name of the security group. You must
  /// specify either the security group ID or the security group name in the
  /// request.
  ///
  /// [ipPermissions]: The IP permissions for the security group rule.
  Future<UpdateSecurityGroupRuleDescriptionsEgressResult>
      updateSecurityGroupRuleDescriptionsEgress(
          List<IpPermission> ipPermissions,
          {bool dryRun,
          String groupId,
          String groupName}) async {
    var response_ =
        await _client.send('UpdateSecurityGroupRuleDescriptionsEgress', {
      if (dryRun != null) 'DryRun': dryRun,
      if (groupId != null) 'GroupId': groupId,
      if (groupName != null) 'GroupName': groupName,
      'IpPermissions': ipPermissions,
    });
    return UpdateSecurityGroupRuleDescriptionsEgressResult.fromJson(response_);
  }

  /// Updates the description of an ingress (inbound) security group rule. You
  /// can replace an existing description, or add a description to a rule that
  /// did not have one previously.
  ///
  /// You specify the description as part of the IP permissions structure. You
  /// can remove a description for a security group rule by omitting the
  /// description parameter in the request.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  ///
  /// [groupId]: The ID of the security group. You must specify either the
  /// security group ID or the security group name in the request. For security
  /// groups in a nondefault VPC, you must specify the security group ID.
  ///
  /// [groupName]: [EC2-Classic, default VPC] The name of the security group.
  /// You must specify either the security group ID or the security group name
  /// in the request.
  ///
  /// [ipPermissions]: The IP permissions for the security group rule.
  Future<UpdateSecurityGroupRuleDescriptionsIngressResult>
      updateSecurityGroupRuleDescriptionsIngress(
          List<IpPermission> ipPermissions,
          {bool dryRun,
          String groupId,
          String groupName}) async {
    var response_ =
        await _client.send('UpdateSecurityGroupRuleDescriptionsIngress', {
      if (dryRun != null) 'DryRun': dryRun,
      if (groupId != null) 'GroupId': groupId,
      if (groupName != null) 'GroupName': groupName,
      'IpPermissions': ipPermissions,
    });
    return UpdateSecurityGroupRuleDescriptionsIngressResult.fromJson(response_);
  }

  /// Stops advertising an IPv4 address range that is provisioned as an address
  /// pool.
  ///
  /// You can perform this operation at most once every 10 seconds, even if you
  /// specify different address ranges each time.
  ///
  /// It can take a few minutes before traffic to the specified addresses stops
  /// routing to AWS because of BGP propagation delays.
  ///
  /// [cidr]: The public IPv4 address range, in CIDR notation.
  ///
  /// [dryRun]: Checks whether you have the required permissions for the action,
  /// without actually making the request, and provides an error response. If
  /// you have the required permissions, the error response is
  /// `DryRunOperation`. Otherwise, it is `UnauthorizedOperation`.
  Future<WithdrawByoipCidrResult> withdrawByoipCidr(String cidr,
      {bool dryRun}) async {
    var response_ = await _client.send('WithdrawByoipCidr', {
      'Cidr': cidr,
      if (dryRun != null) 'DryRun': dryRun,
    });
    return WithdrawByoipCidrResult.fromJson(response_);
  }
}

/// The result of the exchange and whether it was `successful`.
class AcceptReservedInstancesExchangeQuoteResult {
  /// The ID of the successful exchange.
  final String exchangeId;

  AcceptReservedInstancesExchangeQuoteResult({
    this.exchangeId,
  });
  static AcceptReservedInstancesExchangeQuoteResult fromJson(
          Map<String, dynamic> json) =>
      AcceptReservedInstancesExchangeQuoteResult(
        exchangeId: json.containsKey('ExchangeId')
            ? json['ExchangeId'] as String
            : null,
      );
}

class AcceptTransitGatewayVpcAttachmentResult {
  /// The VPC attachment.
  final TransitGatewayVpcAttachment transitGatewayVpcAttachment;

  AcceptTransitGatewayVpcAttachmentResult({
    this.transitGatewayVpcAttachment,
  });
  static AcceptTransitGatewayVpcAttachmentResult fromJson(
          Map<String, dynamic> json) =>
      AcceptTransitGatewayVpcAttachmentResult(
        transitGatewayVpcAttachment:
            json.containsKey('TransitGatewayVpcAttachment')
                ? TransitGatewayVpcAttachment.fromJson(
                    json['TransitGatewayVpcAttachment'])
                : null,
      );
}

class AcceptVpcEndpointConnectionsResult {
  /// Information about the interface endpoints that were not accepted, if
  /// applicable.
  final List<UnsuccessfulItem> unsuccessful;

  AcceptVpcEndpointConnectionsResult({
    this.unsuccessful,
  });
  static AcceptVpcEndpointConnectionsResult fromJson(
          Map<String, dynamic> json) =>
      AcceptVpcEndpointConnectionsResult(
        unsuccessful: json.containsKey('Unsuccessful')
            ? (json['Unsuccessful'] as List)
                .map((e) => UnsuccessfulItem.fromJson(e))
                .toList()
            : null,
      );
}

class AcceptVpcPeeringConnectionResult {
  /// Information about the VPC peering connection.
  final VpcPeeringConnection vpcPeeringConnection;

  AcceptVpcPeeringConnectionResult({
    this.vpcPeeringConnection,
  });
  static AcceptVpcPeeringConnectionResult fromJson(Map<String, dynamic> json) =>
      AcceptVpcPeeringConnectionResult(
        vpcPeeringConnection: json.containsKey('VpcPeeringConnection')
            ? VpcPeeringConnection.fromJson(json['VpcPeeringConnection'])
            : null,
      );
}

/// Describes an account attribute.
class AccountAttribute {
  /// The name of the account attribute.
  final String attributeName;

  /// The values for the account attribute.
  final List<AccountAttributeValue> attributeValues;

  AccountAttribute({
    this.attributeName,
    this.attributeValues,
  });
  static AccountAttribute fromJson(Map<String, dynamic> json) =>
      AccountAttribute(
        attributeName: json.containsKey('AttributeName')
            ? json['AttributeName'] as String
            : null,
        attributeValues: json.containsKey('AttributeValues')
            ? (json['AttributeValues'] as List)
                .map((e) => AccountAttributeValue.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes a value of an account attribute.
class AccountAttributeValue {
  /// The value of the attribute.
  final String attributeValue;

  AccountAttributeValue({
    this.attributeValue,
  });
  static AccountAttributeValue fromJson(Map<String, dynamic> json) =>
      AccountAttributeValue(
        attributeValue: json.containsKey('AttributeValue')
            ? json['AttributeValue'] as String
            : null,
      );
}

/// Describes a running instance in a Spot Fleet.
class ActiveInstance {
  /// The ID of the instance.
  final String instanceId;

  /// The instance type.
  final String instanceType;

  /// The ID of the Spot Instance request.
  final String spotInstanceRequestId;

  /// The health status of the instance. If the status of either the instance
  /// status check or the system status check is `impaired`, the health status
  /// of the instance is `unhealthy`. Otherwise, the health status is `healthy`.
  final String instanceHealth;

  ActiveInstance({
    this.instanceId,
    this.instanceType,
    this.spotInstanceRequestId,
    this.instanceHealth,
  });
  static ActiveInstance fromJson(Map<String, dynamic> json) => ActiveInstance(
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        spotInstanceRequestId: json.containsKey('SpotInstanceRequestId')
            ? json['SpotInstanceRequestId'] as String
            : null,
        instanceHealth: json.containsKey('InstanceHealth')
            ? json['InstanceHealth'] as String
            : null,
      );
}

/// Describes an Elastic IP address.
class Address {
  /// The ID of the instance that the address is associated with (if any).
  final String instanceId;

  /// The Elastic IP address.
  final String publicIp;

  /// The ID representing the allocation of the address for use with EC2-VPC.
  final String allocationId;

  /// The ID representing the association of the address with an instance in a
  /// VPC.
  final String associationId;

  /// Indicates whether this Elastic IP address is for use with instances in
  /// EC2-Classic (`standard`) or instances in a VPC (`vpc`).
  final String domain;

  /// The ID of the network interface.
  final String networkInterfaceId;

  /// The ID of the AWS account that owns the network interface.
  final String networkInterfaceOwnerId;

  /// The private IP address associated with the Elastic IP address.
  final String privateIpAddress;

  /// Any tags assigned to the Elastic IP address.
  final List<Tag> tags;

  /// The ID of an address pool.
  final String publicIpv4Pool;

  Address({
    this.instanceId,
    this.publicIp,
    this.allocationId,
    this.associationId,
    this.domain,
    this.networkInterfaceId,
    this.networkInterfaceOwnerId,
    this.privateIpAddress,
    this.tags,
    this.publicIpv4Pool,
  });
  static Address fromJson(Map<String, dynamic> json) => Address(
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        publicIp:
            json.containsKey('PublicIp') ? json['PublicIp'] as String : null,
        allocationId: json.containsKey('AllocationId')
            ? json['AllocationId'] as String
            : null,
        associationId: json.containsKey('AssociationId')
            ? json['AssociationId'] as String
            : null,
        domain: json.containsKey('Domain') ? json['Domain'] as String : null,
        networkInterfaceId: json.containsKey('NetworkInterfaceId')
            ? json['NetworkInterfaceId'] as String
            : null,
        networkInterfaceOwnerId: json.containsKey('NetworkInterfaceOwnerId')
            ? json['NetworkInterfaceOwnerId'] as String
            : null,
        privateIpAddress: json.containsKey('PrivateIpAddress')
            ? json['PrivateIpAddress'] as String
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        publicIpv4Pool: json.containsKey('PublicIpv4Pool')
            ? json['PublicIpv4Pool'] as String
            : null,
      );
}

class AdvertiseByoipCidrResult {
  /// Information about the address range.
  final ByoipCidr byoipCidr;

  AdvertiseByoipCidrResult({
    this.byoipCidr,
  });
  static AdvertiseByoipCidrResult fromJson(Map<String, dynamic> json) =>
      AdvertiseByoipCidrResult(
        byoipCidr: json.containsKey('ByoipCidr')
            ? ByoipCidr.fromJson(json['ByoipCidr'])
            : null,
      );
}

class AllocateAddressResult {
  /// The Elastic IP address.
  final String publicIp;

  /// [EC2-VPC] The ID that AWS assigns to represent the allocation of the
  /// Elastic IP address for use with instances in a VPC.
  final String allocationId;

  /// The ID of an address pool.
  final String publicIpv4Pool;

  /// Indicates whether this Elastic IP address is for use with instances in
  /// EC2-Classic (`standard`) or instances in a VPC (`vpc`).
  final String domain;

  AllocateAddressResult({
    this.publicIp,
    this.allocationId,
    this.publicIpv4Pool,
    this.domain,
  });
  static AllocateAddressResult fromJson(Map<String, dynamic> json) =>
      AllocateAddressResult(
        publicIp:
            json.containsKey('PublicIp') ? json['PublicIp'] as String : null,
        allocationId: json.containsKey('AllocationId')
            ? json['AllocationId'] as String
            : null,
        publicIpv4Pool: json.containsKey('PublicIpv4Pool')
            ? json['PublicIpv4Pool'] as String
            : null,
        domain: json.containsKey('Domain') ? json['Domain'] as String : null,
      );
}

/// Contains the output of AllocateHosts.
class AllocateHostsResult {
  /// The ID of the allocated Dedicated Host. This is used to launch an instance
  /// onto a specific host.
  final List<String> hostIds;

  AllocateHostsResult({
    this.hostIds,
  });
  static AllocateHostsResult fromJson(Map<String, dynamic> json) =>
      AllocateHostsResult(
        hostIds: json.containsKey('HostIds')
            ? (json['HostIds'] as List).map((e) => e as String).toList()
            : null,
      );
}

/// Describes a principal.
class AllowedPrincipal {
  /// The type of principal.
  final String principalType;

  /// The Amazon Resource Name (ARN) of the principal.
  final String principal;

  AllowedPrincipal({
    this.principalType,
    this.principal,
  });
  static AllowedPrincipal fromJson(Map<String, dynamic> json) =>
      AllowedPrincipal(
        principalType: json.containsKey('PrincipalType')
            ? json['PrincipalType'] as String
            : null,
        principal:
            json.containsKey('Principal') ? json['Principal'] as String : null,
      );
}

class ApplySecurityGroupsToClientVpnTargetNetworkResult {
  /// The IDs of the applied security groups.
  final List<String> securityGroupIds;

  ApplySecurityGroupsToClientVpnTargetNetworkResult({
    this.securityGroupIds,
  });
  static ApplySecurityGroupsToClientVpnTargetNetworkResult fromJson(
          Map<String, dynamic> json) =>
      ApplySecurityGroupsToClientVpnTargetNetworkResult(
        securityGroupIds: json.containsKey('SecurityGroupIds')
            ? (json['SecurityGroupIds'] as List)
                .map((e) => e as String)
                .toList()
            : null,
      );
}

class AssignIpv6AddressesResult {
  /// The IPv6 addresses assigned to the network interface.
  final List<String> assignedIpv6Addresses;

  /// The ID of the network interface.
  final String networkInterfaceId;

  AssignIpv6AddressesResult({
    this.assignedIpv6Addresses,
    this.networkInterfaceId,
  });
  static AssignIpv6AddressesResult fromJson(Map<String, dynamic> json) =>
      AssignIpv6AddressesResult(
        assignedIpv6Addresses: json.containsKey('AssignedIpv6Addresses')
            ? (json['AssignedIpv6Addresses'] as List)
                .map((e) => e as String)
                .toList()
            : null,
        networkInterfaceId: json.containsKey('NetworkInterfaceId')
            ? json['NetworkInterfaceId'] as String
            : null,
      );
}

class AssignPrivateIpAddressesResult {
  /// The ID of the network interface.
  final String networkInterfaceId;

  /// The private IP addresses assigned to the network interface.
  final List<AssignedPrivateIpAddress> assignedPrivateIpAddresses;

  AssignPrivateIpAddressesResult({
    this.networkInterfaceId,
    this.assignedPrivateIpAddresses,
  });
  static AssignPrivateIpAddressesResult fromJson(Map<String, dynamic> json) =>
      AssignPrivateIpAddressesResult(
        networkInterfaceId: json.containsKey('NetworkInterfaceId')
            ? json['NetworkInterfaceId'] as String
            : null,
        assignedPrivateIpAddresses:
            json.containsKey('AssignedPrivateIpAddresses')
                ? (json['AssignedPrivateIpAddresses'] as List)
                    .map((e) => AssignedPrivateIpAddress.fromJson(e))
                    .toList()
                : null,
      );
}

/// Describes the private IP addresses assigned to a network interface.
class AssignedPrivateIpAddress {
  /// The private IP address assigned to the network interface.
  final String privateIpAddress;

  AssignedPrivateIpAddress({
    this.privateIpAddress,
  });
  static AssignedPrivateIpAddress fromJson(Map<String, dynamic> json) =>
      AssignedPrivateIpAddress(
        privateIpAddress: json.containsKey('PrivateIpAddress')
            ? json['PrivateIpAddress'] as String
            : null,
      );
}

class AssociateAddressResult {
  /// [EC2-VPC] The ID that represents the association of the Elastic IP address
  /// with an instance.
  final String associationId;

  AssociateAddressResult({
    this.associationId,
  });
  static AssociateAddressResult fromJson(Map<String, dynamic> json) =>
      AssociateAddressResult(
        associationId: json.containsKey('AssociationId')
            ? json['AssociationId'] as String
            : null,
      );
}

class AssociateClientVpnTargetNetworkResult {
  /// The unique ID of the target network association.
  final String associationId;

  /// The current state of the target network association.
  final AssociationStatus status;

  AssociateClientVpnTargetNetworkResult({
    this.associationId,
    this.status,
  });
  static AssociateClientVpnTargetNetworkResult fromJson(
          Map<String, dynamic> json) =>
      AssociateClientVpnTargetNetworkResult(
        associationId: json.containsKey('AssociationId')
            ? json['AssociationId'] as String
            : null,
        status: json.containsKey('Status')
            ? AssociationStatus.fromJson(json['Status'])
            : null,
      );
}

class AssociateIamInstanceProfileResult {
  /// Information about the IAM instance profile association.
  final IamInstanceProfileAssociation iamInstanceProfileAssociation;

  AssociateIamInstanceProfileResult({
    this.iamInstanceProfileAssociation,
  });
  static AssociateIamInstanceProfileResult fromJson(
          Map<String, dynamic> json) =>
      AssociateIamInstanceProfileResult(
        iamInstanceProfileAssociation:
            json.containsKey('IamInstanceProfileAssociation')
                ? IamInstanceProfileAssociation.fromJson(
                    json['IamInstanceProfileAssociation'])
                : null,
      );
}

class AssociateRouteTableResult {
  /// The route table association ID. This ID is required for disassociating the
  /// route table.
  final String associationId;

  AssociateRouteTableResult({
    this.associationId,
  });
  static AssociateRouteTableResult fromJson(Map<String, dynamic> json) =>
      AssociateRouteTableResult(
        associationId: json.containsKey('AssociationId')
            ? json['AssociationId'] as String
            : null,
      );
}

class AssociateSubnetCidrBlockResult {
  /// Information about the IPv6 CIDR block association.
  final SubnetIpv6CidrBlockAssociation ipv6CidrBlockAssociation;

  /// The ID of the subnet.
  final String subnetId;

  AssociateSubnetCidrBlockResult({
    this.ipv6CidrBlockAssociation,
    this.subnetId,
  });
  static AssociateSubnetCidrBlockResult fromJson(Map<String, dynamic> json) =>
      AssociateSubnetCidrBlockResult(
        ipv6CidrBlockAssociation: json.containsKey('Ipv6CidrBlockAssociation')
            ? SubnetIpv6CidrBlockAssociation.fromJson(
                json['Ipv6CidrBlockAssociation'])
            : null,
        subnetId:
            json.containsKey('SubnetId') ? json['SubnetId'] as String : null,
      );
}

class AssociateTransitGatewayRouteTableResult {
  /// The ID of the association.
  final TransitGatewayAssociation association;

  AssociateTransitGatewayRouteTableResult({
    this.association,
  });
  static AssociateTransitGatewayRouteTableResult fromJson(
          Map<String, dynamic> json) =>
      AssociateTransitGatewayRouteTableResult(
        association: json.containsKey('Association')
            ? TransitGatewayAssociation.fromJson(json['Association'])
            : null,
      );
}

class AssociateVpcCidrBlockResult {
  /// Information about the IPv6 CIDR block association.
  final VpcIpv6CidrBlockAssociation ipv6CidrBlockAssociation;

  /// Information about the IPv4 CIDR block association.
  final VpcCidrBlockAssociation cidrBlockAssociation;

  /// The ID of the VPC.
  final String vpcId;

  AssociateVpcCidrBlockResult({
    this.ipv6CidrBlockAssociation,
    this.cidrBlockAssociation,
    this.vpcId,
  });
  static AssociateVpcCidrBlockResult fromJson(Map<String, dynamic> json) =>
      AssociateVpcCidrBlockResult(
        ipv6CidrBlockAssociation: json.containsKey('Ipv6CidrBlockAssociation')
            ? VpcIpv6CidrBlockAssociation.fromJson(
                json['Ipv6CidrBlockAssociation'])
            : null,
        cidrBlockAssociation: json.containsKey('CidrBlockAssociation')
            ? VpcCidrBlockAssociation.fromJson(json['CidrBlockAssociation'])
            : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
      );
}

/// Describes a target network that is associated with a Client VPN endpoint. A
/// target network is a subnet in a VPC.
class AssociatedTargetNetwork {
  /// The ID of the subnet.
  final String networkId;

  /// The target network type.
  final String networkType;

  AssociatedTargetNetwork({
    this.networkId,
    this.networkType,
  });
  static AssociatedTargetNetwork fromJson(Map<String, dynamic> json) =>
      AssociatedTargetNetwork(
        networkId:
            json.containsKey('NetworkId') ? json['NetworkId'] as String : null,
        networkType: json.containsKey('NetworkType')
            ? json['NetworkType'] as String
            : null,
      );
}

/// Describes the state of a target network association.
class AssociationStatus {
  /// The state of the target network association.
  final String code;

  /// A message about the status of the target network association, if
  /// applicable.
  final String message;

  AssociationStatus({
    this.code,
    this.message,
  });
  static AssociationStatus fromJson(Map<String, dynamic> json) =>
      AssociationStatus(
        code: json.containsKey('Code') ? json['Code'] as String : null,
        message: json.containsKey('Message') ? json['Message'] as String : null,
      );
}

class AttachClassicLinkVpcResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool return$;

  AttachClassicLinkVpcResult({
    this.return$,
  });
  static AttachClassicLinkVpcResult fromJson(Map<String, dynamic> json) =>
      AttachClassicLinkVpcResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

/// Contains the output of AttachNetworkInterface.
class AttachNetworkInterfaceResult {
  /// The ID of the network interface attachment.
  final String attachmentId;

  AttachNetworkInterfaceResult({
    this.attachmentId,
  });
  static AttachNetworkInterfaceResult fromJson(Map<String, dynamic> json) =>
      AttachNetworkInterfaceResult(
        attachmentId: json.containsKey('AttachmentId')
            ? json['AttachmentId'] as String
            : null,
      );
}

/// Contains the output of AttachVpnGateway.
class AttachVpnGatewayResult {
  /// Information about the attachment.
  final VpcAttachment vpcAttachment;

  AttachVpnGatewayResult({
    this.vpcAttachment,
  });
  static AttachVpnGatewayResult fromJson(Map<String, dynamic> json) =>
      AttachVpnGatewayResult(
        vpcAttachment: json.containsKey('VpcAttachment')
            ? VpcAttachment.fromJson(json['VpcAttachment'])
            : null,
      );
}

/// Describes a value for a resource attribute that is a Boolean value.
class AttributeBooleanValue {
  /// The attribute value. The valid values are `true` or `false`.
  final bool value;

  AttributeBooleanValue({
    this.value,
  });
  static AttributeBooleanValue fromJson(Map<String, dynamic> json) =>
      AttributeBooleanValue(
        value: json.containsKey('Value') ? json['Value'] as bool : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a value for a resource attribute that is a String.
class AttributeValue {
  /// The attribute value. The value is case-sensitive.
  final String value;

  AttributeValue({
    this.value,
  });
  static AttributeValue fromJson(Map<String, dynamic> json) => AttributeValue(
        value: json.containsKey('Value') ? json['Value'] as String : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Information about an authorization rule.
class AuthorizationRule {
  /// The ID of the Client VPN endpoint with which the authorization rule is
  /// associated.
  final String clientVpnEndpointId;

  /// A brief description of the authorization rule.
  final String description;

  /// The ID of the Active Directory group to which the authorization rule
  /// grants access.
  final String groupId;

  /// Indicates whether the authorization rule grants access to all clients.
  final bool accessAll;

  /// The IPv4 address range, in CIDR notation, of the network to which the
  /// authorization rule applies.
  final String destinationCidr;

  /// The current state of the authorization rule.
  final ClientVpnAuthorizationRuleStatus status;

  AuthorizationRule({
    this.clientVpnEndpointId,
    this.description,
    this.groupId,
    this.accessAll,
    this.destinationCidr,
    this.status,
  });
  static AuthorizationRule fromJson(Map<String, dynamic> json) =>
      AuthorizationRule(
        clientVpnEndpointId: json.containsKey('ClientVpnEndpointId')
            ? json['ClientVpnEndpointId'] as String
            : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        groupId: json.containsKey('GroupId') ? json['GroupId'] as String : null,
        accessAll:
            json.containsKey('AccessAll') ? json['AccessAll'] as bool : null,
        destinationCidr: json.containsKey('DestinationCidr')
            ? json['DestinationCidr'] as String
            : null,
        status: json.containsKey('Status')
            ? ClientVpnAuthorizationRuleStatus.fromJson(json['Status'])
            : null,
      );
}

class AuthorizeClientVpnIngressResult {
  /// The current state of the authorization rule.
  final ClientVpnAuthorizationRuleStatus status;

  AuthorizeClientVpnIngressResult({
    this.status,
  });
  static AuthorizeClientVpnIngressResult fromJson(Map<String, dynamic> json) =>
      AuthorizeClientVpnIngressResult(
        status: json.containsKey('Status')
            ? ClientVpnAuthorizationRuleStatus.fromJson(json['Status'])
            : null,
      );
}

/// Describes an Availability Zone.
class AvailabilityZone {
  /// The state of the Availability Zone.
  final String state;

  /// Any messages about the Availability Zone.
  final List<AvailabilityZoneMessage> messages;

  /// The name of the Region.
  final String regionName;

  /// The name of the Availability Zone.
  final String zoneName;

  /// The ID of the Availability Zone.
  final String zoneId;

  AvailabilityZone({
    this.state,
    this.messages,
    this.regionName,
    this.zoneName,
    this.zoneId,
  });
  static AvailabilityZone fromJson(Map<String, dynamic> json) =>
      AvailabilityZone(
        state: json.containsKey('State') ? json['State'] as String : null,
        messages: json.containsKey('Messages')
            ? (json['Messages'] as List)
                .map((e) => AvailabilityZoneMessage.fromJson(e))
                .toList()
            : null,
        regionName: json.containsKey('RegionName')
            ? json['RegionName'] as String
            : null,
        zoneName:
            json.containsKey('ZoneName') ? json['ZoneName'] as String : null,
        zoneId: json.containsKey('ZoneId') ? json['ZoneId'] as String : null,
      );
}

/// Describes a message about an Availability Zone.
class AvailabilityZoneMessage {
  /// The message about the Availability Zone.
  final String message;

  AvailabilityZoneMessage({
    this.message,
  });
  static AvailabilityZoneMessage fromJson(Map<String, dynamic> json) =>
      AvailabilityZoneMessage(
        message: json.containsKey('Message') ? json['Message'] as String : null,
      );
}

/// The capacity information for instances launched onto the Dedicated Host.
class AvailableCapacity {
  /// The total number of instances supported by the Dedicated Host.
  final List<InstanceCapacity> availableInstanceCapacity;

  /// The number of vCPUs available on the Dedicated Host.
  final int availablevCpus;

  AvailableCapacity({
    this.availableInstanceCapacity,
    this.availablevCpus,
  });
  static AvailableCapacity fromJson(Map<String, dynamic> json) =>
      AvailableCapacity(
        availableInstanceCapacity: json.containsKey('AvailableInstanceCapacity')
            ? (json['AvailableInstanceCapacity'] as List)
                .map((e) => InstanceCapacity.fromJson(e))
                .toList()
            : null,
        availablevCpus: json.containsKey('AvailableVCpus')
            ? json['AvailableVCpus'] as int
            : null,
      );
}

class BlobAttributeValue {
  final Uint8List value;

  BlobAttributeValue({
    this.value,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a block device mapping.
class BlockDeviceMapping {
  /// The device name (for example, `/dev/sdh` or `xvdh`).
  final String deviceName;

  /// The virtual device name (`ephemeral`N). Instance store volumes are
  /// numbered starting from 0. An instance type with 2 available instance store
  /// volumes can specify mappings for `ephemeral0` and `ephemeral1`. The number
  /// of available instance store volumes depends on the instance type. After
  /// you connect to the instance, you must mount the volume.
  ///
  /// NVMe instance store volumes are automatically enumerated and assigned a
  /// device name. Including them in your block device mapping has no effect.
  ///
  /// Constraints: For M3 instances, you must specify instance store volumes in
  /// the block device mapping for the instance. When you launch an M3 instance,
  /// we ignore any instance store volumes specified in the block device mapping
  /// for the AMI.
  final String virtualName;

  /// Parameters used to automatically set up EBS volumes when the instance is
  /// launched.
  final EbsBlockDevice ebs;

  /// Suppresses the specified device included in the block device mapping of
  /// the AMI.
  final String noDevice;

  BlockDeviceMapping({
    this.deviceName,
    this.virtualName,
    this.ebs,
    this.noDevice,
  });
  static BlockDeviceMapping fromJson(Map<String, dynamic> json) =>
      BlockDeviceMapping(
        deviceName: json.containsKey('DeviceName')
            ? json['DeviceName'] as String
            : null,
        virtualName: json.containsKey('VirtualName')
            ? json['VirtualName'] as String
            : null,
        ebs: json.containsKey('Ebs')
            ? EbsBlockDevice.fromJson(json['Ebs'])
            : null,
        noDevice:
            json.containsKey('NoDevice') ? json['NoDevice'] as String : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Contains the output of BundleInstance.
class BundleInstanceResult {
  /// Information about the bundle task.
  final BundleTask bundleTask;

  BundleInstanceResult({
    this.bundleTask,
  });
  static BundleInstanceResult fromJson(Map<String, dynamic> json) =>
      BundleInstanceResult(
        bundleTask: json.containsKey('BundleTask')
            ? BundleTask.fromJson(json['BundleTask'])
            : null,
      );
}

/// Describes a bundle task.
class BundleTask {
  /// The ID of the bundle task.
  final String bundleId;

  /// If the task fails, a description of the error.
  final BundleTaskError bundleTaskError;

  /// The ID of the instance associated with this bundle task.
  final String instanceId;

  /// The level of task completion, as a percent (for example, 20%).
  final String progress;

  /// The time this task started.
  final DateTime startTime;

  /// The state of the task.
  final String state;

  /// The Amazon S3 storage locations.
  final Storage storage;

  /// The time of the most recent update for the task.
  final DateTime updateTime;

  BundleTask({
    this.bundleId,
    this.bundleTaskError,
    this.instanceId,
    this.progress,
    this.startTime,
    this.state,
    this.storage,
    this.updateTime,
  });
  static BundleTask fromJson(Map<String, dynamic> json) => BundleTask(
        bundleId:
            json.containsKey('BundleId') ? json['BundleId'] as String : null,
        bundleTaskError: json.containsKey('BundleTaskError')
            ? BundleTaskError.fromJson(json['BundleTaskError'])
            : null,
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        progress:
            json.containsKey('Progress') ? json['Progress'] as String : null,
        startTime: json.containsKey('StartTime')
            ? DateTime.parse(json['StartTime'])
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        storage: json.containsKey('Storage')
            ? Storage.fromJson(json['Storage'])
            : null,
        updateTime: json.containsKey('UpdateTime')
            ? DateTime.parse(json['UpdateTime'])
            : null,
      );
}

/// Describes an error for BundleInstance.
class BundleTaskError {
  /// The error code.
  final String code;

  /// The error message.
  final String message;

  BundleTaskError({
    this.code,
    this.message,
  });
  static BundleTaskError fromJson(Map<String, dynamic> json) => BundleTaskError(
        code: json.containsKey('Code') ? json['Code'] as String : null,
        message: json.containsKey('Message') ? json['Message'] as String : null,
      );
}

/// Information about an address range that is provisioned for use with your AWS
/// resources through bring your own IP addresses (BYOIP).
class ByoipCidr {
  /// The public IPv4 address range, in CIDR notation.
  final String cidr;

  /// The description of the address range.
  final String description;

  /// Upon success, contains the ID of the address pool. Otherwise, contains an
  /// error message.
  final String statusMessage;

  /// The state of the address pool.
  final String state;

  ByoipCidr({
    this.cidr,
    this.description,
    this.statusMessage,
    this.state,
  });
  static ByoipCidr fromJson(Map<String, dynamic> json) => ByoipCidr(
        cidr: json.containsKey('Cidr') ? json['Cidr'] as String : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        statusMessage: json.containsKey('StatusMessage')
            ? json['StatusMessage'] as String
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
      );
}

/// Contains the output of CancelBundleTask.
class CancelBundleTaskResult {
  /// Information about the bundle task.
  final BundleTask bundleTask;

  CancelBundleTaskResult({
    this.bundleTask,
  });
  static CancelBundleTaskResult fromJson(Map<String, dynamic> json) =>
      CancelBundleTaskResult(
        bundleTask: json.containsKey('BundleTask')
            ? BundleTask.fromJson(json['BundleTask'])
            : null,
      );
}

class CancelCapacityReservationResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool return$;

  CancelCapacityReservationResult({
    this.return$,
  });
  static CancelCapacityReservationResult fromJson(Map<String, dynamic> json) =>
      CancelCapacityReservationResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class CancelImportTaskResult {
  /// The ID of the task being canceled.
  final String importTaskId;

  /// The current state of the task being canceled.
  final String previousState;

  /// The current state of the task being canceled.
  final String state;

  CancelImportTaskResult({
    this.importTaskId,
    this.previousState,
    this.state,
  });
  static CancelImportTaskResult fromJson(Map<String, dynamic> json) =>
      CancelImportTaskResult(
        importTaskId: json.containsKey('ImportTaskId')
            ? json['ImportTaskId'] as String
            : null,
        previousState: json.containsKey('PreviousState')
            ? json['PreviousState'] as String
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
      );
}

/// Contains the output of CancelReservedInstancesListing.
class CancelReservedInstancesListingResult {
  /// The Reserved Instance listing.
  final List<ReservedInstancesListing> reservedInstancesListings;

  CancelReservedInstancesListingResult({
    this.reservedInstancesListings,
  });
  static CancelReservedInstancesListingResult fromJson(
          Map<String, dynamic> json) =>
      CancelReservedInstancesListingResult(
        reservedInstancesListings: json.containsKey('ReservedInstancesListings')
            ? (json['ReservedInstancesListings'] as List)
                .map((e) => ReservedInstancesListing.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes a Spot Fleet error.
class CancelSpotFleetRequestsError {
  /// The error code.
  final String code;

  /// The description for the error code.
  final String message;

  CancelSpotFleetRequestsError({
    this.code,
    this.message,
  });
  static CancelSpotFleetRequestsError fromJson(Map<String, dynamic> json) =>
      CancelSpotFleetRequestsError(
        code: json.containsKey('Code') ? json['Code'] as String : null,
        message: json.containsKey('Message') ? json['Message'] as String : null,
      );
}

/// Describes a Spot Fleet request that was not successfully canceled.
class CancelSpotFleetRequestsErrorItem {
  /// The error.
  final CancelSpotFleetRequestsError error;

  /// The ID of the Spot Fleet request.
  final String spotFleetRequestId;

  CancelSpotFleetRequestsErrorItem({
    this.error,
    this.spotFleetRequestId,
  });
  static CancelSpotFleetRequestsErrorItem fromJson(Map<String, dynamic> json) =>
      CancelSpotFleetRequestsErrorItem(
        error: json.containsKey('Error')
            ? CancelSpotFleetRequestsError.fromJson(json['Error'])
            : null,
        spotFleetRequestId: json.containsKey('SpotFleetRequestId')
            ? json['SpotFleetRequestId'] as String
            : null,
      );
}

/// Contains the output of CancelSpotFleetRequests.
class CancelSpotFleetRequestsResponse {
  /// Information about the Spot Fleet requests that are successfully canceled.
  final List<CancelSpotFleetRequestsSuccessItem> successfulFleetRequests;

  /// Information about the Spot Fleet requests that are not successfully
  /// canceled.
  final List<CancelSpotFleetRequestsErrorItem> unsuccessfulFleetRequests;

  CancelSpotFleetRequestsResponse({
    this.successfulFleetRequests,
    this.unsuccessfulFleetRequests,
  });
  static CancelSpotFleetRequestsResponse fromJson(Map<String, dynamic> json) =>
      CancelSpotFleetRequestsResponse(
        successfulFleetRequests: json.containsKey('SuccessfulFleetRequests')
            ? (json['SuccessfulFleetRequests'] as List)
                .map((e) => CancelSpotFleetRequestsSuccessItem.fromJson(e))
                .toList()
            : null,
        unsuccessfulFleetRequests: json.containsKey('UnsuccessfulFleetRequests')
            ? (json['UnsuccessfulFleetRequests'] as List)
                .map((e) => CancelSpotFleetRequestsErrorItem.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes a Spot Fleet request that was successfully canceled.
class CancelSpotFleetRequestsSuccessItem {
  /// The current state of the Spot Fleet request.
  final String currentSpotFleetRequestState;

  /// The previous state of the Spot Fleet request.
  final String previousSpotFleetRequestState;

  /// The ID of the Spot Fleet request.
  final String spotFleetRequestId;

  CancelSpotFleetRequestsSuccessItem({
    this.currentSpotFleetRequestState,
    this.previousSpotFleetRequestState,
    this.spotFleetRequestId,
  });
  static CancelSpotFleetRequestsSuccessItem fromJson(
          Map<String, dynamic> json) =>
      CancelSpotFleetRequestsSuccessItem(
        currentSpotFleetRequestState:
            json.containsKey('CurrentSpotFleetRequestState')
                ? json['CurrentSpotFleetRequestState'] as String
                : null,
        previousSpotFleetRequestState:
            json.containsKey('PreviousSpotFleetRequestState')
                ? json['PreviousSpotFleetRequestState'] as String
                : null,
        spotFleetRequestId: json.containsKey('SpotFleetRequestId')
            ? json['SpotFleetRequestId'] as String
            : null,
      );
}

/// Contains the output of CancelSpotInstanceRequests.
class CancelSpotInstanceRequestsResult {
  /// One or more Spot Instance requests.
  final List<CancelledSpotInstanceRequest> cancelledSpotInstanceRequests;

  CancelSpotInstanceRequestsResult({
    this.cancelledSpotInstanceRequests,
  });
  static CancelSpotInstanceRequestsResult fromJson(Map<String, dynamic> json) =>
      CancelSpotInstanceRequestsResult(
        cancelledSpotInstanceRequests:
            json.containsKey('CancelledSpotInstanceRequests')
                ? (json['CancelledSpotInstanceRequests'] as List)
                    .map((e) => CancelledSpotInstanceRequest.fromJson(e))
                    .toList()
                : null,
      );
}

/// Describes a request to cancel a Spot Instance.
class CancelledSpotInstanceRequest {
  /// The ID of the Spot Instance request.
  final String spotInstanceRequestId;

  /// The state of the Spot Instance request.
  final String state;

  CancelledSpotInstanceRequest({
    this.spotInstanceRequestId,
    this.state,
  });
  static CancelledSpotInstanceRequest fromJson(Map<String, dynamic> json) =>
      CancelledSpotInstanceRequest(
        spotInstanceRequestId: json.containsKey('SpotInstanceRequestId')
            ? json['SpotInstanceRequestId'] as String
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
      );
}

/// Describes a Capacity Reservation.
class CapacityReservation {
  /// The ID of the Capacity Reservation.
  final String capacityReservationId;

  /// The ID of the AWS account that owns the Capacity Reservation.
  final String ownerId;

  /// The Amazon Resource Name (ARN) of the Capacity Reservation.
  final String capacityReservationArn;

  /// The Availability Zone ID of the Capacity Reservation.
  final String availabilityZoneId;

  /// The type of instance for which the Capacity Reservation reserves capacity.
  final String instanceType;

  /// The type of operating system for which the Capacity Reservation reserves
  /// capacity.
  final String instancePlatform;

  /// The Availability Zone in which the capacity is reserved.
  final String availabilityZone;

  /// Indicates the tenancy of the Capacity Reservation. A Capacity Reservation
  /// can have one of the following tenancy settings:
  ///
  /// *    `default` - The Capacity Reservation is created on hardware that is
  /// shared with other AWS accounts.
  ///
  /// *    `dedicated` - The Capacity Reservation is created on single-tenant
  /// hardware that is dedicated to a single AWS account.
  final String tenancy;

  /// The total number of instances for which the Capacity Reservation reserves
  /// capacity.
  final int totalInstanceCount;

  /// The remaining capacity. Indicates the number of instances that can be
  /// launched in the Capacity Reservation.
  final int availableInstanceCount;

  /// Indicates whether the Capacity Reservation supports EBS-optimized
  /// instances. This optimization provides dedicated throughput to Amazon EBS
  /// and an optimized configuration stack to provide optimal I/O performance.
  /// This optimization isn't available with all instance types. Additional
  /// usage charges apply when using an EBS- optimized instance.
  final bool ebsOptimized;

  /// Indicates whether the Capacity Reservation supports instances with
  /// temporary, block-level storage.
  final bool ephemeralStorage;

  /// The current state of the Capacity Reservation. A Capacity Reservation can
  /// be in one of the following states:
  ///
  /// *    `active` - The Capacity Reservation is active and the capacity is
  /// available for your use.
  ///
  /// *    `expired` - The Capacity Reservation expired automatically at the
  /// date and time specified in your request. The reserved capacity is no
  /// longer available for your use.
  ///
  /// *    `cancelled` - The Capacity Reservation was manually cancelled. The
  /// reserved capacity is no longer available for your use.
  ///
  /// *    `pending` - The Capacity Reservation request was successful but the
  /// capacity provisioning is still pending.
  ///
  /// *    `failed` - The Capacity Reservation request has failed. A request
  /// might fail due to invalid request parameters, capacity constraints, or
  /// instance limit constraints. Failed requests are retained for 60 minutes.
  final String state;

  /// The date and time at which the Capacity Reservation expires. When a
  /// Capacity Reservation expires, the reserved capacity is released and you
  /// can no longer launch instances into it. The Capacity Reservation's state
  /// changes to `expired` when it reaches its end date and time.
  final DateTime endDate;

  /// Indicates the way in which the Capacity Reservation ends. A Capacity
  /// Reservation can have one of the following end types:
  ///
  /// *    `unlimited` - The Capacity Reservation remains active until you
  /// explicitly cancel it.
  ///
  /// *    `limited` - The Capacity Reservation expires automatically at a
  /// specified date and time.
  final String endDateType;

  /// Indicates the type of instance launches that the Capacity Reservation
  /// accepts. The options include:
  ///
  /// *    `open` - The Capacity Reservation accepts all instances that have
  /// matching attributes (instance type, platform, and Availability Zone).
  /// Instances that have matching attributes launch into the Capacity
  /// Reservation automatically without specifying any additional parameters.
  ///
  /// *    `targeted` - The Capacity Reservation only accepts instances that
  /// have matching attributes (instance type, platform, and Availability Zone),
  /// and explicitly target the Capacity Reservation. This ensures that only
  /// permitted instances can use the reserved capacity.
  final String instanceMatchCriteria;

  /// The date and time at which the Capacity Reservation was created.
  final DateTime createDate;

  /// Any tags assigned to the Capacity Reservation.
  final List<Tag> tags;

  CapacityReservation({
    this.capacityReservationId,
    this.ownerId,
    this.capacityReservationArn,
    this.availabilityZoneId,
    this.instanceType,
    this.instancePlatform,
    this.availabilityZone,
    this.tenancy,
    this.totalInstanceCount,
    this.availableInstanceCount,
    this.ebsOptimized,
    this.ephemeralStorage,
    this.state,
    this.endDate,
    this.endDateType,
    this.instanceMatchCriteria,
    this.createDate,
    this.tags,
  });
  static CapacityReservation fromJson(Map<String, dynamic> json) =>
      CapacityReservation(
        capacityReservationId: json.containsKey('CapacityReservationId')
            ? json['CapacityReservationId'] as String
            : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        capacityReservationArn: json.containsKey('CapacityReservationArn')
            ? json['CapacityReservationArn'] as String
            : null,
        availabilityZoneId: json.containsKey('AvailabilityZoneId')
            ? json['AvailabilityZoneId'] as String
            : null,
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        instancePlatform: json.containsKey('InstancePlatform')
            ? json['InstancePlatform'] as String
            : null,
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        tenancy: json.containsKey('Tenancy') ? json['Tenancy'] as String : null,
        totalInstanceCount: json.containsKey('TotalInstanceCount')
            ? json['TotalInstanceCount'] as int
            : null,
        availableInstanceCount: json.containsKey('AvailableInstanceCount')
            ? json['AvailableInstanceCount'] as int
            : null,
        ebsOptimized: json.containsKey('EbsOptimized')
            ? json['EbsOptimized'] as bool
            : null,
        ephemeralStorage: json.containsKey('EphemeralStorage')
            ? json['EphemeralStorage'] as bool
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        endDate: json.containsKey('EndDate')
            ? DateTime.parse(json['EndDate'])
            : null,
        endDateType: json.containsKey('EndDateType')
            ? json['EndDateType'] as String
            : null,
        instanceMatchCriteria: json.containsKey('InstanceMatchCriteria')
            ? json['InstanceMatchCriteria'] as String
            : null,
        createDate: json.containsKey('CreateDate')
            ? DateTime.parse(json['CreateDate'])
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes an instance's Capacity Reservation targeting option. You can
/// specify only one parameter at a time. If you specify
/// `CapacityReservationPreference` and `CapacityReservationTarget`, the request
/// fails.
///
/// Use the `CapacityReservationPreference` parameter to configure the instance
/// to run as an On-Demand Instance or to run in any `open` Capacity Reservation
/// that has matching attributes (instance type, platform, Availability Zone).
/// Use the `CapacityReservationTarget` parameter to explicitly target a
/// specific Capacity Reservation.
class CapacityReservationSpecification {
  /// Indicates the instance's Capacity Reservation preferences. Possible
  /// preferences include:
  ///
  /// *    `open` - The instance can run in any `open` Capacity Reservation that
  /// has matching attributes (instance type, platform, Availability Zone).
  ///
  /// *    `none` - The instance avoids running in a Capacity Reservation even
  /// if one is available. The instance runs as an On-Demand Instance.
  final String capacityReservationPreference;

  /// Information about the target Capacity Reservation.
  final CapacityReservationTarget capacityReservationTarget;

  CapacityReservationSpecification({
    this.capacityReservationPreference,
    this.capacityReservationTarget,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the instance's Capacity Reservation targeting preferences. The
/// action returns the `capacityReservationPreference` response element if the
/// instance is configured to run in On-Demand capacity, or if it is configured
/// in run in any `open` Capacity Reservation that has matching attributes
/// (instance type, platform, Availability Zone). The action returns the
/// `capacityReservationTarget` response element if the instance explicily
/// targets a specific Capacity Reservation.
class CapacityReservationSpecificationResponse {
  /// Describes the instance's Capacity Reservation preferences. Possible
  /// preferences include:
  ///
  /// *    `open` - The instance can run in any `open` Capacity Reservation that
  /// has matching attributes (instance type, platform, Availability Zone).
  ///
  /// *    `none` - The instance avoids running in a Capacity Reservation even
  /// if one is available. The instance runs in On-Demand capacity.
  final String capacityReservationPreference;

  /// Information about the targeted Capacity Reservation.
  final CapacityReservationTargetResponse capacityReservationTarget;

  CapacityReservationSpecificationResponse({
    this.capacityReservationPreference,
    this.capacityReservationTarget,
  });
  static CapacityReservationSpecificationResponse fromJson(
          Map<String, dynamic> json) =>
      CapacityReservationSpecificationResponse(
        capacityReservationPreference:
            json.containsKey('CapacityReservationPreference')
                ? json['CapacityReservationPreference'] as String
                : null,
        capacityReservationTarget: json.containsKey('CapacityReservationTarget')
            ? CapacityReservationTargetResponse.fromJson(
                json['CapacityReservationTarget'])
            : null,
      );
}

/// Describes a target Capacity Reservation.
class CapacityReservationTarget {
  /// The ID of the Capacity Reservation.
  final String capacityReservationId;

  CapacityReservationTarget({
    this.capacityReservationId,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a target Capacity Reservation.
class CapacityReservationTargetResponse {
  /// The ID of the Capacity Reservation.
  final String capacityReservationId;

  CapacityReservationTargetResponse({
    this.capacityReservationId,
  });
  static CapacityReservationTargetResponse fromJson(
          Map<String, dynamic> json) =>
      CapacityReservationTargetResponse(
        capacityReservationId: json.containsKey('CapacityReservationId')
            ? json['CapacityReservationId'] as String
            : null,
      );
}

/// Information about the client certificate used for authentication.
class CertificateAuthentication {
  /// The ARN of the client certificate.
  final String clientRootCertificateChain;

  CertificateAuthentication({
    this.clientRootCertificateChain,
  });
  static CertificateAuthentication fromJson(Map<String, dynamic> json) =>
      CertificateAuthentication(
        clientRootCertificateChain:
            json.containsKey('ClientRootCertificateChain')
                ? json['ClientRootCertificateChain'] as String
                : null,
      );
}

/// Information about the client certificate to be used for authentication.
class CertificateAuthenticationRequest {
  /// The ARN of the client certificate. The certificate must be signed by a
  /// certificate authority (CA) and it must be provisioned in AWS Certificate
  /// Manager (ACM).
  final String clientRootCertificateChainArn;

  CertificateAuthenticationRequest({
    this.clientRootCertificateChainArn,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Provides authorization for Amazon to bring a specific IP address range to a
/// specific AWS account using bring your own IP addresses (BYOIP). For more
/// information, see
/// [Prepare to Bring Your Address Range to Your AWS Account](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-byoip.html#prepare-for-byoip)
/// in the _Amazon Elastic Compute Cloud User Guide_.
class CidrAuthorizationContext {
  /// The plain-text authorization message for the prefix and account.
  final String message;

  /// The signed authorization message for the prefix and account.
  final String signature;

  CidrAuthorizationContext({
    @required this.message,
    @required this.signature,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes an IPv4 CIDR block.
class CidrBlock {
  /// The IPv4 CIDR block.
  final String cidrBlock;

  CidrBlock({
    this.cidrBlock,
  });
  static CidrBlock fromJson(Map<String, dynamic> json) => CidrBlock(
        cidrBlock:
            json.containsKey('CidrBlock') ? json['CidrBlock'] as String : null,
      );
}

/// Describes the ClassicLink DNS support status of a VPC.
class ClassicLinkDnsSupport {
  /// Indicates whether ClassicLink DNS support is enabled for the VPC.
  final bool classicLinkDnsSupported;

  /// The ID of the VPC.
  final String vpcId;

  ClassicLinkDnsSupport({
    this.classicLinkDnsSupported,
    this.vpcId,
  });
  static ClassicLinkDnsSupport fromJson(Map<String, dynamic> json) =>
      ClassicLinkDnsSupport(
        classicLinkDnsSupported: json.containsKey('ClassicLinkDnsSupported')
            ? json['ClassicLinkDnsSupported'] as bool
            : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
      );
}

/// Describes a linked EC2-Classic instance.
class ClassicLinkInstance {
  /// A list of security groups.
  final List<GroupIdentifier> groups;

  /// The ID of the instance.
  final String instanceId;

  /// Any tags assigned to the instance.
  final List<Tag> tags;

  /// The ID of the VPC.
  final String vpcId;

  ClassicLinkInstance({
    this.groups,
    this.instanceId,
    this.tags,
    this.vpcId,
  });
  static ClassicLinkInstance fromJson(Map<String, dynamic> json) =>
      ClassicLinkInstance(
        groups: json.containsKey('Groups')
            ? (json['Groups'] as List)
                .map((e) => GroupIdentifier.fromJson(e))
                .toList()
            : null,
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
      );
}

/// Describes a Classic Load Balancer.
class ClassicLoadBalancer {
  /// The name of the load balancer.
  final String name;

  ClassicLoadBalancer({
    this.name,
  });
  static ClassicLoadBalancer fromJson(Map<String, dynamic> json) =>
      ClassicLoadBalancer(
        name: json.containsKey('Name') ? json['Name'] as String : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the Classic Load Balancers to attach to a Spot Fleet. Spot Fleet
/// registers the running Spot Instances with these Classic Load Balancers.
class ClassicLoadBalancersConfig {
  /// One or more Classic Load Balancers.
  final List<ClassicLoadBalancer> classicLoadBalancers;

  ClassicLoadBalancersConfig({
    this.classicLoadBalancers,
  });
  static ClassicLoadBalancersConfig fromJson(Map<String, dynamic> json) =>
      ClassicLoadBalancersConfig(
        classicLoadBalancers: json.containsKey('ClassicLoadBalancers')
            ? (json['ClassicLoadBalancers'] as List)
                .map((e) => ClassicLoadBalancer.fromJson(e))
                .toList()
            : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the state of a client certificate revocation list.
class ClientCertificateRevocationListStatus {
  /// The state of the client certificate revocation list.
  final String code;

  /// A message about the status of the client certificate revocation list, if
  /// applicable.
  final String message;

  ClientCertificateRevocationListStatus({
    this.code,
    this.message,
  });
  static ClientCertificateRevocationListStatus fromJson(
          Map<String, dynamic> json) =>
      ClientCertificateRevocationListStatus(
        code: json.containsKey('Code') ? json['Code'] as String : null,
        message: json.containsKey('Message') ? json['Message'] as String : null,
      );
}

/// Describes the client-specific data.
class ClientData {
  /// A user-defined comment about the disk upload.
  final String comment;

  /// The time that the disk upload ends.
  final DateTime uploadEnd;

  /// The size of the uploaded disk image, in GiB.
  final double uploadSize;

  /// The time that the disk upload starts.
  final DateTime uploadStart;

  ClientData({
    this.comment,
    this.uploadEnd,
    this.uploadSize,
    this.uploadStart,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the authentication methods used by a Client VPN endpoint. Client
/// VPN supports Active Directory and mutual authentication. For more
/// information, see
/// [Authentication](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/authentication-authrization.html#client-authentication)
/// in the _AWS Client VPN Administrator Guide_.
class ClientVpnAuthentication {
  /// The authentication type used.
  final String type;

  /// Information about the Active Directory, if applicable.
  final DirectoryServiceAuthentication activeDirectory;

  /// Information about the authentication certificates, if applicable.
  final CertificateAuthentication mutualAuthentication;

  ClientVpnAuthentication({
    this.type,
    this.activeDirectory,
    this.mutualAuthentication,
  });
  static ClientVpnAuthentication fromJson(Map<String, dynamic> json) =>
      ClientVpnAuthentication(
        type: json.containsKey('Type') ? json['Type'] as String : null,
        activeDirectory: json.containsKey('ActiveDirectory')
            ? DirectoryServiceAuthentication.fromJson(json['ActiveDirectory'])
            : null,
        mutualAuthentication: json.containsKey('MutualAuthentication')
            ? CertificateAuthentication.fromJson(json['MutualAuthentication'])
            : null,
      );
}

/// Describes the authentication method to be used by a Client VPN endpoint.
/// Client VPN supports Active Directory and mutual authentication. For more
/// information, see
/// [Authentication](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/authentication-authrization.html#client-authentication)
/// in the _AWS Client VPN Administrator Guide_.
class ClientVpnAuthenticationRequest {
  /// The type of client authentication to be used. Specify
  /// `certificate-authentication` to use certificate-based authentication, or
  /// `directory-service-authentication` to use Active Directory authentication.
  final String type;

  /// Information about the Active Directory to be used, if applicable. You must
  /// provide this information if **Type** is
  /// `directory-service-authentication`.
  final DirectoryServiceAuthenticationRequest activeDirectory;

  /// Information about the authentication certificates to be used, if
  /// applicable. You must provide this information if **Type** is
  /// `certificate-authentication`.
  final CertificateAuthenticationRequest mutualAuthentication;

  ClientVpnAuthenticationRequest({
    this.type,
    this.activeDirectory,
    this.mutualAuthentication,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the state of an authorization rule.
class ClientVpnAuthorizationRuleStatus {
  /// The state of the authorization rule.
  final String code;

  /// A message about the status of the authorization rule, if applicable.
  final String message;

  ClientVpnAuthorizationRuleStatus({
    this.code,
    this.message,
  });
  static ClientVpnAuthorizationRuleStatus fromJson(Map<String, dynamic> json) =>
      ClientVpnAuthorizationRuleStatus(
        code: json.containsKey('Code') ? json['Code'] as String : null,
        message: json.containsKey('Message') ? json['Message'] as String : null,
      );
}

/// Describes a client connection.
class ClientVpnConnection {
  /// The ID of the Client VPN endpoint to which the client is connected.
  final String clientVpnEndpointId;

  /// The current date and time.
  final String timestamp;

  /// The ID of the client connection.
  final String connectionId;

  /// The username of the client who established the client connection. This
  /// information is only provided if Active Directory client authentication is
  /// used.
  final String username;

  /// The date and time the client connection was established.
  final String connectionEstablishedTime;

  /// The number of bytes sent by the client.
  final String ingressBytes;

  /// The number of bytes received by the client.
  final String egressBytes;

  /// The number of packets sent by the client.
  final String ingressPackets;

  /// The number of packets received by the client.
  final String egressPackets;

  /// The IP address of the client.
  final String clientIp;

  /// The common name associated with the client. This is either the name of the
  /// client certificate, or the Active Directory user name.
  final String commonName;

  /// The current state of the client connection.
  final ClientVpnConnectionStatus status;

  /// The date and time the client connection was terminated.
  final String connectionEndTime;

  ClientVpnConnection({
    this.clientVpnEndpointId,
    this.timestamp,
    this.connectionId,
    this.username,
    this.connectionEstablishedTime,
    this.ingressBytes,
    this.egressBytes,
    this.ingressPackets,
    this.egressPackets,
    this.clientIp,
    this.commonName,
    this.status,
    this.connectionEndTime,
  });
  static ClientVpnConnection fromJson(Map<String, dynamic> json) =>
      ClientVpnConnection(
        clientVpnEndpointId: json.containsKey('ClientVpnEndpointId')
            ? json['ClientVpnEndpointId'] as String
            : null,
        timestamp:
            json.containsKey('Timestamp') ? json['Timestamp'] as String : null,
        connectionId: json.containsKey('ConnectionId')
            ? json['ConnectionId'] as String
            : null,
        username:
            json.containsKey('Username') ? json['Username'] as String : null,
        connectionEstablishedTime: json.containsKey('ConnectionEstablishedTime')
            ? json['ConnectionEstablishedTime'] as String
            : null,
        ingressBytes: json.containsKey('IngressBytes')
            ? json['IngressBytes'] as String
            : null,
        egressBytes: json.containsKey('EgressBytes')
            ? json['EgressBytes'] as String
            : null,
        ingressPackets: json.containsKey('IngressPackets')
            ? json['IngressPackets'] as String
            : null,
        egressPackets: json.containsKey('EgressPackets')
            ? json['EgressPackets'] as String
            : null,
        clientIp:
            json.containsKey('ClientIp') ? json['ClientIp'] as String : null,
        commonName: json.containsKey('CommonName')
            ? json['CommonName'] as String
            : null,
        status: json.containsKey('Status')
            ? ClientVpnConnectionStatus.fromJson(json['Status'])
            : null,
        connectionEndTime: json.containsKey('ConnectionEndTime')
            ? json['ConnectionEndTime'] as String
            : null,
      );
}

/// Describes the status of a client connection.
class ClientVpnConnectionStatus {
  /// The state of the client connection.
  final String code;

  /// A message about the status of the client connection, if applicable.
  final String message;

  ClientVpnConnectionStatus({
    this.code,
    this.message,
  });
  static ClientVpnConnectionStatus fromJson(Map<String, dynamic> json) =>
      ClientVpnConnectionStatus(
        code: json.containsKey('Code') ? json['Code'] as String : null,
        message: json.containsKey('Message') ? json['Message'] as String : null,
      );
}

/// Describes a Client VPN endpoint.
class ClientVpnEndpoint {
  /// The ID of the Client VPN endpoint.
  final String clientVpnEndpointId;

  /// A brief description of the endpoint.
  final String description;

  /// The current state of the Client VPN endpoint.
  final ClientVpnEndpointStatus status;

  /// The date and time the Client VPN endpoint was created.
  final String creationTime;

  /// The date and time the Client VPN endpoint was deleted, if applicable.
  final String deletionTime;

  /// The DNS name to be used by clients when connecting to the Client VPN
  /// endpoint.
  final String dnsName;

  /// The IPv4 address range, in CIDR notation, from which client IP addresses
  /// are assigned.
  final String clientCidrBlock;

  /// Information about the DNS servers to be used for DNS resolution.
  final List<String> dnsServers;

  /// Indicates whether split-tunnel is enabled in the AWS Client VPN endpoint.
  ///
  /// For information about split-tunnel VPN endpoints, see
  /// [Split-Tunnel AWS Client VPN Endpoint](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html)
  /// in the _AWS Client VPN Administrator Guide_.
  final bool splitTunnel;

  /// The protocol used by the VPN session.
  final String vpnProtocol;

  /// The transport protocol used by the Client VPN endpoint.
  final String transportProtocol;

  /// Information about the associated target networks. A target network is a
  /// subnet in a VPC.
  final List<AssociatedTargetNetwork> associatedTargetNetworks;

  /// The ARN of the server certificate.
  final String serverCertificateArn;

  /// Information about the authentication method used by the Client VPN
  /// endpoint.
  final List<ClientVpnAuthentication> authenticationOptions;

  /// Information about the client connection logging options for the Client VPN
  /// endpoint.
  final ConnectionLogResponseOptions connectionLogOptions;

  /// Any tags assigned to the Client VPN endpoint.
  final List<Tag> tags;

  ClientVpnEndpoint({
    this.clientVpnEndpointId,
    this.description,
    this.status,
    this.creationTime,
    this.deletionTime,
    this.dnsName,
    this.clientCidrBlock,
    this.dnsServers,
    this.splitTunnel,
    this.vpnProtocol,
    this.transportProtocol,
    this.associatedTargetNetworks,
    this.serverCertificateArn,
    this.authenticationOptions,
    this.connectionLogOptions,
    this.tags,
  });
  static ClientVpnEndpoint fromJson(Map<String, dynamic> json) =>
      ClientVpnEndpoint(
        clientVpnEndpointId: json.containsKey('ClientVpnEndpointId')
            ? json['ClientVpnEndpointId'] as String
            : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        status: json.containsKey('Status')
            ? ClientVpnEndpointStatus.fromJson(json['Status'])
            : null,
        creationTime: json.containsKey('CreationTime')
            ? json['CreationTime'] as String
            : null,
        deletionTime: json.containsKey('DeletionTime')
            ? json['DeletionTime'] as String
            : null,
        dnsName: json.containsKey('DnsName') ? json['DnsName'] as String : null,
        clientCidrBlock: json.containsKey('ClientCidrBlock')
            ? json['ClientCidrBlock'] as String
            : null,
        dnsServers: json.containsKey('DnsServers')
            ? (json['DnsServers'] as List).map((e) => e as String).toList()
            : null,
        splitTunnel: json.containsKey('SplitTunnel')
            ? json['SplitTunnel'] as bool
            : null,
        vpnProtocol: json.containsKey('VpnProtocol')
            ? json['VpnProtocol'] as String
            : null,
        transportProtocol: json.containsKey('TransportProtocol')
            ? json['TransportProtocol'] as String
            : null,
        associatedTargetNetworks: json.containsKey('AssociatedTargetNetworks')
            ? (json['AssociatedTargetNetworks'] as List)
                .map((e) => AssociatedTargetNetwork.fromJson(e))
                .toList()
            : null,
        serverCertificateArn: json.containsKey('ServerCertificateArn')
            ? json['ServerCertificateArn'] as String
            : null,
        authenticationOptions: json.containsKey('AuthenticationOptions')
            ? (json['AuthenticationOptions'] as List)
                .map((e) => ClientVpnAuthentication.fromJson(e))
                .toList()
            : null,
        connectionLogOptions: json.containsKey('ConnectionLogOptions')
            ? ConnectionLogResponseOptions.fromJson(
                json['ConnectionLogOptions'])
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes the state of a Client VPN endpoint.
class ClientVpnEndpointStatus {
  /// The state of the Client VPN endpoint. Possible states include:
  ///
  /// *    `pending-associate` - The Client VPN endpoint has been created but no
  /// target networks have been associated. The Client VPN endpoint cannot
  /// accept connections.
  ///
  /// *    `available` - The Client VPN endpoint has been created and a target
  /// network has been associated. The Client VPN endpoint can accept
  /// connections.
  ///
  /// *    `deleting` - The Client VPN endpoint is being deleted. The Client VPN
  /// endpoint cannot accept connections.
  ///
  /// *    `deleted` - The Client VPN endpoint has been deleted. The Client VPN
  /// endpoint cannot accept connections.
  final String code;

  /// A message about the status of the Client VPN endpoint.
  final String message;

  ClientVpnEndpointStatus({
    this.code,
    this.message,
  });
  static ClientVpnEndpointStatus fromJson(Map<String, dynamic> json) =>
      ClientVpnEndpointStatus(
        code: json.containsKey('Code') ? json['Code'] as String : null,
        message: json.containsKey('Message') ? json['Message'] as String : null,
      );
}

/// Information about a Client VPN endpoint route.
class ClientVpnRoute {
  /// The ID of the Client VPN endpoint with which the route is associated.
  final String clientVpnEndpointId;

  /// The IPv4 address range, in CIDR notation, of the route destination.
  final String destinationCidr;

  /// The ID of the subnet through which traffic is routed.
  final String targetSubnet;

  /// The route type.
  final String type;

  /// Indicates how the route was associated with the Client VPN endpoint.
  /// `associate` indicates that the route was automatically added when the
  /// target network was associated with the Client VPN endpoint. `add-route`
  /// indicates that the route was manually added using the
  /// **CreateClientVpnRoute** action.
  final String origin;

  /// The current state of the route.
  final ClientVpnRouteStatus status;

  /// A brief description of the route.
  final String description;

  ClientVpnRoute({
    this.clientVpnEndpointId,
    this.destinationCidr,
    this.targetSubnet,
    this.type,
    this.origin,
    this.status,
    this.description,
  });
  static ClientVpnRoute fromJson(Map<String, dynamic> json) => ClientVpnRoute(
        clientVpnEndpointId: json.containsKey('ClientVpnEndpointId')
            ? json['ClientVpnEndpointId'] as String
            : null,
        destinationCidr: json.containsKey('DestinationCidr')
            ? json['DestinationCidr'] as String
            : null,
        targetSubnet: json.containsKey('TargetSubnet')
            ? json['TargetSubnet'] as String
            : null,
        type: json.containsKey('Type') ? json['Type'] as String : null,
        origin: json.containsKey('Origin') ? json['Origin'] as String : null,
        status: json.containsKey('Status')
            ? ClientVpnRouteStatus.fromJson(json['Status'])
            : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
      );
}

/// Describes the state of a Client VPN endpoint route.
class ClientVpnRouteStatus {
  /// The state of the Client VPN endpoint route.
  final String code;

  /// A message about the status of the Client VPN endpoint route, if
  /// applicable.
  final String message;

  ClientVpnRouteStatus({
    this.code,
    this.message,
  });
  static ClientVpnRouteStatus fromJson(Map<String, dynamic> json) =>
      ClientVpnRouteStatus(
        code: json.containsKey('Code') ? json['Code'] as String : null,
        message: json.containsKey('Message') ? json['Message'] as String : null,
      );
}

class ConfirmProductInstanceResult {
  /// The AWS account ID of the instance owner. This is only present if the
  /// product code is attached to the instance.
  final String ownerId;

  /// The return value of the request. Returns `true` if the specified product
  /// code is owned by the requester and associated with the specified instance.
  final bool return$;

  ConfirmProductInstanceResult({
    this.ownerId,
    this.return$,
  });
  static ConfirmProductInstanceResult fromJson(Map<String, dynamic> json) =>
      ConfirmProductInstanceResult(
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

/// Describes the client connection logging options for the Client VPN endpoint.
class ConnectionLogOptions {
  /// Indicates whether connection logging is enabled.
  final bool enabled;

  /// The name of the CloudWatch Logs log group.
  final String cloudwatchLogGroup;

  /// The name of the CloudWatch Logs log stream to which the connection data is
  /// published.
  final String cloudwatchLogStream;

  ConnectionLogOptions({
    this.enabled,
    this.cloudwatchLogGroup,
    this.cloudwatchLogStream,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Information about the client connection logging options for a Client VPN
/// endpoint.
class ConnectionLogResponseOptions {
  /// Indicates whether client connection logging is enabled for the Client VPN
  /// endpoint.
  final bool enabled;

  /// The name of the Amazon CloudWatch Logs log group to which connection
  /// logging data is published.
  final String cloudwatchLogGroup;

  /// The name of the Amazon CloudWatch Logs log stream to which connection
  /// logging data is published.
  final String cloudwatchLogStream;

  ConnectionLogResponseOptions({
    this.enabled,
    this.cloudwatchLogGroup,
    this.cloudwatchLogStream,
  });
  static ConnectionLogResponseOptions fromJson(Map<String, dynamic> json) =>
      ConnectionLogResponseOptions(
        enabled: json.containsKey('Enabled') ? json['Enabled'] as bool : null,
        cloudwatchLogGroup: json.containsKey('CloudwatchLogGroup')
            ? json['CloudwatchLogGroup'] as String
            : null,
        cloudwatchLogStream: json.containsKey('CloudwatchLogStream')
            ? json['CloudwatchLogStream'] as String
            : null,
      );
}

/// Describes a connection notification for a VPC endpoint or VPC endpoint
/// service.
class ConnectionNotification {
  /// The ID of the notification.
  final String connectionNotificationId;

  /// The ID of the endpoint service.
  final String serviceId;

  /// The ID of the VPC endpoint.
  final String vpcEndpointId;

  /// The type of notification.
  final String connectionNotificationType;

  /// The ARN of the SNS topic for the notification.
  final String connectionNotificationArn;

  /// The events for the notification. Valid values are `Accept`, `Connect`,
  /// `Delete`, and `Reject`.
  final List<String> connectionEvents;

  /// The state of the notification.
  final String connectionNotificationState;

  ConnectionNotification({
    this.connectionNotificationId,
    this.serviceId,
    this.vpcEndpointId,
    this.connectionNotificationType,
    this.connectionNotificationArn,
    this.connectionEvents,
    this.connectionNotificationState,
  });
  static ConnectionNotification fromJson(Map<String, dynamic> json) =>
      ConnectionNotification(
        connectionNotificationId: json.containsKey('ConnectionNotificationId')
            ? json['ConnectionNotificationId'] as String
            : null,
        serviceId:
            json.containsKey('ServiceId') ? json['ServiceId'] as String : null,
        vpcEndpointId: json.containsKey('VpcEndpointId')
            ? json['VpcEndpointId'] as String
            : null,
        connectionNotificationType:
            json.containsKey('ConnectionNotificationType')
                ? json['ConnectionNotificationType'] as String
                : null,
        connectionNotificationArn: json.containsKey('ConnectionNotificationArn')
            ? json['ConnectionNotificationArn'] as String
            : null,
        connectionEvents: json.containsKey('ConnectionEvents')
            ? (json['ConnectionEvents'] as List)
                .map((e) => e as String)
                .toList()
            : null,
        connectionNotificationState:
            json.containsKey('ConnectionNotificationState')
                ? json['ConnectionNotificationState'] as String
                : null,
      );
}

/// Describes a conversion task.
class ConversionTask {
  /// The ID of the conversion task.
  final String conversionTaskId;

  /// The time when the task expires. If the upload isn't complete before the
  /// expiration time, we automatically cancel the task.
  final String expirationTime;

  /// If the task is for importing an instance, this contains information about
  /// the import instance task.
  final ImportInstanceTaskDetails importInstance;

  /// If the task is for importing a volume, this contains information about the
  /// import volume task.
  final ImportVolumeTaskDetails importVolume;

  /// The state of the conversion task.
  final String state;

  /// The status message related to the conversion task.
  final String statusMessage;

  /// Any tags assigned to the task.
  final List<Tag> tags;

  ConversionTask({
    this.conversionTaskId,
    this.expirationTime,
    this.importInstance,
    this.importVolume,
    this.state,
    this.statusMessage,
    this.tags,
  });
  static ConversionTask fromJson(Map<String, dynamic> json) => ConversionTask(
        conversionTaskId: json.containsKey('ConversionTaskId')
            ? json['ConversionTaskId'] as String
            : null,
        expirationTime: json.containsKey('ExpirationTime')
            ? json['ExpirationTime'] as String
            : null,
        importInstance: json.containsKey('ImportInstance')
            ? ImportInstanceTaskDetails.fromJson(json['ImportInstance'])
            : null,
        importVolume: json.containsKey('ImportVolume')
            ? ImportVolumeTaskDetails.fromJson(json['ImportVolume'])
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        statusMessage: json.containsKey('StatusMessage')
            ? json['StatusMessage'] as String
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

class CopyFpgaImageResult {
  /// The ID of the new AFI.
  final String fpgaImageId;

  CopyFpgaImageResult({
    this.fpgaImageId,
  });
  static CopyFpgaImageResult fromJson(Map<String, dynamic> json) =>
      CopyFpgaImageResult(
        fpgaImageId: json.containsKey('FpgaImageId')
            ? json['FpgaImageId'] as String
            : null,
      );
}

/// Contains the output of CopyImage.
class CopyImageResult {
  /// The ID of the new AMI.
  final String imageId;

  CopyImageResult({
    this.imageId,
  });
  static CopyImageResult fromJson(Map<String, dynamic> json) => CopyImageResult(
        imageId: json.containsKey('ImageId') ? json['ImageId'] as String : null,
      );
}

/// Contains the output of CopySnapshot.
class CopySnapshotResult {
  /// The ID of the new snapshot.
  final String snapshotId;

  CopySnapshotResult({
    this.snapshotId,
  });
  static CopySnapshotResult fromJson(Map<String, dynamic> json) =>
      CopySnapshotResult(
        snapshotId: json.containsKey('SnapshotId')
            ? json['SnapshotId'] as String
            : null,
      );
}

/// The CPU options for the instance.
class CpuOptions {
  /// The number of CPU cores for the instance.
  final int coreCount;

  /// The number of threads per CPU core.
  final int threadsPerCore;

  CpuOptions({
    this.coreCount,
    this.threadsPerCore,
  });
  static CpuOptions fromJson(Map<String, dynamic> json) => CpuOptions(
        coreCount:
            json.containsKey('CoreCount') ? json['CoreCount'] as int : null,
        threadsPerCore: json.containsKey('ThreadsPerCore')
            ? json['ThreadsPerCore'] as int
            : null,
      );
}

/// The CPU options for the instance. Both the core count and threads per core
/// must be specified in the request.
class CpuOptionsRequest {
  /// The number of CPU cores for the instance.
  final int coreCount;

  /// The number of threads per CPU core. To disable multithreading for the
  /// instance, specify a value of `1`. Otherwise, specify the default value of
  /// `2`.
  final int threadsPerCore;

  CpuOptionsRequest({
    this.coreCount,
    this.threadsPerCore,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

class CreateCapacityReservationResult {
  /// Information about the Capacity Reservation.
  final CapacityReservation capacityReservation;

  CreateCapacityReservationResult({
    this.capacityReservation,
  });
  static CreateCapacityReservationResult fromJson(Map<String, dynamic> json) =>
      CreateCapacityReservationResult(
        capacityReservation: json.containsKey('CapacityReservation')
            ? CapacityReservation.fromJson(json['CapacityReservation'])
            : null,
      );
}

class CreateClientVpnEndpointResult {
  /// The ID of the Client VPN endpoint.
  final String clientVpnEndpointId;

  /// The current state of the Client VPN endpoint.
  final ClientVpnEndpointStatus status;

  /// The DNS name to be used by clients when establishing their VPN session.
  final String dnsName;

  CreateClientVpnEndpointResult({
    this.clientVpnEndpointId,
    this.status,
    this.dnsName,
  });
  static CreateClientVpnEndpointResult fromJson(Map<String, dynamic> json) =>
      CreateClientVpnEndpointResult(
        clientVpnEndpointId: json.containsKey('ClientVpnEndpointId')
            ? json['ClientVpnEndpointId'] as String
            : null,
        status: json.containsKey('Status')
            ? ClientVpnEndpointStatus.fromJson(json['Status'])
            : null,
        dnsName: json.containsKey('DnsName') ? json['DnsName'] as String : null,
      );
}

class CreateClientVpnRouteResult {
  /// The current state of the route.
  final ClientVpnRouteStatus status;

  CreateClientVpnRouteResult({
    this.status,
  });
  static CreateClientVpnRouteResult fromJson(Map<String, dynamic> json) =>
      CreateClientVpnRouteResult(
        status: json.containsKey('Status')
            ? ClientVpnRouteStatus.fromJson(json['Status'])
            : null,
      );
}

/// Contains the output of CreateCustomerGateway.
class CreateCustomerGatewayResult {
  /// Information about the customer gateway.
  final CustomerGateway customerGateway;

  CreateCustomerGatewayResult({
    this.customerGateway,
  });
  static CreateCustomerGatewayResult fromJson(Map<String, dynamic> json) =>
      CreateCustomerGatewayResult(
        customerGateway: json.containsKey('CustomerGateway')
            ? CustomerGateway.fromJson(json['CustomerGateway'])
            : null,
      );
}

class CreateDefaultSubnetResult {
  /// Information about the subnet.
  final Subnet subnet;

  CreateDefaultSubnetResult({
    this.subnet,
  });
  static CreateDefaultSubnetResult fromJson(Map<String, dynamic> json) =>
      CreateDefaultSubnetResult(
        subnet:
            json.containsKey('Subnet') ? Subnet.fromJson(json['Subnet']) : null,
      );
}

class CreateDefaultVpcResult {
  /// Information about the VPC.
  final Vpc vpc;

  CreateDefaultVpcResult({
    this.vpc,
  });
  static CreateDefaultVpcResult fromJson(Map<String, dynamic> json) =>
      CreateDefaultVpcResult(
        vpc: json.containsKey('Vpc') ? Vpc.fromJson(json['Vpc']) : null,
      );
}

class CreateDhcpOptionsResult {
  /// A set of DHCP options.
  final DhcpOptions dhcpOptions;

  CreateDhcpOptionsResult({
    this.dhcpOptions,
  });
  static CreateDhcpOptionsResult fromJson(Map<String, dynamic> json) =>
      CreateDhcpOptionsResult(
        dhcpOptions: json.containsKey('DhcpOptions')
            ? DhcpOptions.fromJson(json['DhcpOptions'])
            : null,
      );
}

class CreateEgressOnlyInternetGatewayResult {
  /// Unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request.
  final String clientToken;

  /// Information about the egress-only internet gateway.
  final EgressOnlyInternetGateway egressOnlyInternetGateway;

  CreateEgressOnlyInternetGatewayResult({
    this.clientToken,
    this.egressOnlyInternetGateway,
  });
  static CreateEgressOnlyInternetGatewayResult fromJson(
          Map<String, dynamic> json) =>
      CreateEgressOnlyInternetGatewayResult(
        clientToken: json.containsKey('ClientToken')
            ? json['ClientToken'] as String
            : null,
        egressOnlyInternetGateway: json.containsKey('EgressOnlyInternetGateway')
            ? EgressOnlyInternetGateway.fromJson(
                json['EgressOnlyInternetGateway'])
            : null,
      );
}

/// Describes the instances that could not be launched by the fleet.
class CreateFleetError {
  /// The launch templates and overrides that were used for launching the
  /// instances. Any parameters that you specify in the Overrides override the
  /// same parameters in the launch template.
  final LaunchTemplateAndOverridesResponse launchTemplateAndOverrides;

  /// Indicates if the instance that could not be launched was a Spot Instance
  /// or On-Demand Instance.
  final String lifecycle;

  /// The error code that indicates why the instance could not be launched. For
  /// more information about error codes, see
  /// [Error Codes](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html).
  final String errorCode;

  /// The error message that describes why the instance could not be launched.
  /// For more information about error messages, see ee
  /// [Error Codes](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html).
  final String errorMessage;

  CreateFleetError({
    this.launchTemplateAndOverrides,
    this.lifecycle,
    this.errorCode,
    this.errorMessage,
  });
  static CreateFleetError fromJson(Map<String, dynamic> json) =>
      CreateFleetError(
        launchTemplateAndOverrides:
            json.containsKey('LaunchTemplateAndOverrides')
                ? LaunchTemplateAndOverridesResponse.fromJson(
                    json['LaunchTemplateAndOverrides'])
                : null,
        lifecycle:
            json.containsKey('Lifecycle') ? json['Lifecycle'] as String : null,
        errorCode:
            json.containsKey('ErrorCode') ? json['ErrorCode'] as String : null,
        errorMessage: json.containsKey('ErrorMessage')
            ? json['ErrorMessage'] as String
            : null,
      );
}

/// Describes the instances that were launched by the fleet.
class CreateFleetInstance {
  /// The launch templates and overrides that were used for launching the
  /// instances. Any parameters that you specify in the Overrides override the
  /// same parameters in the launch template.
  final LaunchTemplateAndOverridesResponse launchTemplateAndOverrides;

  /// Indicates if the instance that was launched is a Spot Instance or
  /// On-Demand Instance.
  final String lifecycle;

  /// The IDs of the instances.
  final List<String> instanceIds;

  /// The instance type.
  final String instanceType;

  /// The value is `Windows` for Windows instances; otherwise blank.
  final String platform;

  CreateFleetInstance({
    this.launchTemplateAndOverrides,
    this.lifecycle,
    this.instanceIds,
    this.instanceType,
    this.platform,
  });
  static CreateFleetInstance fromJson(Map<String, dynamic> json) =>
      CreateFleetInstance(
        launchTemplateAndOverrides:
            json.containsKey('LaunchTemplateAndOverrides')
                ? LaunchTemplateAndOverridesResponse.fromJson(
                    json['LaunchTemplateAndOverrides'])
                : null,
        lifecycle:
            json.containsKey('Lifecycle') ? json['Lifecycle'] as String : null,
        instanceIds: json.containsKey('InstanceIds')
            ? (json['InstanceIds'] as List).map((e) => e as String).toList()
            : null,
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        platform:
            json.containsKey('Platform') ? json['Platform'] as String : null,
      );
}

class CreateFleetResult {
  /// The ID of the EC2 Fleet.
  final String fleetId;

  /// Information about the instances that could not be launched by the fleet.
  /// Valid only when **Type** is set to `instant`.
  final List<CreateFleetError> errors;

  /// Information about the instances that were launched by the fleet. Valid
  /// only when **Type** is set to `instant`.
  final List<CreateFleetInstance> instances;

  CreateFleetResult({
    this.fleetId,
    this.errors,
    this.instances,
  });
  static CreateFleetResult fromJson(Map<String, dynamic> json) =>
      CreateFleetResult(
        fleetId: json.containsKey('FleetId') ? json['FleetId'] as String : null,
        errors: json.containsKey('Errors')
            ? (json['Errors'] as List)
                .map((e) => CreateFleetError.fromJson(e))
                .toList()
            : null,
        instances: json.containsKey('Instances')
            ? (json['Instances'] as List)
                .map((e) => CreateFleetInstance.fromJson(e))
                .toList()
            : null,
      );
}

class CreateFlowLogsResult {
  /// Unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request.
  final String clientToken;

  /// The IDs of the flow logs.
  final List<String> flowLogIds;

  /// Information about the flow logs that could not be created successfully.
  final List<UnsuccessfulItem> unsuccessful;

  CreateFlowLogsResult({
    this.clientToken,
    this.flowLogIds,
    this.unsuccessful,
  });
  static CreateFlowLogsResult fromJson(Map<String, dynamic> json) =>
      CreateFlowLogsResult(
        clientToken: json.containsKey('ClientToken')
            ? json['ClientToken'] as String
            : null,
        flowLogIds: json.containsKey('FlowLogIds')
            ? (json['FlowLogIds'] as List).map((e) => e as String).toList()
            : null,
        unsuccessful: json.containsKey('Unsuccessful')
            ? (json['Unsuccessful'] as List)
                .map((e) => UnsuccessfulItem.fromJson(e))
                .toList()
            : null,
      );
}

class CreateFpgaImageResult {
  /// The FPGA image identifier (AFI ID).
  final String fpgaImageId;

  /// The global FPGA image identifier (AGFI ID).
  final String fpgaImageGlobalId;

  CreateFpgaImageResult({
    this.fpgaImageId,
    this.fpgaImageGlobalId,
  });
  static CreateFpgaImageResult fromJson(Map<String, dynamic> json) =>
      CreateFpgaImageResult(
        fpgaImageId: json.containsKey('FpgaImageId')
            ? json['FpgaImageId'] as String
            : null,
        fpgaImageGlobalId: json.containsKey('FpgaImageGlobalId')
            ? json['FpgaImageGlobalId'] as String
            : null,
      );
}

class CreateImageResult {
  /// The ID of the new AMI.
  final String imageId;

  CreateImageResult({
    this.imageId,
  });
  static CreateImageResult fromJson(Map<String, dynamic> json) =>
      CreateImageResult(
        imageId: json.containsKey('ImageId') ? json['ImageId'] as String : null,
      );
}

class CreateInstanceExportTaskResult {
  /// Information about the instance export task.
  final ExportTask exportTask;

  CreateInstanceExportTaskResult({
    this.exportTask,
  });
  static CreateInstanceExportTaskResult fromJson(Map<String, dynamic> json) =>
      CreateInstanceExportTaskResult(
        exportTask: json.containsKey('ExportTask')
            ? ExportTask.fromJson(json['ExportTask'])
            : null,
      );
}

class CreateInternetGatewayResult {
  /// Information about the internet gateway.
  final InternetGateway internetGateway;

  CreateInternetGatewayResult({
    this.internetGateway,
  });
  static CreateInternetGatewayResult fromJson(Map<String, dynamic> json) =>
      CreateInternetGatewayResult(
        internetGateway: json.containsKey('InternetGateway')
            ? InternetGateway.fromJson(json['InternetGateway'])
            : null,
      );
}

class CreateLaunchTemplateResult {
  /// Information about the launch template.
  final LaunchTemplate launchTemplate;

  CreateLaunchTemplateResult({
    this.launchTemplate,
  });
  static CreateLaunchTemplateResult fromJson(Map<String, dynamic> json) =>
      CreateLaunchTemplateResult(
        launchTemplate: json.containsKey('LaunchTemplate')
            ? LaunchTemplate.fromJson(json['LaunchTemplate'])
            : null,
      );
}

class CreateLaunchTemplateVersionResult {
  /// Information about the launch template version.
  final LaunchTemplateVersion launchTemplateVersion;

  CreateLaunchTemplateVersionResult({
    this.launchTemplateVersion,
  });
  static CreateLaunchTemplateVersionResult fromJson(
          Map<String, dynamic> json) =>
      CreateLaunchTemplateVersionResult(
        launchTemplateVersion: json.containsKey('LaunchTemplateVersion')
            ? LaunchTemplateVersion.fromJson(json['LaunchTemplateVersion'])
            : null,
      );
}

class CreateNatGatewayResult {
  /// Unique, case-sensitive identifier to ensure the idempotency of the
  /// request. Only returned if a client token was provided in the request.
  final String clientToken;

  /// Information about the NAT gateway.
  final NatGateway natGateway;

  CreateNatGatewayResult({
    this.clientToken,
    this.natGateway,
  });
  static CreateNatGatewayResult fromJson(Map<String, dynamic> json) =>
      CreateNatGatewayResult(
        clientToken: json.containsKey('ClientToken')
            ? json['ClientToken'] as String
            : null,
        natGateway: json.containsKey('NatGateway')
            ? NatGateway.fromJson(json['NatGateway'])
            : null,
      );
}

class CreateNetworkAclResult {
  /// Information about the network ACL.
  final NetworkAcl networkAcl;

  CreateNetworkAclResult({
    this.networkAcl,
  });
  static CreateNetworkAclResult fromJson(Map<String, dynamic> json) =>
      CreateNetworkAclResult(
        networkAcl: json.containsKey('NetworkAcl')
            ? NetworkAcl.fromJson(json['NetworkAcl'])
            : null,
      );
}

/// Contains the output of CreateNetworkInterfacePermission.
class CreateNetworkInterfacePermissionResult {
  /// Information about the permission for the network interface.
  final NetworkInterfacePermission interfacePermission;

  CreateNetworkInterfacePermissionResult({
    this.interfacePermission,
  });
  static CreateNetworkInterfacePermissionResult fromJson(
          Map<String, dynamic> json) =>
      CreateNetworkInterfacePermissionResult(
        interfacePermission: json.containsKey('InterfacePermission')
            ? NetworkInterfacePermission.fromJson(json['InterfacePermission'])
            : null,
      );
}

/// Contains the output of CreateNetworkInterface.
class CreateNetworkInterfaceResult {
  /// Information about the network interface.
  final NetworkInterface networkInterface;

  CreateNetworkInterfaceResult({
    this.networkInterface,
  });
  static CreateNetworkInterfaceResult fromJson(Map<String, dynamic> json) =>
      CreateNetworkInterfaceResult(
        networkInterface: json.containsKey('NetworkInterface')
            ? NetworkInterface.fromJson(json['NetworkInterface'])
            : null,
      );
}

/// Contains the output of CreateReservedInstancesListing.
class CreateReservedInstancesListingResult {
  /// Information about the Standard Reserved Instance listing.
  final List<ReservedInstancesListing> reservedInstancesListings;

  CreateReservedInstancesListingResult({
    this.reservedInstancesListings,
  });
  static CreateReservedInstancesListingResult fromJson(
          Map<String, dynamic> json) =>
      CreateReservedInstancesListingResult(
        reservedInstancesListings: json.containsKey('ReservedInstancesListings')
            ? (json['ReservedInstancesListings'] as List)
                .map((e) => ReservedInstancesListing.fromJson(e))
                .toList()
            : null,
      );
}

class CreateRouteResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool return$;

  CreateRouteResult({
    this.return$,
  });
  static CreateRouteResult fromJson(Map<String, dynamic> json) =>
      CreateRouteResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class CreateRouteTableResult {
  /// Information about the route table.
  final RouteTable routeTable;

  CreateRouteTableResult({
    this.routeTable,
  });
  static CreateRouteTableResult fromJson(Map<String, dynamic> json) =>
      CreateRouteTableResult(
        routeTable: json.containsKey('RouteTable')
            ? RouteTable.fromJson(json['RouteTable'])
            : null,
      );
}

class CreateSecurityGroupResult {
  /// The ID of the security group.
  final String groupId;

  CreateSecurityGroupResult({
    this.groupId,
  });
  static CreateSecurityGroupResult fromJson(Map<String, dynamic> json) =>
      CreateSecurityGroupResult(
        groupId: json.containsKey('GroupId') ? json['GroupId'] as String : null,
      );
}

class CreateSnapshotsResult {
  /// List of snapshots.
  final List<SnapshotInfo> snapshots;

  CreateSnapshotsResult({
    this.snapshots,
  });
  static CreateSnapshotsResult fromJson(Map<String, dynamic> json) =>
      CreateSnapshotsResult(
        snapshots: json.containsKey('Snapshots')
            ? (json['Snapshots'] as List)
                .map((e) => SnapshotInfo.fromJson(e))
                .toList()
            : null,
      );
}

/// Contains the output of CreateSpotDatafeedSubscription.
class CreateSpotDatafeedSubscriptionResult {
  /// The Spot Instance data feed subscription.
  final SpotDatafeedSubscription spotDatafeedSubscription;

  CreateSpotDatafeedSubscriptionResult({
    this.spotDatafeedSubscription,
  });
  static CreateSpotDatafeedSubscriptionResult fromJson(
          Map<String, dynamic> json) =>
      CreateSpotDatafeedSubscriptionResult(
        spotDatafeedSubscription: json.containsKey('SpotDatafeedSubscription')
            ? SpotDatafeedSubscription.fromJson(
                json['SpotDatafeedSubscription'])
            : null,
      );
}

class CreateSubnetResult {
  /// Information about the subnet.
  final Subnet subnet;

  CreateSubnetResult({
    this.subnet,
  });
  static CreateSubnetResult fromJson(Map<String, dynamic> json) =>
      CreateSubnetResult(
        subnet:
            json.containsKey('Subnet') ? Subnet.fromJson(json['Subnet']) : null,
      );
}

class CreateTrafficMirrorFilterResult {
  /// Information about the Traffic Mirror filter.
  final TrafficMirrorFilter trafficMirrorFilter;

  /// Unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  final String clientToken;

  CreateTrafficMirrorFilterResult({
    this.trafficMirrorFilter,
    this.clientToken,
  });
  static CreateTrafficMirrorFilterResult fromJson(Map<String, dynamic> json) =>
      CreateTrafficMirrorFilterResult(
        trafficMirrorFilter: json.containsKey('TrafficMirrorFilter')
            ? TrafficMirrorFilter.fromJson(json['TrafficMirrorFilter'])
            : null,
        clientToken: json.containsKey('ClientToken')
            ? json['ClientToken'] as String
            : null,
      );
}

class CreateTrafficMirrorFilterRuleResult {
  /// The Traffic Mirror rule.
  final TrafficMirrorFilterRule trafficMirrorFilterRule;

  /// Unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  final String clientToken;

  CreateTrafficMirrorFilterRuleResult({
    this.trafficMirrorFilterRule,
    this.clientToken,
  });
  static CreateTrafficMirrorFilterRuleResult fromJson(
          Map<String, dynamic> json) =>
      CreateTrafficMirrorFilterRuleResult(
        trafficMirrorFilterRule: json.containsKey('TrafficMirrorFilterRule')
            ? TrafficMirrorFilterRule.fromJson(json['TrafficMirrorFilterRule'])
            : null,
        clientToken: json.containsKey('ClientToken')
            ? json['ClientToken'] as String
            : null,
      );
}

class CreateTrafficMirrorSessionResult {
  /// Information about the Traffic Mirror session.
  final TrafficMirrorSession trafficMirrorSession;

  /// Unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  final String clientToken;

  CreateTrafficMirrorSessionResult({
    this.trafficMirrorSession,
    this.clientToken,
  });
  static CreateTrafficMirrorSessionResult fromJson(Map<String, dynamic> json) =>
      CreateTrafficMirrorSessionResult(
        trafficMirrorSession: json.containsKey('TrafficMirrorSession')
            ? TrafficMirrorSession.fromJson(json['TrafficMirrorSession'])
            : null,
        clientToken: json.containsKey('ClientToken')
            ? json['ClientToken'] as String
            : null,
      );
}

class CreateTrafficMirrorTargetResult {
  /// Information about the Traffic Mirror target.
  final TrafficMirrorTarget trafficMirrorTarget;

  /// Unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  final String clientToken;

  CreateTrafficMirrorTargetResult({
    this.trafficMirrorTarget,
    this.clientToken,
  });
  static CreateTrafficMirrorTargetResult fromJson(Map<String, dynamic> json) =>
      CreateTrafficMirrorTargetResult(
        trafficMirrorTarget: json.containsKey('TrafficMirrorTarget')
            ? TrafficMirrorTarget.fromJson(json['TrafficMirrorTarget'])
            : null,
        clientToken: json.containsKey('ClientToken')
            ? json['ClientToken'] as String
            : null,
      );
}

class CreateTransitGatewayResult {
  /// Information about the transit gateway.
  final TransitGateway transitGateway;

  CreateTransitGatewayResult({
    this.transitGateway,
  });
  static CreateTransitGatewayResult fromJson(Map<String, dynamic> json) =>
      CreateTransitGatewayResult(
        transitGateway: json.containsKey('TransitGateway')
            ? TransitGateway.fromJson(json['TransitGateway'])
            : null,
      );
}

class CreateTransitGatewayRouteResult {
  /// Information about the route.
  final TransitGatewayRoute route;

  CreateTransitGatewayRouteResult({
    this.route,
  });
  static CreateTransitGatewayRouteResult fromJson(Map<String, dynamic> json) =>
      CreateTransitGatewayRouteResult(
        route: json.containsKey('Route')
            ? TransitGatewayRoute.fromJson(json['Route'])
            : null,
      );
}

class CreateTransitGatewayRouteTableResult {
  /// Information about the transit gateway route table.
  final TransitGatewayRouteTable transitGatewayRouteTable;

  CreateTransitGatewayRouteTableResult({
    this.transitGatewayRouteTable,
  });
  static CreateTransitGatewayRouteTableResult fromJson(
          Map<String, dynamic> json) =>
      CreateTransitGatewayRouteTableResult(
        transitGatewayRouteTable: json.containsKey('TransitGatewayRouteTable')
            ? TransitGatewayRouteTable.fromJson(
                json['TransitGatewayRouteTable'])
            : null,
      );
}

/// Describes the options for a VPC attachment.
class CreateTransitGatewayVpcAttachmentRequestOptions {
  /// Enable or disable DNS support. The default is `enable`.
  final String dnsSupport;

  /// Enable or disable IPv6 support. The default is `enable`.
  final String ipv6Support;

  CreateTransitGatewayVpcAttachmentRequestOptions({
    this.dnsSupport,
    this.ipv6Support,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

class CreateTransitGatewayVpcAttachmentResult {
  /// Information about the VPC attachment.
  final TransitGatewayVpcAttachment transitGatewayVpcAttachment;

  CreateTransitGatewayVpcAttachmentResult({
    this.transitGatewayVpcAttachment,
  });
  static CreateTransitGatewayVpcAttachmentResult fromJson(
          Map<String, dynamic> json) =>
      CreateTransitGatewayVpcAttachmentResult(
        transitGatewayVpcAttachment:
            json.containsKey('TransitGatewayVpcAttachment')
                ? TransitGatewayVpcAttachment.fromJson(
                    json['TransitGatewayVpcAttachment'])
                : null,
      );
}

/// Describes the user or group to be added or removed from the list of create
/// volume permissions for a volume.
class CreateVolumePermission {
  /// The group to be added or removed. The possible value is `all`.
  final String group;

  /// The AWS account ID to be added or removed.
  final String userId;

  CreateVolumePermission({
    this.group,
    this.userId,
  });
  static CreateVolumePermission fromJson(Map<String, dynamic> json) =>
      CreateVolumePermission(
        group: json.containsKey('Group') ? json['Group'] as String : null,
        userId: json.containsKey('UserId') ? json['UserId'] as String : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes modifications to the list of create volume permissions for a
/// volume.
class CreateVolumePermissionModifications {
  /// Adds the specified AWS account ID or group to the list.
  final List<CreateVolumePermission> add;

  /// Removes the specified AWS account ID or group from the list.
  final List<CreateVolumePermission> remove;

  CreateVolumePermissionModifications({
    this.add,
    this.remove,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

class CreateVpcEndpointConnectionNotificationResult {
  /// Information about the notification.
  final ConnectionNotification connectionNotification;

  /// Unique, case-sensitive identifier you provide to ensure the idempotency of
  /// the request.
  final String clientToken;

  CreateVpcEndpointConnectionNotificationResult({
    this.connectionNotification,
    this.clientToken,
  });
  static CreateVpcEndpointConnectionNotificationResult fromJson(
          Map<String, dynamic> json) =>
      CreateVpcEndpointConnectionNotificationResult(
        connectionNotification: json.containsKey('ConnectionNotification')
            ? ConnectionNotification.fromJson(json['ConnectionNotification'])
            : null,
        clientToken: json.containsKey('ClientToken')
            ? json['ClientToken'] as String
            : null,
      );
}

/// Contains the output of CreateVpcEndpoint.
class CreateVpcEndpointResult {
  /// Information about the endpoint.
  final VpcEndpoint vpcEndpoint;

  /// Unique, case-sensitive identifier you provide to ensure the idempotency of
  /// the request.
  final String clientToken;

  CreateVpcEndpointResult({
    this.vpcEndpoint,
    this.clientToken,
  });
  static CreateVpcEndpointResult fromJson(Map<String, dynamic> json) =>
      CreateVpcEndpointResult(
        vpcEndpoint: json.containsKey('VpcEndpoint')
            ? VpcEndpoint.fromJson(json['VpcEndpoint'])
            : null,
        clientToken: json.containsKey('ClientToken')
            ? json['ClientToken'] as String
            : null,
      );
}

class CreateVpcEndpointServiceConfigurationResult {
  /// Information about the service configuration.
  final ServiceConfiguration serviceConfiguration;

  /// Unique, case-sensitive identifier you provide to ensure the idempotency of
  /// the request.
  final String clientToken;

  CreateVpcEndpointServiceConfigurationResult({
    this.serviceConfiguration,
    this.clientToken,
  });
  static CreateVpcEndpointServiceConfigurationResult fromJson(
          Map<String, dynamic> json) =>
      CreateVpcEndpointServiceConfigurationResult(
        serviceConfiguration: json.containsKey('ServiceConfiguration')
            ? ServiceConfiguration.fromJson(json['ServiceConfiguration'])
            : null,
        clientToken: json.containsKey('ClientToken')
            ? json['ClientToken'] as String
            : null,
      );
}

class CreateVpcPeeringConnectionResult {
  /// Information about the VPC peering connection.
  final VpcPeeringConnection vpcPeeringConnection;

  CreateVpcPeeringConnectionResult({
    this.vpcPeeringConnection,
  });
  static CreateVpcPeeringConnectionResult fromJson(Map<String, dynamic> json) =>
      CreateVpcPeeringConnectionResult(
        vpcPeeringConnection: json.containsKey('VpcPeeringConnection')
            ? VpcPeeringConnection.fromJson(json['VpcPeeringConnection'])
            : null,
      );
}

class CreateVpcResult {
  /// Information about the VPC.
  final Vpc vpc;

  CreateVpcResult({
    this.vpc,
  });
  static CreateVpcResult fromJson(Map<String, dynamic> json) => CreateVpcResult(
        vpc: json.containsKey('Vpc') ? Vpc.fromJson(json['Vpc']) : null,
      );
}

/// Contains the output of CreateVpnConnection.
class CreateVpnConnectionResult {
  /// Information about the VPN connection.
  final VpnConnection vpnConnection;

  CreateVpnConnectionResult({
    this.vpnConnection,
  });
  static CreateVpnConnectionResult fromJson(Map<String, dynamic> json) =>
      CreateVpnConnectionResult(
        vpnConnection: json.containsKey('VpnConnection')
            ? VpnConnection.fromJson(json['VpnConnection'])
            : null,
      );
}

/// Contains the output of CreateVpnGateway.
class CreateVpnGatewayResult {
  /// Information about the virtual private gateway.
  final VpnGateway vpnGateway;

  CreateVpnGatewayResult({
    this.vpnGateway,
  });
  static CreateVpnGatewayResult fromJson(Map<String, dynamic> json) =>
      CreateVpnGatewayResult(
        vpnGateway: json.containsKey('VpnGateway')
            ? VpnGateway.fromJson(json['VpnGateway'])
            : null,
      );
}

/// Describes the credit option for CPU usage of a T2 or T3 instance.
class CreditSpecification {
  /// The credit option for CPU usage of a T2 or T3 instance. Valid values are
  /// `standard` and `unlimited`.
  final String cpuCredits;

  CreditSpecification({
    this.cpuCredits,
  });
  static CreditSpecification fromJson(Map<String, dynamic> json) =>
      CreditSpecification(
        cpuCredits: json.containsKey('CpuCredits')
            ? json['CpuCredits'] as String
            : null,
      );
}

/// The credit option for CPU usage of a T2 or T3 instance.
class CreditSpecificationRequest {
  /// The credit option for CPU usage of a T2 or T3 instance. Valid values are
  /// `standard` and `unlimited`.
  final String cpuCredits;

  CreditSpecificationRequest({
    @required this.cpuCredits,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a customer gateway.
class CustomerGateway {
  /// The customer gateway's Border Gateway Protocol (BGP) Autonomous System
  /// Number (ASN).
  final String bgpAsn;

  /// The ID of the customer gateway.
  final String customerGatewayId;

  /// The Internet-routable IP address of the customer gateway's outside
  /// interface.
  final String ipAddress;

  /// The Amazon Resource Name (ARN) for the customer gateway certificate.
  final String certificateArn;

  /// The current state of the customer gateway (`pending | available | deleting
  /// | deleted`).
  final String state;

  /// The type of VPN connection the customer gateway supports (`ipsec.1`).
  final String type;

  /// Any tags assigned to the customer gateway.
  final List<Tag> tags;

  CustomerGateway({
    this.bgpAsn,
    this.customerGatewayId,
    this.ipAddress,
    this.certificateArn,
    this.state,
    this.type,
    this.tags,
  });
  static CustomerGateway fromJson(Map<String, dynamic> json) => CustomerGateway(
        bgpAsn: json.containsKey('BgpAsn') ? json['BgpAsn'] as String : null,
        customerGatewayId: json.containsKey('CustomerGatewayId')
            ? json['CustomerGatewayId'] as String
            : null,
        ipAddress:
            json.containsKey('IpAddress') ? json['IpAddress'] as String : null,
        certificateArn: json.containsKey('CertificateArn')
            ? json['CertificateArn'] as String
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        type: json.containsKey('Type') ? json['Type'] as String : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

class DeleteClientVpnEndpointResult {
  /// The current state of the Client VPN endpoint.
  final ClientVpnEndpointStatus status;

  DeleteClientVpnEndpointResult({
    this.status,
  });
  static DeleteClientVpnEndpointResult fromJson(Map<String, dynamic> json) =>
      DeleteClientVpnEndpointResult(
        status: json.containsKey('Status')
            ? ClientVpnEndpointStatus.fromJson(json['Status'])
            : null,
      );
}

class DeleteClientVpnRouteResult {
  /// The current state of the route.
  final ClientVpnRouteStatus status;

  DeleteClientVpnRouteResult({
    this.status,
  });
  static DeleteClientVpnRouteResult fromJson(Map<String, dynamic> json) =>
      DeleteClientVpnRouteResult(
        status: json.containsKey('Status')
            ? ClientVpnRouteStatus.fromJson(json['Status'])
            : null,
      );
}

class DeleteEgressOnlyInternetGatewayResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool returnCode;

  DeleteEgressOnlyInternetGatewayResult({
    this.returnCode,
  });
  static DeleteEgressOnlyInternetGatewayResult fromJson(
          Map<String, dynamic> json) =>
      DeleteEgressOnlyInternetGatewayResult(
        returnCode:
            json.containsKey('ReturnCode') ? json['ReturnCode'] as bool : null,
      );
}

/// Describes an EC2 Fleet error.
class DeleteFleetError {
  /// The error code.
  final String code;

  /// The description for the error code.
  final String message;

  DeleteFleetError({
    this.code,
    this.message,
  });
  static DeleteFleetError fromJson(Map<String, dynamic> json) =>
      DeleteFleetError(
        code: json.containsKey('Code') ? json['Code'] as String : null,
        message: json.containsKey('Message') ? json['Message'] as String : null,
      );
}

/// Describes an EC2 Fleet that was not successfully deleted.
class DeleteFleetErrorItem {
  /// The error.
  final DeleteFleetError error;

  /// The ID of the EC2 Fleet.
  final String fleetId;

  DeleteFleetErrorItem({
    this.error,
    this.fleetId,
  });
  static DeleteFleetErrorItem fromJson(Map<String, dynamic> json) =>
      DeleteFleetErrorItem(
        error: json.containsKey('Error')
            ? DeleteFleetError.fromJson(json['Error'])
            : null,
        fleetId: json.containsKey('FleetId') ? json['FleetId'] as String : null,
      );
}

/// Describes an EC2 Fleet that was successfully deleted.
class DeleteFleetSuccessItem {
  /// The current state of the EC2 Fleet.
  final String currentFleetState;

  /// The previous state of the EC2 Fleet.
  final String previousFleetState;

  /// The ID of the EC2 Fleet.
  final String fleetId;

  DeleteFleetSuccessItem({
    this.currentFleetState,
    this.previousFleetState,
    this.fleetId,
  });
  static DeleteFleetSuccessItem fromJson(Map<String, dynamic> json) =>
      DeleteFleetSuccessItem(
        currentFleetState: json.containsKey('CurrentFleetState')
            ? json['CurrentFleetState'] as String
            : null,
        previousFleetState: json.containsKey('PreviousFleetState')
            ? json['PreviousFleetState'] as String
            : null,
        fleetId: json.containsKey('FleetId') ? json['FleetId'] as String : null,
      );
}

class DeleteFleetsResult {
  /// Information about the EC2 Fleets that are successfully deleted.
  final List<DeleteFleetSuccessItem> successfulFleetDeletions;

  /// Information about the EC2 Fleets that are not successfully deleted.
  final List<DeleteFleetErrorItem> unsuccessfulFleetDeletions;

  DeleteFleetsResult({
    this.successfulFleetDeletions,
    this.unsuccessfulFleetDeletions,
  });
  static DeleteFleetsResult fromJson(Map<String, dynamic> json) =>
      DeleteFleetsResult(
        successfulFleetDeletions: json.containsKey('SuccessfulFleetDeletions')
            ? (json['SuccessfulFleetDeletions'] as List)
                .map((e) => DeleteFleetSuccessItem.fromJson(e))
                .toList()
            : null,
        unsuccessfulFleetDeletions:
            json.containsKey('UnsuccessfulFleetDeletions')
                ? (json['UnsuccessfulFleetDeletions'] as List)
                    .map((e) => DeleteFleetErrorItem.fromJson(e))
                    .toList()
                : null,
      );
}

class DeleteFlowLogsResult {
  /// Information about the flow logs that could not be deleted successfully.
  final List<UnsuccessfulItem> unsuccessful;

  DeleteFlowLogsResult({
    this.unsuccessful,
  });
  static DeleteFlowLogsResult fromJson(Map<String, dynamic> json) =>
      DeleteFlowLogsResult(
        unsuccessful: json.containsKey('Unsuccessful')
            ? (json['Unsuccessful'] as List)
                .map((e) => UnsuccessfulItem.fromJson(e))
                .toList()
            : null,
      );
}

class DeleteFpgaImageResult {
  /// Is `true` if the request succeeds, and an error otherwise.
  final bool return$;

  DeleteFpgaImageResult({
    this.return$,
  });
  static DeleteFpgaImageResult fromJson(Map<String, dynamic> json) =>
      DeleteFpgaImageResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class DeleteLaunchTemplateResult {
  /// Information about the launch template.
  final LaunchTemplate launchTemplate;

  DeleteLaunchTemplateResult({
    this.launchTemplate,
  });
  static DeleteLaunchTemplateResult fromJson(Map<String, dynamic> json) =>
      DeleteLaunchTemplateResult(
        launchTemplate: json.containsKey('LaunchTemplate')
            ? LaunchTemplate.fromJson(json['LaunchTemplate'])
            : null,
      );
}

/// Describes a launch template version that could not be deleted.
class DeleteLaunchTemplateVersionsResponseErrorItem {
  /// The ID of the launch template.
  final String launchTemplateId;

  /// The name of the launch template.
  final String launchTemplateName;

  /// The version number of the launch template.
  final BigInt versionNumber;

  /// Information about the error.
  final ResponseError responseError;

  DeleteLaunchTemplateVersionsResponseErrorItem({
    this.launchTemplateId,
    this.launchTemplateName,
    this.versionNumber,
    this.responseError,
  });
  static DeleteLaunchTemplateVersionsResponseErrorItem fromJson(
          Map<String, dynamic> json) =>
      DeleteLaunchTemplateVersionsResponseErrorItem(
        launchTemplateId: json.containsKey('LaunchTemplateId')
            ? json['LaunchTemplateId'] as String
            : null,
        launchTemplateName: json.containsKey('LaunchTemplateName')
            ? json['LaunchTemplateName'] as String
            : null,
        versionNumber: json.containsKey('VersionNumber')
            ? BigInt.from(json['VersionNumber'])
            : null,
        responseError: json.containsKey('ResponseError')
            ? ResponseError.fromJson(json['ResponseError'])
            : null,
      );
}

/// Describes a launch template version that was successfully deleted.
class DeleteLaunchTemplateVersionsResponseSuccessItem {
  /// The ID of the launch template.
  final String launchTemplateId;

  /// The name of the launch template.
  final String launchTemplateName;

  /// The version number of the launch template.
  final BigInt versionNumber;

  DeleteLaunchTemplateVersionsResponseSuccessItem({
    this.launchTemplateId,
    this.launchTemplateName,
    this.versionNumber,
  });
  static DeleteLaunchTemplateVersionsResponseSuccessItem fromJson(
          Map<String, dynamic> json) =>
      DeleteLaunchTemplateVersionsResponseSuccessItem(
        launchTemplateId: json.containsKey('LaunchTemplateId')
            ? json['LaunchTemplateId'] as String
            : null,
        launchTemplateName: json.containsKey('LaunchTemplateName')
            ? json['LaunchTemplateName'] as String
            : null,
        versionNumber: json.containsKey('VersionNumber')
            ? BigInt.from(json['VersionNumber'])
            : null,
      );
}

class DeleteLaunchTemplateVersionsResult {
  /// Information about the launch template versions that were successfully
  /// deleted.
  final List<DeleteLaunchTemplateVersionsResponseSuccessItem>
      successfullyDeletedLaunchTemplateVersions;

  /// Information about the launch template versions that could not be deleted.
  final List<DeleteLaunchTemplateVersionsResponseErrorItem>
      unsuccessfullyDeletedLaunchTemplateVersions;

  DeleteLaunchTemplateVersionsResult({
    this.successfullyDeletedLaunchTemplateVersions,
    this.unsuccessfullyDeletedLaunchTemplateVersions,
  });
  static DeleteLaunchTemplateVersionsResult fromJson(
          Map<String, dynamic> json) =>
      DeleteLaunchTemplateVersionsResult(
        successfullyDeletedLaunchTemplateVersions: json
                .containsKey('SuccessfullyDeletedLaunchTemplateVersions')
            ? (json['SuccessfullyDeletedLaunchTemplateVersions'] as List)
                .map((e) =>
                    DeleteLaunchTemplateVersionsResponseSuccessItem.fromJson(e))
                .toList()
            : null,
        unsuccessfullyDeletedLaunchTemplateVersions: json
                .containsKey('UnsuccessfullyDeletedLaunchTemplateVersions')
            ? (json['UnsuccessfullyDeletedLaunchTemplateVersions'] as List)
                .map((e) =>
                    DeleteLaunchTemplateVersionsResponseErrorItem.fromJson(e))
                .toList()
            : null,
      );
}

class DeleteNatGatewayResult {
  /// The ID of the NAT gateway.
  final String natGatewayId;

  DeleteNatGatewayResult({
    this.natGatewayId,
  });
  static DeleteNatGatewayResult fromJson(Map<String, dynamic> json) =>
      DeleteNatGatewayResult(
        natGatewayId: json.containsKey('NatGatewayId')
            ? json['NatGatewayId'] as String
            : null,
      );
}

/// Contains the output for DeleteNetworkInterfacePermission.
class DeleteNetworkInterfacePermissionResult {
  /// Returns `true` if the request succeeds, otherwise returns an error.
  final bool return$;

  DeleteNetworkInterfacePermissionResult({
    this.return$,
  });
  static DeleteNetworkInterfacePermissionResult fromJson(
          Map<String, dynamic> json) =>
      DeleteNetworkInterfacePermissionResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class DeleteTrafficMirrorFilterResult {
  /// The ID of the Traffic Mirror filter.
  final String trafficMirrorFilterId;

  DeleteTrafficMirrorFilterResult({
    this.trafficMirrorFilterId,
  });
  static DeleteTrafficMirrorFilterResult fromJson(Map<String, dynamic> json) =>
      DeleteTrafficMirrorFilterResult(
        trafficMirrorFilterId: json.containsKey('TrafficMirrorFilterId')
            ? json['TrafficMirrorFilterId'] as String
            : null,
      );
}

class DeleteTrafficMirrorFilterRuleResult {
  /// The ID of the deleted Traffic Mirror rule.
  final String trafficMirrorFilterRuleId;

  DeleteTrafficMirrorFilterRuleResult({
    this.trafficMirrorFilterRuleId,
  });
  static DeleteTrafficMirrorFilterRuleResult fromJson(
          Map<String, dynamic> json) =>
      DeleteTrafficMirrorFilterRuleResult(
        trafficMirrorFilterRuleId: json.containsKey('TrafficMirrorFilterRuleId')
            ? json['TrafficMirrorFilterRuleId'] as String
            : null,
      );
}

class DeleteTrafficMirrorSessionResult {
  /// The ID of the deleted Traffic Mirror session.
  final String trafficMirrorSessionId;

  DeleteTrafficMirrorSessionResult({
    this.trafficMirrorSessionId,
  });
  static DeleteTrafficMirrorSessionResult fromJson(Map<String, dynamic> json) =>
      DeleteTrafficMirrorSessionResult(
        trafficMirrorSessionId: json.containsKey('TrafficMirrorSessionId')
            ? json['TrafficMirrorSessionId'] as String
            : null,
      );
}

class DeleteTrafficMirrorTargetResult {
  /// The ID of the deleted Traffic Mirror target.
  final String trafficMirrorTargetId;

  DeleteTrafficMirrorTargetResult({
    this.trafficMirrorTargetId,
  });
  static DeleteTrafficMirrorTargetResult fromJson(Map<String, dynamic> json) =>
      DeleteTrafficMirrorTargetResult(
        trafficMirrorTargetId: json.containsKey('TrafficMirrorTargetId')
            ? json['TrafficMirrorTargetId'] as String
            : null,
      );
}

class DeleteTransitGatewayResult {
  /// Information about the deleted transit gateway.
  final TransitGateway transitGateway;

  DeleteTransitGatewayResult({
    this.transitGateway,
  });
  static DeleteTransitGatewayResult fromJson(Map<String, dynamic> json) =>
      DeleteTransitGatewayResult(
        transitGateway: json.containsKey('TransitGateway')
            ? TransitGateway.fromJson(json['TransitGateway'])
            : null,
      );
}

class DeleteTransitGatewayRouteResult {
  /// Information about the route.
  final TransitGatewayRoute route;

  DeleteTransitGatewayRouteResult({
    this.route,
  });
  static DeleteTransitGatewayRouteResult fromJson(Map<String, dynamic> json) =>
      DeleteTransitGatewayRouteResult(
        route: json.containsKey('Route')
            ? TransitGatewayRoute.fromJson(json['Route'])
            : null,
      );
}

class DeleteTransitGatewayRouteTableResult {
  /// Information about the deleted transit gateway route table.
  final TransitGatewayRouteTable transitGatewayRouteTable;

  DeleteTransitGatewayRouteTableResult({
    this.transitGatewayRouteTable,
  });
  static DeleteTransitGatewayRouteTableResult fromJson(
          Map<String, dynamic> json) =>
      DeleteTransitGatewayRouteTableResult(
        transitGatewayRouteTable: json.containsKey('TransitGatewayRouteTable')
            ? TransitGatewayRouteTable.fromJson(
                json['TransitGatewayRouteTable'])
            : null,
      );
}

class DeleteTransitGatewayVpcAttachmentResult {
  /// Information about the deleted VPC attachment.
  final TransitGatewayVpcAttachment transitGatewayVpcAttachment;

  DeleteTransitGatewayVpcAttachmentResult({
    this.transitGatewayVpcAttachment,
  });
  static DeleteTransitGatewayVpcAttachmentResult fromJson(
          Map<String, dynamic> json) =>
      DeleteTransitGatewayVpcAttachmentResult(
        transitGatewayVpcAttachment:
            json.containsKey('TransitGatewayVpcAttachment')
                ? TransitGatewayVpcAttachment.fromJson(
                    json['TransitGatewayVpcAttachment'])
                : null,
      );
}

class DeleteVpcEndpointConnectionNotificationsResult {
  /// Information about the notifications that could not be deleted
  /// successfully.
  final List<UnsuccessfulItem> unsuccessful;

  DeleteVpcEndpointConnectionNotificationsResult({
    this.unsuccessful,
  });
  static DeleteVpcEndpointConnectionNotificationsResult fromJson(
          Map<String, dynamic> json) =>
      DeleteVpcEndpointConnectionNotificationsResult(
        unsuccessful: json.containsKey('Unsuccessful')
            ? (json['Unsuccessful'] as List)
                .map((e) => UnsuccessfulItem.fromJson(e))
                .toList()
            : null,
      );
}

class DeleteVpcEndpointServiceConfigurationsResult {
  /// Information about the service configurations that were not deleted, if
  /// applicable.
  final List<UnsuccessfulItem> unsuccessful;

  DeleteVpcEndpointServiceConfigurationsResult({
    this.unsuccessful,
  });
  static DeleteVpcEndpointServiceConfigurationsResult fromJson(
          Map<String, dynamic> json) =>
      DeleteVpcEndpointServiceConfigurationsResult(
        unsuccessful: json.containsKey('Unsuccessful')
            ? (json['Unsuccessful'] as List)
                .map((e) => UnsuccessfulItem.fromJson(e))
                .toList()
            : null,
      );
}

/// Contains the output of DeleteVpcEndpoints.
class DeleteVpcEndpointsResult {
  /// Information about the VPC endpoints that were not successfully deleted.
  final List<UnsuccessfulItem> unsuccessful;

  DeleteVpcEndpointsResult({
    this.unsuccessful,
  });
  static DeleteVpcEndpointsResult fromJson(Map<String, dynamic> json) =>
      DeleteVpcEndpointsResult(
        unsuccessful: json.containsKey('Unsuccessful')
            ? (json['Unsuccessful'] as List)
                .map((e) => UnsuccessfulItem.fromJson(e))
                .toList()
            : null,
      );
}

class DeleteVpcPeeringConnectionResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool return$;

  DeleteVpcPeeringConnectionResult({
    this.return$,
  });
  static DeleteVpcPeeringConnectionResult fromJson(Map<String, dynamic> json) =>
      DeleteVpcPeeringConnectionResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class DeprovisionByoipCidrResult {
  /// Information about the address range.
  final ByoipCidr byoipCidr;

  DeprovisionByoipCidrResult({
    this.byoipCidr,
  });
  static DeprovisionByoipCidrResult fromJson(Map<String, dynamic> json) =>
      DeprovisionByoipCidrResult(
        byoipCidr: json.containsKey('ByoipCidr')
            ? ByoipCidr.fromJson(json['ByoipCidr'])
            : null,
      );
}

class DescribeAccountAttributesResult {
  /// Information about the account attributes.
  final List<AccountAttribute> accountAttributes;

  DescribeAccountAttributesResult({
    this.accountAttributes,
  });
  static DescribeAccountAttributesResult fromJson(Map<String, dynamic> json) =>
      DescribeAccountAttributesResult(
        accountAttributes: json.containsKey('AccountAttributes')
            ? (json['AccountAttributes'] as List)
                .map((e) => AccountAttribute.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeAddressesResult {
  /// Information about the Elastic IP addresses.
  final List<Address> addresses;

  DescribeAddressesResult({
    this.addresses,
  });
  static DescribeAddressesResult fromJson(Map<String, dynamic> json) =>
      DescribeAddressesResult(
        addresses: json.containsKey('Addresses')
            ? (json['Addresses'] as List)
                .map((e) => Address.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeAggregateIdFormatResult {
  /// Indicates whether all resource types in the Region are configured to use
  /// longer IDs. This value is only `true` if all users are configured to use
  /// longer IDs for all resources types in the Region.
  final bool useLongIdsAggregated;

  /// Information about each resource's ID format.
  final List<IdFormat> statuses;

  DescribeAggregateIdFormatResult({
    this.useLongIdsAggregated,
    this.statuses,
  });
  static DescribeAggregateIdFormatResult fromJson(Map<String, dynamic> json) =>
      DescribeAggregateIdFormatResult(
        useLongIdsAggregated: json.containsKey('UseLongIdsAggregated')
            ? json['UseLongIdsAggregated'] as bool
            : null,
        statuses: json.containsKey('Statuses')
            ? (json['Statuses'] as List)
                .map((e) => IdFormat.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeAvailabilityZonesResult {
  /// Information about the Availability Zones.
  final List<AvailabilityZone> availabilityZones;

  DescribeAvailabilityZonesResult({
    this.availabilityZones,
  });
  static DescribeAvailabilityZonesResult fromJson(Map<String, dynamic> json) =>
      DescribeAvailabilityZonesResult(
        availabilityZones: json.containsKey('AvailabilityZones')
            ? (json['AvailabilityZones'] as List)
                .map((e) => AvailabilityZone.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeBundleTasksResult {
  /// Information about the bundle tasks.
  final List<BundleTask> bundleTasks;

  DescribeBundleTasksResult({
    this.bundleTasks,
  });
  static DescribeBundleTasksResult fromJson(Map<String, dynamic> json) =>
      DescribeBundleTasksResult(
        bundleTasks: json.containsKey('BundleTasks')
            ? (json['BundleTasks'] as List)
                .map((e) => BundleTask.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeByoipCidrsResult {
  /// Information about your address ranges.
  final List<ByoipCidr> byoipCidrs;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeByoipCidrsResult({
    this.byoipCidrs,
    this.nextToken,
  });
  static DescribeByoipCidrsResult fromJson(Map<String, dynamic> json) =>
      DescribeByoipCidrsResult(
        byoipCidrs: json.containsKey('ByoipCidrs')
            ? (json['ByoipCidrs'] as List)
                .map((e) => ByoipCidr.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeCapacityReservationsResult {
  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  /// Information about the Capacity Reservations.
  final List<CapacityReservation> capacityReservations;

  DescribeCapacityReservationsResult({
    this.nextToken,
    this.capacityReservations,
  });
  static DescribeCapacityReservationsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeCapacityReservationsResult(
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
        capacityReservations: json.containsKey('CapacityReservations')
            ? (json['CapacityReservations'] as List)
                .map((e) => CapacityReservation.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeClassicLinkInstancesResult {
  /// Information about one or more linked EC2-Classic instances.
  final List<ClassicLinkInstance> instances;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeClassicLinkInstancesResult({
    this.instances,
    this.nextToken,
  });
  static DescribeClassicLinkInstancesResult fromJson(
          Map<String, dynamic> json) =>
      DescribeClassicLinkInstancesResult(
        instances: json.containsKey('Instances')
            ? (json['Instances'] as List)
                .map((e) => ClassicLinkInstance.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeClientVpnAuthorizationRulesResult {
  /// Information about the authorization rules.
  final List<AuthorizationRule> authorizationRules;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeClientVpnAuthorizationRulesResult({
    this.authorizationRules,
    this.nextToken,
  });
  static DescribeClientVpnAuthorizationRulesResult fromJson(
          Map<String, dynamic> json) =>
      DescribeClientVpnAuthorizationRulesResult(
        authorizationRules: json.containsKey('AuthorizationRules')
            ? (json['AuthorizationRules'] as List)
                .map((e) => AuthorizationRule.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeClientVpnConnectionsResult {
  /// Information about the active and terminated client connections.
  final List<ClientVpnConnection> connections;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeClientVpnConnectionsResult({
    this.connections,
    this.nextToken,
  });
  static DescribeClientVpnConnectionsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeClientVpnConnectionsResult(
        connections: json.containsKey('Connections')
            ? (json['Connections'] as List)
                .map((e) => ClientVpnConnection.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeClientVpnEndpointsResult {
  /// Information about the Client VPN endpoints.
  final List<ClientVpnEndpoint> clientVpnEndpoints;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeClientVpnEndpointsResult({
    this.clientVpnEndpoints,
    this.nextToken,
  });
  static DescribeClientVpnEndpointsResult fromJson(Map<String, dynamic> json) =>
      DescribeClientVpnEndpointsResult(
        clientVpnEndpoints: json.containsKey('ClientVpnEndpoints')
            ? (json['ClientVpnEndpoints'] as List)
                .map((e) => ClientVpnEndpoint.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeClientVpnRoutesResult {
  /// Information about the Client VPN endpoint routes.
  final List<ClientVpnRoute> routes;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeClientVpnRoutesResult({
    this.routes,
    this.nextToken,
  });
  static DescribeClientVpnRoutesResult fromJson(Map<String, dynamic> json) =>
      DescribeClientVpnRoutesResult(
        routes: json.containsKey('Routes')
            ? (json['Routes'] as List)
                .map((e) => ClientVpnRoute.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeClientVpnTargetNetworksResult {
  /// Information about the associated target networks.
  final List<TargetNetwork> clientVpnTargetNetworks;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeClientVpnTargetNetworksResult({
    this.clientVpnTargetNetworks,
    this.nextToken,
  });
  static DescribeClientVpnTargetNetworksResult fromJson(
          Map<String, dynamic> json) =>
      DescribeClientVpnTargetNetworksResult(
        clientVpnTargetNetworks: json.containsKey('ClientVpnTargetNetworks')
            ? (json['ClientVpnTargetNetworks'] as List)
                .map((e) => TargetNetwork.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeConversionTasksResult {
  /// Information about the conversion tasks.
  final List<ConversionTask> conversionTasks;

  DescribeConversionTasksResult({
    this.conversionTasks,
  });
  static DescribeConversionTasksResult fromJson(Map<String, dynamic> json) =>
      DescribeConversionTasksResult(
        conversionTasks: json.containsKey('ConversionTasks')
            ? (json['ConversionTasks'] as List)
                .map((e) => ConversionTask.fromJson(e))
                .toList()
            : null,
      );
}

/// Contains the output of DescribeCustomerGateways.
class DescribeCustomerGatewaysResult {
  /// Information about one or more customer gateways.
  final List<CustomerGateway> customerGateways;

  DescribeCustomerGatewaysResult({
    this.customerGateways,
  });
  static DescribeCustomerGatewaysResult fromJson(Map<String, dynamic> json) =>
      DescribeCustomerGatewaysResult(
        customerGateways: json.containsKey('CustomerGateways')
            ? (json['CustomerGateways'] as List)
                .map((e) => CustomerGateway.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeDhcpOptionsResult {
  /// Information about one or more DHCP options sets.
  final List<DhcpOptions> dhcpOptions;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeDhcpOptionsResult({
    this.dhcpOptions,
    this.nextToken,
  });
  static DescribeDhcpOptionsResult fromJson(Map<String, dynamic> json) =>
      DescribeDhcpOptionsResult(
        dhcpOptions: json.containsKey('DhcpOptions')
            ? (json['DhcpOptions'] as List)
                .map((e) => DhcpOptions.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeEgressOnlyInternetGatewaysResult {
  /// Information about the egress-only internet gateways.
  final List<EgressOnlyInternetGateway> egressOnlyInternetGateways;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeEgressOnlyInternetGatewaysResult({
    this.egressOnlyInternetGateways,
    this.nextToken,
  });
  static DescribeEgressOnlyInternetGatewaysResult fromJson(
          Map<String, dynamic> json) =>
      DescribeEgressOnlyInternetGatewaysResult(
        egressOnlyInternetGateways:
            json.containsKey('EgressOnlyInternetGateways')
                ? (json['EgressOnlyInternetGateways'] as List)
                    .map((e) => EgressOnlyInternetGateway.fromJson(e))
                    .toList()
                : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeElasticGpusResult {
  /// Information about the Elastic Graphics accelerators.
  final List<ElasticGpus> elasticGpuSet;

  /// The total number of items to return. If the total number of items
  /// available is more than the value specified in max-items then a Next-Token
  /// will be provided in the output that you can use to resume pagination.
  final int maxResults;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeElasticGpusResult({
    this.elasticGpuSet,
    this.maxResults,
    this.nextToken,
  });
  static DescribeElasticGpusResult fromJson(Map<String, dynamic> json) =>
      DescribeElasticGpusResult(
        elasticGpuSet: json.containsKey('ElasticGpuSet')
            ? (json['ElasticGpuSet'] as List)
                .map((e) => ElasticGpus.fromJson(e))
                .toList()
            : null,
        maxResults:
            json.containsKey('MaxResults') ? json['MaxResults'] as int : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeExportImageTasksResult {
  /// Information about the export image tasks.
  final List<ExportImageTask> exportImageTasks;

  /// The token to use to get the next page of results. This value is `null`
  /// when there are no more results to return.
  final String nextToken;

  DescribeExportImageTasksResult({
    this.exportImageTasks,
    this.nextToken,
  });
  static DescribeExportImageTasksResult fromJson(Map<String, dynamic> json) =>
      DescribeExportImageTasksResult(
        exportImageTasks: json.containsKey('ExportImageTasks')
            ? (json['ExportImageTasks'] as List)
                .map((e) => ExportImageTask.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeExportTasksResult {
  /// Information about the export tasks.
  final List<ExportTask> exportTasks;

  DescribeExportTasksResult({
    this.exportTasks,
  });
  static DescribeExportTasksResult fromJson(Map<String, dynamic> json) =>
      DescribeExportTasksResult(
        exportTasks: json.containsKey('ExportTasks')
            ? (json['ExportTasks'] as List)
                .map((e) => ExportTask.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes the instances that could not be launched by the fleet.
class DescribeFleetError {
  /// The launch templates and overrides that were used for launching the
  /// instances. Any parameters that you specify in the Overrides override the
  /// same parameters in the launch template.
  final LaunchTemplateAndOverridesResponse launchTemplateAndOverrides;

  /// Indicates if the instance that could not be launched was a Spot Instance
  /// or On-Demand Instance.
  final String lifecycle;

  /// The error code that indicates why the instance could not be launched. For
  /// more information about error codes, see
  /// [Error Codes](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html).
  final String errorCode;

  /// The error message that describes why the instance could not be launched.
  /// For more information about error messages, see ee
  /// [Error Codes](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html).
  final String errorMessage;

  DescribeFleetError({
    this.launchTemplateAndOverrides,
    this.lifecycle,
    this.errorCode,
    this.errorMessage,
  });
  static DescribeFleetError fromJson(Map<String, dynamic> json) =>
      DescribeFleetError(
        launchTemplateAndOverrides:
            json.containsKey('LaunchTemplateAndOverrides')
                ? LaunchTemplateAndOverridesResponse.fromJson(
                    json['LaunchTemplateAndOverrides'])
                : null,
        lifecycle:
            json.containsKey('Lifecycle') ? json['Lifecycle'] as String : null,
        errorCode:
            json.containsKey('ErrorCode') ? json['ErrorCode'] as String : null,
        errorMessage: json.containsKey('ErrorMessage')
            ? json['ErrorMessage'] as String
            : null,
      );
}

class DescribeFleetHistoryResult {
  /// Information about the events in the history of the EC2 Fleet.
  final List<HistoryRecordEntry> historyRecords;

  /// The last date and time for the events, in UTC format (for example,
  /// _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z). All records up to this time were
  /// retrieved.
  ///
  /// If `nextToken` indicates that there are more results, this value is not
  /// present.
  final DateTime lastEvaluatedTime;

  /// The token for the next set of results.
  final String nextToken;

  /// The ID of the EC Fleet.
  final String fleetId;

  /// The start date and time for the events, in UTC format (for example,
  /// _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z).
  final DateTime startTime;

  DescribeFleetHistoryResult({
    this.historyRecords,
    this.lastEvaluatedTime,
    this.nextToken,
    this.fleetId,
    this.startTime,
  });
  static DescribeFleetHistoryResult fromJson(Map<String, dynamic> json) =>
      DescribeFleetHistoryResult(
        historyRecords: json.containsKey('HistoryRecords')
            ? (json['HistoryRecords'] as List)
                .map((e) => HistoryRecordEntry.fromJson(e))
                .toList()
            : null,
        lastEvaluatedTime: json.containsKey('LastEvaluatedTime')
            ? DateTime.parse(json['LastEvaluatedTime'])
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
        fleetId: json.containsKey('FleetId') ? json['FleetId'] as String : null,
        startTime: json.containsKey('StartTime')
            ? DateTime.parse(json['StartTime'])
            : null,
      );
}

class DescribeFleetInstancesResult {
  /// The running instances. This list is refreshed periodically and might be
  /// out of date.
  final List<ActiveInstance> activeInstances;

  /// The token for the next set of results.
  final String nextToken;

  /// The ID of the EC2 Fleet.
  final String fleetId;

  DescribeFleetInstancesResult({
    this.activeInstances,
    this.nextToken,
    this.fleetId,
  });
  static DescribeFleetInstancesResult fromJson(Map<String, dynamic> json) =>
      DescribeFleetInstancesResult(
        activeInstances: json.containsKey('ActiveInstances')
            ? (json['ActiveInstances'] as List)
                .map((e) => ActiveInstance.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
        fleetId: json.containsKey('FleetId') ? json['FleetId'] as String : null,
      );
}

/// Describes the instances that were launched by the fleet.
class DescribeFleetsInstances {
  /// The launch templates and overrides that were used for launching the
  /// instances. Any parameters that you specify in the Overrides override the
  /// same parameters in the launch template.
  final LaunchTemplateAndOverridesResponse launchTemplateAndOverrides;

  /// Indicates if the instance that was launched is a Spot Instance or
  /// On-Demand Instance.
  final String lifecycle;

  /// The IDs of the instances.
  final List<String> instanceIds;

  /// The instance type.
  final String instanceType;

  /// The value is `Windows` for Windows instances; otherwise blank.
  final String platform;

  DescribeFleetsInstances({
    this.launchTemplateAndOverrides,
    this.lifecycle,
    this.instanceIds,
    this.instanceType,
    this.platform,
  });
  static DescribeFleetsInstances fromJson(Map<String, dynamic> json) =>
      DescribeFleetsInstances(
        launchTemplateAndOverrides:
            json.containsKey('LaunchTemplateAndOverrides')
                ? LaunchTemplateAndOverridesResponse.fromJson(
                    json['LaunchTemplateAndOverrides'])
                : null,
        lifecycle:
            json.containsKey('Lifecycle') ? json['Lifecycle'] as String : null,
        instanceIds: json.containsKey('InstanceIds')
            ? (json['InstanceIds'] as List).map((e) => e as String).toList()
            : null,
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        platform:
            json.containsKey('Platform') ? json['Platform'] as String : null,
      );
}

class DescribeFleetsResult {
  /// The token for the next set of results.
  final String nextToken;

  /// Information about the EC2 Fleets.
  final List<FleetData> fleets;

  DescribeFleetsResult({
    this.nextToken,
    this.fleets,
  });
  static DescribeFleetsResult fromJson(Map<String, dynamic> json) =>
      DescribeFleetsResult(
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
        fleets: json.containsKey('Fleets')
            ? (json['Fleets'] as List)
                .map((e) => FleetData.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeFlowLogsResult {
  /// Information about the flow logs.
  final List<FlowLog> flowLogs;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeFlowLogsResult({
    this.flowLogs,
    this.nextToken,
  });
  static DescribeFlowLogsResult fromJson(Map<String, dynamic> json) =>
      DescribeFlowLogsResult(
        flowLogs: json.containsKey('FlowLogs')
            ? (json['FlowLogs'] as List)
                .map((e) => FlowLog.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeFpgaImageAttributeResult {
  /// Information about the attribute.
  final FpgaImageAttribute fpgaImageAttribute;

  DescribeFpgaImageAttributeResult({
    this.fpgaImageAttribute,
  });
  static DescribeFpgaImageAttributeResult fromJson(Map<String, dynamic> json) =>
      DescribeFpgaImageAttributeResult(
        fpgaImageAttribute: json.containsKey('FpgaImageAttribute')
            ? FpgaImageAttribute.fromJson(json['FpgaImageAttribute'])
            : null,
      );
}

class DescribeFpgaImagesResult {
  /// Information about the FPGA images.
  final List<FpgaImage> fpgaImages;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeFpgaImagesResult({
    this.fpgaImages,
    this.nextToken,
  });
  static DescribeFpgaImagesResult fromJson(Map<String, dynamic> json) =>
      DescribeFpgaImagesResult(
        fpgaImages: json.containsKey('FpgaImages')
            ? (json['FpgaImages'] as List)
                .map((e) => FpgaImage.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeHostReservationOfferingsResult {
  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  /// Information about the offerings.
  final List<HostOffering> offeringSet;

  DescribeHostReservationOfferingsResult({
    this.nextToken,
    this.offeringSet,
  });
  static DescribeHostReservationOfferingsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeHostReservationOfferingsResult(
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
        offeringSet: json.containsKey('OfferingSet')
            ? (json['OfferingSet'] as List)
                .map((e) => HostOffering.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeHostReservationsResult {
  /// Details about the reservation's configuration.
  final List<HostReservation> hostReservationSet;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeHostReservationsResult({
    this.hostReservationSet,
    this.nextToken,
  });
  static DescribeHostReservationsResult fromJson(Map<String, dynamic> json) =>
      DescribeHostReservationsResult(
        hostReservationSet: json.containsKey('HostReservationSet')
            ? (json['HostReservationSet'] as List)
                .map((e) => HostReservation.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeHostsResult {
  /// Information about the Dedicated Hosts.
  final List<Host> hosts;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeHostsResult({
    this.hosts,
    this.nextToken,
  });
  static DescribeHostsResult fromJson(Map<String, dynamic> json) =>
      DescribeHostsResult(
        hosts: json.containsKey('Hosts')
            ? (json['Hosts'] as List).map((e) => Host.fromJson(e)).toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeIamInstanceProfileAssociationsResult {
  /// Information about the IAM instance profile associations.
  final List<IamInstanceProfileAssociation> iamInstanceProfileAssociations;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeIamInstanceProfileAssociationsResult({
    this.iamInstanceProfileAssociations,
    this.nextToken,
  });
  static DescribeIamInstanceProfileAssociationsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeIamInstanceProfileAssociationsResult(
        iamInstanceProfileAssociations:
            json.containsKey('IamInstanceProfileAssociations')
                ? (json['IamInstanceProfileAssociations'] as List)
                    .map((e) => IamInstanceProfileAssociation.fromJson(e))
                    .toList()
                : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeIdFormatResult {
  /// Information about the ID format for the resource.
  final List<IdFormat> statuses;

  DescribeIdFormatResult({
    this.statuses,
  });
  static DescribeIdFormatResult fromJson(Map<String, dynamic> json) =>
      DescribeIdFormatResult(
        statuses: json.containsKey('Statuses')
            ? (json['Statuses'] as List)
                .map((e) => IdFormat.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeIdentityIdFormatResult {
  /// Information about the ID format for the resources.
  final List<IdFormat> statuses;

  DescribeIdentityIdFormatResult({
    this.statuses,
  });
  static DescribeIdentityIdFormatResult fromJson(Map<String, dynamic> json) =>
      DescribeIdentityIdFormatResult(
        statuses: json.containsKey('Statuses')
            ? (json['Statuses'] as List)
                .map((e) => IdFormat.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeImagesResult {
  /// Information about the images.
  final List<Image> images;

  DescribeImagesResult({
    this.images,
  });
  static DescribeImagesResult fromJson(Map<String, dynamic> json) =>
      DescribeImagesResult(
        images: json.containsKey('Images')
            ? (json['Images'] as List).map((e) => Image.fromJson(e)).toList()
            : null,
      );
}

class DescribeImportImageTasksResult {
  /// A list of zero or more import image tasks that are currently active or
  /// were completed or canceled in the previous 7 days.
  final List<ImportImageTask> importImageTasks;

  /// The token to use to get the next page of results. This value is `null`
  /// when there are no more results to return.
  final String nextToken;

  DescribeImportImageTasksResult({
    this.importImageTasks,
    this.nextToken,
  });
  static DescribeImportImageTasksResult fromJson(Map<String, dynamic> json) =>
      DescribeImportImageTasksResult(
        importImageTasks: json.containsKey('ImportImageTasks')
            ? (json['ImportImageTasks'] as List)
                .map((e) => ImportImageTask.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeImportSnapshotTasksResult {
  /// A list of zero or more import snapshot tasks that are currently active or
  /// were completed or canceled in the previous 7 days.
  final List<ImportSnapshotTask> importSnapshotTasks;

  /// The token to use to get the next page of results. This value is `null`
  /// when there are no more results to return.
  final String nextToken;

  DescribeImportSnapshotTasksResult({
    this.importSnapshotTasks,
    this.nextToken,
  });
  static DescribeImportSnapshotTasksResult fromJson(
          Map<String, dynamic> json) =>
      DescribeImportSnapshotTasksResult(
        importSnapshotTasks: json.containsKey('ImportSnapshotTasks')
            ? (json['ImportSnapshotTasks'] as List)
                .map((e) => ImportSnapshotTask.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeInstanceCreditSpecificationsResult {
  /// Information about the credit option for CPU usage of an instance.
  final List<InstanceCreditSpecification> instanceCreditSpecifications;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeInstanceCreditSpecificationsResult({
    this.instanceCreditSpecifications,
    this.nextToken,
  });
  static DescribeInstanceCreditSpecificationsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeInstanceCreditSpecificationsResult(
        instanceCreditSpecifications:
            json.containsKey('InstanceCreditSpecifications')
                ? (json['InstanceCreditSpecifications'] as List)
                    .map((e) => InstanceCreditSpecification.fromJson(e))
                    .toList()
                : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeInstanceStatusResult {
  /// Information about the status of the instances.
  final List<InstanceStatus> instanceStatuses;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeInstanceStatusResult({
    this.instanceStatuses,
    this.nextToken,
  });
  static DescribeInstanceStatusResult fromJson(Map<String, dynamic> json) =>
      DescribeInstanceStatusResult(
        instanceStatuses: json.containsKey('InstanceStatuses')
            ? (json['InstanceStatuses'] as List)
                .map((e) => InstanceStatus.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeInstancesResult {
  /// Information about the reservations.
  final List<Reservation> reservations;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeInstancesResult({
    this.reservations,
    this.nextToken,
  });
  static DescribeInstancesResult fromJson(Map<String, dynamic> json) =>
      DescribeInstancesResult(
        reservations: json.containsKey('Reservations')
            ? (json['Reservations'] as List)
                .map((e) => Reservation.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeInternetGatewaysResult {
  /// Information about one or more internet gateways.
  final List<InternetGateway> internetGateways;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeInternetGatewaysResult({
    this.internetGateways,
    this.nextToken,
  });
  static DescribeInternetGatewaysResult fromJson(Map<String, dynamic> json) =>
      DescribeInternetGatewaysResult(
        internetGateways: json.containsKey('InternetGateways')
            ? (json['InternetGateways'] as List)
                .map((e) => InternetGateway.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeKeyPairsResult {
  /// Information about the key pairs.
  final List<KeyPairInfo> keyPairs;

  DescribeKeyPairsResult({
    this.keyPairs,
  });
  static DescribeKeyPairsResult fromJson(Map<String, dynamic> json) =>
      DescribeKeyPairsResult(
        keyPairs: json.containsKey('KeyPairs')
            ? (json['KeyPairs'] as List)
                .map((e) => KeyPairInfo.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeLaunchTemplateVersionsResult {
  /// Information about the launch template versions.
  final List<LaunchTemplateVersion> launchTemplateVersions;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeLaunchTemplateVersionsResult({
    this.launchTemplateVersions,
    this.nextToken,
  });
  static DescribeLaunchTemplateVersionsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeLaunchTemplateVersionsResult(
        launchTemplateVersions: json.containsKey('LaunchTemplateVersions')
            ? (json['LaunchTemplateVersions'] as List)
                .map((e) => LaunchTemplateVersion.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeLaunchTemplatesResult {
  /// Information about the launch templates.
  final List<LaunchTemplate> launchTemplates;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeLaunchTemplatesResult({
    this.launchTemplates,
    this.nextToken,
  });
  static DescribeLaunchTemplatesResult fromJson(Map<String, dynamic> json) =>
      DescribeLaunchTemplatesResult(
        launchTemplates: json.containsKey('LaunchTemplates')
            ? (json['LaunchTemplates'] as List)
                .map((e) => LaunchTemplate.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeMovingAddressesResult {
  /// The status for each Elastic IP address.
  final List<MovingAddressStatus> movingAddressStatuses;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeMovingAddressesResult({
    this.movingAddressStatuses,
    this.nextToken,
  });
  static DescribeMovingAddressesResult fromJson(Map<String, dynamic> json) =>
      DescribeMovingAddressesResult(
        movingAddressStatuses: json.containsKey('MovingAddressStatuses')
            ? (json['MovingAddressStatuses'] as List)
                .map((e) => MovingAddressStatus.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeNatGatewaysResult {
  /// Information about the NAT gateways.
  final List<NatGateway> natGateways;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeNatGatewaysResult({
    this.natGateways,
    this.nextToken,
  });
  static DescribeNatGatewaysResult fromJson(Map<String, dynamic> json) =>
      DescribeNatGatewaysResult(
        natGateways: json.containsKey('NatGateways')
            ? (json['NatGateways'] as List)
                .map((e) => NatGateway.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeNetworkAclsResult {
  /// Information about one or more network ACLs.
  final List<NetworkAcl> networkAcls;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeNetworkAclsResult({
    this.networkAcls,
    this.nextToken,
  });
  static DescribeNetworkAclsResult fromJson(Map<String, dynamic> json) =>
      DescribeNetworkAclsResult(
        networkAcls: json.containsKey('NetworkAcls')
            ? (json['NetworkAcls'] as List)
                .map((e) => NetworkAcl.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

/// Contains the output of DescribeNetworkInterfaceAttribute.
class DescribeNetworkInterfaceAttributeResult {
  /// The attachment (if any) of the network interface.
  final NetworkInterfaceAttachment attachment;

  /// The description of the network interface.
  final AttributeValue description;

  /// The security groups associated with the network interface.
  final List<GroupIdentifier> groups;

  /// The ID of the network interface.
  final String networkInterfaceId;

  /// Indicates whether source/destination checking is enabled.
  final AttributeBooleanValue sourceDestCheck;

  DescribeNetworkInterfaceAttributeResult({
    this.attachment,
    this.description,
    this.groups,
    this.networkInterfaceId,
    this.sourceDestCheck,
  });
  static DescribeNetworkInterfaceAttributeResult fromJson(
          Map<String, dynamic> json) =>
      DescribeNetworkInterfaceAttributeResult(
        attachment: json.containsKey('Attachment')
            ? NetworkInterfaceAttachment.fromJson(json['Attachment'])
            : null,
        description: json.containsKey('Description')
            ? AttributeValue.fromJson(json['Description'])
            : null,
        groups: json.containsKey('Groups')
            ? (json['Groups'] as List)
                .map((e) => GroupIdentifier.fromJson(e))
                .toList()
            : null,
        networkInterfaceId: json.containsKey('NetworkInterfaceId')
            ? json['NetworkInterfaceId'] as String
            : null,
        sourceDestCheck: json.containsKey('SourceDestCheck')
            ? AttributeBooleanValue.fromJson(json['SourceDestCheck'])
            : null,
      );
}

/// Contains the output for DescribeNetworkInterfacePermissions.
class DescribeNetworkInterfacePermissionsResult {
  /// The network interface permissions.
  final List<NetworkInterfacePermission> networkInterfacePermissions;

  /// The token to use to retrieve the next page of results.
  final String nextToken;

  DescribeNetworkInterfacePermissionsResult({
    this.networkInterfacePermissions,
    this.nextToken,
  });
  static DescribeNetworkInterfacePermissionsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeNetworkInterfacePermissionsResult(
        networkInterfacePermissions:
            json.containsKey('NetworkInterfacePermissions')
                ? (json['NetworkInterfacePermissions'] as List)
                    .map((e) => NetworkInterfacePermission.fromJson(e))
                    .toList()
                : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

/// Contains the output of DescribeNetworkInterfaces.
class DescribeNetworkInterfacesResult {
  /// Information about one or more network interfaces.
  final List<NetworkInterface> networkInterfaces;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeNetworkInterfacesResult({
    this.networkInterfaces,
    this.nextToken,
  });
  static DescribeNetworkInterfacesResult fromJson(Map<String, dynamic> json) =>
      DescribeNetworkInterfacesResult(
        networkInterfaces: json.containsKey('NetworkInterfaces')
            ? (json['NetworkInterfaces'] as List)
                .map((e) => NetworkInterface.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribePlacementGroupsResult {
  /// Information about the placement groups.
  final List<PlacementGroup> placementGroups;

  DescribePlacementGroupsResult({
    this.placementGroups,
  });
  static DescribePlacementGroupsResult fromJson(Map<String, dynamic> json) =>
      DescribePlacementGroupsResult(
        placementGroups: json.containsKey('PlacementGroups')
            ? (json['PlacementGroups'] as List)
                .map((e) => PlacementGroup.fromJson(e))
                .toList()
            : null,
      );
}

class DescribePrefixListsResult {
  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  /// All available prefix lists.
  final List<PrefixList> prefixLists;

  DescribePrefixListsResult({
    this.nextToken,
    this.prefixLists,
  });
  static DescribePrefixListsResult fromJson(Map<String, dynamic> json) =>
      DescribePrefixListsResult(
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
        prefixLists: json.containsKey('PrefixLists')
            ? (json['PrefixLists'] as List)
                .map((e) => PrefixList.fromJson(e))
                .toList()
            : null,
      );
}

class DescribePrincipalIdFormatResult {
  /// Information about the ID format settings for the ARN.
  final List<PrincipalIdFormat> principals;

  /// The token to use to retrieve the next page of results. This value is null
  /// when there are no more results to return.
  final String nextToken;

  DescribePrincipalIdFormatResult({
    this.principals,
    this.nextToken,
  });
  static DescribePrincipalIdFormatResult fromJson(Map<String, dynamic> json) =>
      DescribePrincipalIdFormatResult(
        principals: json.containsKey('Principals')
            ? (json['Principals'] as List)
                .map((e) => PrincipalIdFormat.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribePublicIpv4PoolsResult {
  /// Information about the address pools.
  final List<PublicIpv4Pool> publicIpv4Pools;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribePublicIpv4PoolsResult({
    this.publicIpv4Pools,
    this.nextToken,
  });
  static DescribePublicIpv4PoolsResult fromJson(Map<String, dynamic> json) =>
      DescribePublicIpv4PoolsResult(
        publicIpv4Pools: json.containsKey('PublicIpv4Pools')
            ? (json['PublicIpv4Pools'] as List)
                .map((e) => PublicIpv4Pool.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeRegionsResult {
  /// Information about the Regions.
  final List<Region> regions;

  DescribeRegionsResult({
    this.regions,
  });
  static DescribeRegionsResult fromJson(Map<String, dynamic> json) =>
      DescribeRegionsResult(
        regions: json.containsKey('Regions')
            ? (json['Regions'] as List).map((e) => Region.fromJson(e)).toList()
            : null,
      );
}

/// Contains the output of DescribeReservedInstancesListings.
class DescribeReservedInstancesListingsResult {
  /// Information about the Reserved Instance listing.
  final List<ReservedInstancesListing> reservedInstancesListings;

  DescribeReservedInstancesListingsResult({
    this.reservedInstancesListings,
  });
  static DescribeReservedInstancesListingsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeReservedInstancesListingsResult(
        reservedInstancesListings: json.containsKey('ReservedInstancesListings')
            ? (json['ReservedInstancesListings'] as List)
                .map((e) => ReservedInstancesListing.fromJson(e))
                .toList()
            : null,
      );
}

/// Contains the output of DescribeReservedInstancesModifications.
class DescribeReservedInstancesModificationsResult {
  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  /// The Reserved Instance modification information.
  final List<ReservedInstancesModification> reservedInstancesModifications;

  DescribeReservedInstancesModificationsResult({
    this.nextToken,
    this.reservedInstancesModifications,
  });
  static DescribeReservedInstancesModificationsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeReservedInstancesModificationsResult(
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
        reservedInstancesModifications:
            json.containsKey('ReservedInstancesModifications')
                ? (json['ReservedInstancesModifications'] as List)
                    .map((e) => ReservedInstancesModification.fromJson(e))
                    .toList()
                : null,
      );
}

/// Contains the output of DescribeReservedInstancesOfferings.
class DescribeReservedInstancesOfferingsResult {
  /// A list of Reserved Instances offerings.
  final List<ReservedInstancesOffering> reservedInstancesOfferings;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeReservedInstancesOfferingsResult({
    this.reservedInstancesOfferings,
    this.nextToken,
  });
  static DescribeReservedInstancesOfferingsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeReservedInstancesOfferingsResult(
        reservedInstancesOfferings:
            json.containsKey('ReservedInstancesOfferings')
                ? (json['ReservedInstancesOfferings'] as List)
                    .map((e) => ReservedInstancesOffering.fromJson(e))
                    .toList()
                : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

/// Contains the output for DescribeReservedInstances.
class DescribeReservedInstancesResult {
  /// A list of Reserved Instances.
  final List<ReservedInstances> reservedInstances;

  DescribeReservedInstancesResult({
    this.reservedInstances,
  });
  static DescribeReservedInstancesResult fromJson(Map<String, dynamic> json) =>
      DescribeReservedInstancesResult(
        reservedInstances: json.containsKey('ReservedInstances')
            ? (json['ReservedInstances'] as List)
                .map((e) => ReservedInstances.fromJson(e))
                .toList()
            : null,
      );
}

/// Contains the output of DescribeRouteTables.
class DescribeRouteTablesResult {
  /// Information about one or more route tables.
  final List<RouteTable> routeTables;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeRouteTablesResult({
    this.routeTables,
    this.nextToken,
  });
  static DescribeRouteTablesResult fromJson(Map<String, dynamic> json) =>
      DescribeRouteTablesResult(
        routeTables: json.containsKey('RouteTables')
            ? (json['RouteTables'] as List)
                .map((e) => RouteTable.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

/// Contains the output of DescribeScheduledInstanceAvailability.
class DescribeScheduledInstanceAvailabilityResult {
  /// The token required to retrieve the next set of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  /// Information about the available Scheduled Instances.
  final List<ScheduledInstanceAvailability> scheduledInstanceAvailabilitySet;

  DescribeScheduledInstanceAvailabilityResult({
    this.nextToken,
    this.scheduledInstanceAvailabilitySet,
  });
  static DescribeScheduledInstanceAvailabilityResult fromJson(
          Map<String, dynamic> json) =>
      DescribeScheduledInstanceAvailabilityResult(
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
        scheduledInstanceAvailabilitySet:
            json.containsKey('ScheduledInstanceAvailabilitySet')
                ? (json['ScheduledInstanceAvailabilitySet'] as List)
                    .map((e) => ScheduledInstanceAvailability.fromJson(e))
                    .toList()
                : null,
      );
}

/// Contains the output of DescribeScheduledInstances.
class DescribeScheduledInstancesResult {
  /// The token required to retrieve the next set of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  /// Information about the Scheduled Instances.
  final List<ScheduledInstance> scheduledInstanceSet;

  DescribeScheduledInstancesResult({
    this.nextToken,
    this.scheduledInstanceSet,
  });
  static DescribeScheduledInstancesResult fromJson(Map<String, dynamic> json) =>
      DescribeScheduledInstancesResult(
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
        scheduledInstanceSet: json.containsKey('ScheduledInstanceSet')
            ? (json['ScheduledInstanceSet'] as List)
                .map((e) => ScheduledInstance.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeSecurityGroupReferencesResult {
  /// Information about the VPCs with the referencing security groups.
  final List<SecurityGroupReference> securityGroupReferenceSet;

  DescribeSecurityGroupReferencesResult({
    this.securityGroupReferenceSet,
  });
  static DescribeSecurityGroupReferencesResult fromJson(
          Map<String, dynamic> json) =>
      DescribeSecurityGroupReferencesResult(
        securityGroupReferenceSet: json.containsKey('SecurityGroupReferenceSet')
            ? (json['SecurityGroupReferenceSet'] as List)
                .map((e) => SecurityGroupReference.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeSecurityGroupsResult {
  /// Information about the security groups.
  final List<SecurityGroup> securityGroups;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeSecurityGroupsResult({
    this.securityGroups,
    this.nextToken,
  });
  static DescribeSecurityGroupsResult fromJson(Map<String, dynamic> json) =>
      DescribeSecurityGroupsResult(
        securityGroups: json.containsKey('SecurityGroups')
            ? (json['SecurityGroups'] as List)
                .map((e) => SecurityGroup.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

/// Contains the output of DescribeSnapshotAttribute.
class DescribeSnapshotAttributeResult {
  /// The users and groups that have the permissions for creating volumes from
  /// the snapshot.
  final List<CreateVolumePermission> createVolumePermissions;

  /// The product codes.
  final List<ProductCode> productCodes;

  /// The ID of the EBS snapshot.
  final String snapshotId;

  DescribeSnapshotAttributeResult({
    this.createVolumePermissions,
    this.productCodes,
    this.snapshotId,
  });
  static DescribeSnapshotAttributeResult fromJson(Map<String, dynamic> json) =>
      DescribeSnapshotAttributeResult(
        createVolumePermissions: json.containsKey('CreateVolumePermissions')
            ? (json['CreateVolumePermissions'] as List)
                .map((e) => CreateVolumePermission.fromJson(e))
                .toList()
            : null,
        productCodes: json.containsKey('ProductCodes')
            ? (json['ProductCodes'] as List)
                .map((e) => ProductCode.fromJson(e))
                .toList()
            : null,
        snapshotId: json.containsKey('SnapshotId')
            ? json['SnapshotId'] as String
            : null,
      );
}

class DescribeSnapshotsResult {
  /// Information about the snapshots.
  final List<Snapshot> snapshots;

  /// The `NextToken` value to include in a future `DescribeSnapshots` request.
  /// When the results of a `DescribeSnapshots` request exceed `MaxResults`,
  /// this value can be used to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeSnapshotsResult({
    this.snapshots,
    this.nextToken,
  });
  static DescribeSnapshotsResult fromJson(Map<String, dynamic> json) =>
      DescribeSnapshotsResult(
        snapshots: json.containsKey('Snapshots')
            ? (json['Snapshots'] as List)
                .map((e) => Snapshot.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

/// Contains the output of DescribeSpotDatafeedSubscription.
class DescribeSpotDatafeedSubscriptionResult {
  /// The Spot Instance data feed subscription.
  final SpotDatafeedSubscription spotDatafeedSubscription;

  DescribeSpotDatafeedSubscriptionResult({
    this.spotDatafeedSubscription,
  });
  static DescribeSpotDatafeedSubscriptionResult fromJson(
          Map<String, dynamic> json) =>
      DescribeSpotDatafeedSubscriptionResult(
        spotDatafeedSubscription: json.containsKey('SpotDatafeedSubscription')
            ? SpotDatafeedSubscription.fromJson(
                json['SpotDatafeedSubscription'])
            : null,
      );
}

/// Contains the output of DescribeSpotFleetInstances.
class DescribeSpotFleetInstancesResponse {
  /// The running instances. This list is refreshed periodically and might be
  /// out of date.
  final List<ActiveInstance> activeInstances;

  /// The token required to retrieve the next set of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  /// The ID of the Spot Fleet request.
  final String spotFleetRequestId;

  DescribeSpotFleetInstancesResponse({
    this.activeInstances,
    this.nextToken,
    this.spotFleetRequestId,
  });
  static DescribeSpotFleetInstancesResponse fromJson(
          Map<String, dynamic> json) =>
      DescribeSpotFleetInstancesResponse(
        activeInstances: json.containsKey('ActiveInstances')
            ? (json['ActiveInstances'] as List)
                .map((e) => ActiveInstance.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
        spotFleetRequestId: json.containsKey('SpotFleetRequestId')
            ? json['SpotFleetRequestId'] as String
            : null,
      );
}

/// Contains the output of DescribeSpotFleetRequestHistory.
class DescribeSpotFleetRequestHistoryResponse {
  /// Information about the events in the history of the Spot Fleet request.
  final List<HistoryRecord> historyRecords;

  /// The last date and time for the events, in UTC format (for example,
  /// _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z). All records up to this time were
  /// retrieved.
  ///
  /// If `nextToken` indicates that there are more results, this value is not
  /// present.
  final DateTime lastEvaluatedTime;

  /// The token required to retrieve the next set of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  /// The ID of the Spot Fleet request.
  final String spotFleetRequestId;

  /// The starting date and time for the events, in UTC format (for example,
  /// _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z).
  final DateTime startTime;

  DescribeSpotFleetRequestHistoryResponse({
    this.historyRecords,
    this.lastEvaluatedTime,
    this.nextToken,
    this.spotFleetRequestId,
    this.startTime,
  });
  static DescribeSpotFleetRequestHistoryResponse fromJson(
          Map<String, dynamic> json) =>
      DescribeSpotFleetRequestHistoryResponse(
        historyRecords: json.containsKey('HistoryRecords')
            ? (json['HistoryRecords'] as List)
                .map((e) => HistoryRecord.fromJson(e))
                .toList()
            : null,
        lastEvaluatedTime: json.containsKey('LastEvaluatedTime')
            ? DateTime.parse(json['LastEvaluatedTime'])
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
        spotFleetRequestId: json.containsKey('SpotFleetRequestId')
            ? json['SpotFleetRequestId'] as String
            : null,
        startTime: json.containsKey('StartTime')
            ? DateTime.parse(json['StartTime'])
            : null,
      );
}

/// Contains the output of DescribeSpotFleetRequests.
class DescribeSpotFleetRequestsResponse {
  /// The token required to retrieve the next set of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  /// Information about the configuration of your Spot Fleet.
  final List<SpotFleetRequestConfig> spotFleetRequestConfigs;

  DescribeSpotFleetRequestsResponse({
    this.nextToken,
    this.spotFleetRequestConfigs,
  });
  static DescribeSpotFleetRequestsResponse fromJson(
          Map<String, dynamic> json) =>
      DescribeSpotFleetRequestsResponse(
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
        spotFleetRequestConfigs: json.containsKey('SpotFleetRequestConfigs')
            ? (json['SpotFleetRequestConfigs'] as List)
                .map((e) => SpotFleetRequestConfig.fromJson(e))
                .toList()
            : null,
      );
}

/// Contains the output of DescribeSpotInstanceRequests.
class DescribeSpotInstanceRequestsResult {
  /// One or more Spot Instance requests.
  final List<SpotInstanceRequest> spotInstanceRequests;

  /// The token to use to retrieve the next set of results. This value is `null`
  /// when there are no more results to return.
  final String nextToken;

  DescribeSpotInstanceRequestsResult({
    this.spotInstanceRequests,
    this.nextToken,
  });
  static DescribeSpotInstanceRequestsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeSpotInstanceRequestsResult(
        spotInstanceRequests: json.containsKey('SpotInstanceRequests')
            ? (json['SpotInstanceRequests'] as List)
                .map((e) => SpotInstanceRequest.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

/// Contains the output of DescribeSpotPriceHistory.
class DescribeSpotPriceHistoryResult {
  /// The token required to retrieve the next set of results. This value is null
  /// or an empty string when there are no more results to return.
  final String nextToken;

  /// The historical Spot prices.
  final List<SpotPrice> spotPriceHistory;

  DescribeSpotPriceHistoryResult({
    this.nextToken,
    this.spotPriceHistory,
  });
  static DescribeSpotPriceHistoryResult fromJson(Map<String, dynamic> json) =>
      DescribeSpotPriceHistoryResult(
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
        spotPriceHistory: json.containsKey('SpotPriceHistory')
            ? (json['SpotPriceHistory'] as List)
                .map((e) => SpotPrice.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeStaleSecurityGroupsResult {
  /// The token to use when requesting the next set of items. If there are no
  /// additional items to return, the string is empty.
  final String nextToken;

  /// Information about the stale security groups.
  final List<StaleSecurityGroup> staleSecurityGroupSet;

  DescribeStaleSecurityGroupsResult({
    this.nextToken,
    this.staleSecurityGroupSet,
  });
  static DescribeStaleSecurityGroupsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeStaleSecurityGroupsResult(
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
        staleSecurityGroupSet: json.containsKey('StaleSecurityGroupSet')
            ? (json['StaleSecurityGroupSet'] as List)
                .map((e) => StaleSecurityGroup.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeSubnetsResult {
  /// Information about one or more subnets.
  final List<Subnet> subnets;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeSubnetsResult({
    this.subnets,
    this.nextToken,
  });
  static DescribeSubnetsResult fromJson(Map<String, dynamic> json) =>
      DescribeSubnetsResult(
        subnets: json.containsKey('Subnets')
            ? (json['Subnets'] as List).map((e) => Subnet.fromJson(e)).toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeTagsResult {
  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  /// The tags.
  final List<TagDescription> tags;

  DescribeTagsResult({
    this.nextToken,
    this.tags,
  });
  static DescribeTagsResult fromJson(Map<String, dynamic> json) =>
      DescribeTagsResult(
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List)
                .map((e) => TagDescription.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeTrafficMirrorFiltersResult {
  /// Information about one or more Traffic Mirror filters.
  final List<TrafficMirrorFilter> trafficMirrorFilters;

  /// The token to use to retrieve the next page of results. The value is `null`
  /// when there are no more results to return.
  final String nextToken;

  DescribeTrafficMirrorFiltersResult({
    this.trafficMirrorFilters,
    this.nextToken,
  });
  static DescribeTrafficMirrorFiltersResult fromJson(
          Map<String, dynamic> json) =>
      DescribeTrafficMirrorFiltersResult(
        trafficMirrorFilters: json.containsKey('TrafficMirrorFilters')
            ? (json['TrafficMirrorFilters'] as List)
                .map((e) => TrafficMirrorFilter.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeTrafficMirrorSessionsResult {
  /// Describes one or more Traffic Mirror sessions. By default, all Traffic
  /// Mirror sessions are described. Alternatively, you can filter the results.
  final List<TrafficMirrorSession> trafficMirrorSessions;

  /// The token to use to retrieve the next page of results. The value is `null`
  /// when there are no more results to return.
  final String nextToken;

  DescribeTrafficMirrorSessionsResult({
    this.trafficMirrorSessions,
    this.nextToken,
  });
  static DescribeTrafficMirrorSessionsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeTrafficMirrorSessionsResult(
        trafficMirrorSessions: json.containsKey('TrafficMirrorSessions')
            ? (json['TrafficMirrorSessions'] as List)
                .map((e) => TrafficMirrorSession.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeTrafficMirrorTargetsResult {
  /// Information about one or more Traffic Mirror targets.
  final List<TrafficMirrorTarget> trafficMirrorTargets;

  /// The token to use to retrieve the next page of results. The value is `null`
  /// when there are no more results to return.
  final String nextToken;

  DescribeTrafficMirrorTargetsResult({
    this.trafficMirrorTargets,
    this.nextToken,
  });
  static DescribeTrafficMirrorTargetsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeTrafficMirrorTargetsResult(
        trafficMirrorTargets: json.containsKey('TrafficMirrorTargets')
            ? (json['TrafficMirrorTargets'] as List)
                .map((e) => TrafficMirrorTarget.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeTransitGatewayAttachmentsResult {
  /// Information about the attachments.
  final List<TransitGatewayAttachment> transitGatewayAttachments;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeTransitGatewayAttachmentsResult({
    this.transitGatewayAttachments,
    this.nextToken,
  });
  static DescribeTransitGatewayAttachmentsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeTransitGatewayAttachmentsResult(
        transitGatewayAttachments: json.containsKey('TransitGatewayAttachments')
            ? (json['TransitGatewayAttachments'] as List)
                .map((e) => TransitGatewayAttachment.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeTransitGatewayRouteTablesResult {
  /// Information about the transit gateway route tables.
  final List<TransitGatewayRouteTable> transitGatewayRouteTables;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeTransitGatewayRouteTablesResult({
    this.transitGatewayRouteTables,
    this.nextToken,
  });
  static DescribeTransitGatewayRouteTablesResult fromJson(
          Map<String, dynamic> json) =>
      DescribeTransitGatewayRouteTablesResult(
        transitGatewayRouteTables: json.containsKey('TransitGatewayRouteTables')
            ? (json['TransitGatewayRouteTables'] as List)
                .map((e) => TransitGatewayRouteTable.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeTransitGatewayVpcAttachmentsResult {
  /// Information about the VPC attachments.
  final List<TransitGatewayVpcAttachment> transitGatewayVpcAttachments;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeTransitGatewayVpcAttachmentsResult({
    this.transitGatewayVpcAttachments,
    this.nextToken,
  });
  static DescribeTransitGatewayVpcAttachmentsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeTransitGatewayVpcAttachmentsResult(
        transitGatewayVpcAttachments:
            json.containsKey('TransitGatewayVpcAttachments')
                ? (json['TransitGatewayVpcAttachments'] as List)
                    .map((e) => TransitGatewayVpcAttachment.fromJson(e))
                    .toList()
                : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeTransitGatewaysResult {
  /// Information about the transit gateways.
  final List<TransitGateway> transitGateways;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeTransitGatewaysResult({
    this.transitGateways,
    this.nextToken,
  });
  static DescribeTransitGatewaysResult fromJson(Map<String, dynamic> json) =>
      DescribeTransitGatewaysResult(
        transitGateways: json.containsKey('TransitGateways')
            ? (json['TransitGateways'] as List)
                .map((e) => TransitGateway.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

/// Contains the output of DescribeVolumeAttribute.
class DescribeVolumeAttributeResult {
  /// The state of `autoEnableIO` attribute.
  final AttributeBooleanValue autoEnableIO;

  /// A list of product codes.
  final List<ProductCode> productCodes;

  /// The ID of the volume.
  final String volumeId;

  DescribeVolumeAttributeResult({
    this.autoEnableIO,
    this.productCodes,
    this.volumeId,
  });
  static DescribeVolumeAttributeResult fromJson(Map<String, dynamic> json) =>
      DescribeVolumeAttributeResult(
        autoEnableIO: json.containsKey('AutoEnableIO')
            ? AttributeBooleanValue.fromJson(json['AutoEnableIO'])
            : null,
        productCodes: json.containsKey('ProductCodes')
            ? (json['ProductCodes'] as List)
                .map((e) => ProductCode.fromJson(e))
                .toList()
            : null,
        volumeId:
            json.containsKey('VolumeId') ? json['VolumeId'] as String : null,
      );
}

class DescribeVolumeStatusResult {
  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  /// Information about the status of the volumes.
  final List<VolumeStatusItem> volumeStatuses;

  DescribeVolumeStatusResult({
    this.nextToken,
    this.volumeStatuses,
  });
  static DescribeVolumeStatusResult fromJson(Map<String, dynamic> json) =>
      DescribeVolumeStatusResult(
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
        volumeStatuses: json.containsKey('VolumeStatuses')
            ? (json['VolumeStatuses'] as List)
                .map((e) => VolumeStatusItem.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeVolumesModificationsResult {
  /// Information about the volume modifications.
  final List<VolumeModification> volumesModifications;

  /// Token for pagination, null if there are no more results
  final String nextToken;

  DescribeVolumesModificationsResult({
    this.volumesModifications,
    this.nextToken,
  });
  static DescribeVolumesModificationsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeVolumesModificationsResult(
        volumesModifications: json.containsKey('VolumesModifications')
            ? (json['VolumesModifications'] as List)
                .map((e) => VolumeModification.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeVolumesResult {
  /// Information about the volumes.
  final List<Volume> volumes;

  /// The `NextToken` value to include in a future `DescribeVolumes` request.
  /// When the results of a `DescribeVolumes` request exceed `MaxResults`, this
  /// value can be used to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeVolumesResult({
    this.volumes,
    this.nextToken,
  });
  static DescribeVolumesResult fromJson(Map<String, dynamic> json) =>
      DescribeVolumesResult(
        volumes: json.containsKey('Volumes')
            ? (json['Volumes'] as List).map((e) => Volume.fromJson(e)).toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeVpcAttributeResult {
  /// The ID of the VPC.
  final String vpcId;

  /// Indicates whether the instances launched in the VPC get DNS hostnames. If
  /// this attribute is `true`, instances in the VPC get DNS hostnames;
  /// otherwise, they do not.
  final AttributeBooleanValue enableDnsHostnames;

  /// Indicates whether DNS resolution is enabled for the VPC. If this attribute
  /// is `true`, the Amazon DNS server resolves DNS hostnames for your instances
  /// to their corresponding IP addresses; otherwise, it does not.
  final AttributeBooleanValue enableDnsSupport;

  DescribeVpcAttributeResult({
    this.vpcId,
    this.enableDnsHostnames,
    this.enableDnsSupport,
  });
  static DescribeVpcAttributeResult fromJson(Map<String, dynamic> json) =>
      DescribeVpcAttributeResult(
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
        enableDnsHostnames: json.containsKey('EnableDnsHostnames')
            ? AttributeBooleanValue.fromJson(json['EnableDnsHostnames'])
            : null,
        enableDnsSupport: json.containsKey('EnableDnsSupport')
            ? AttributeBooleanValue.fromJson(json['EnableDnsSupport'])
            : null,
      );
}

class DescribeVpcClassicLinkDnsSupportResult {
  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  /// Information about the ClassicLink DNS support status of the VPCs.
  final List<ClassicLinkDnsSupport> vpcs;

  DescribeVpcClassicLinkDnsSupportResult({
    this.nextToken,
    this.vpcs,
  });
  static DescribeVpcClassicLinkDnsSupportResult fromJson(
          Map<String, dynamic> json) =>
      DescribeVpcClassicLinkDnsSupportResult(
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
        vpcs: json.containsKey('Vpcs')
            ? (json['Vpcs'] as List)
                .map((e) => ClassicLinkDnsSupport.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeVpcClassicLinkResult {
  /// The ClassicLink status of one or more VPCs.
  final List<VpcClassicLink> vpcs;

  DescribeVpcClassicLinkResult({
    this.vpcs,
  });
  static DescribeVpcClassicLinkResult fromJson(Map<String, dynamic> json) =>
      DescribeVpcClassicLinkResult(
        vpcs: json.containsKey('Vpcs')
            ? (json['Vpcs'] as List)
                .map((e) => VpcClassicLink.fromJson(e))
                .toList()
            : null,
      );
}

class DescribeVpcEndpointConnectionNotificationsResult {
  /// One or more notifications.
  final List<ConnectionNotification> connectionNotificationSet;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeVpcEndpointConnectionNotificationsResult({
    this.connectionNotificationSet,
    this.nextToken,
  });
  static DescribeVpcEndpointConnectionNotificationsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeVpcEndpointConnectionNotificationsResult(
        connectionNotificationSet: json.containsKey('ConnectionNotificationSet')
            ? (json['ConnectionNotificationSet'] as List)
                .map((e) => ConnectionNotification.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeVpcEndpointConnectionsResult {
  /// Information about one or more VPC endpoint connections.
  final List<VpcEndpointConnection> vpcEndpointConnections;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeVpcEndpointConnectionsResult({
    this.vpcEndpointConnections,
    this.nextToken,
  });
  static DescribeVpcEndpointConnectionsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeVpcEndpointConnectionsResult(
        vpcEndpointConnections: json.containsKey('VpcEndpointConnections')
            ? (json['VpcEndpointConnections'] as List)
                .map((e) => VpcEndpointConnection.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeVpcEndpointServiceConfigurationsResult {
  /// Information about one or more services.
  final List<ServiceConfiguration> serviceConfigurations;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeVpcEndpointServiceConfigurationsResult({
    this.serviceConfigurations,
    this.nextToken,
  });
  static DescribeVpcEndpointServiceConfigurationsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeVpcEndpointServiceConfigurationsResult(
        serviceConfigurations: json.containsKey('ServiceConfigurations')
            ? (json['ServiceConfigurations'] as List)
                .map((e) => ServiceConfiguration.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeVpcEndpointServicePermissionsResult {
  /// Information about one or more allowed principals.
  final List<AllowedPrincipal> allowedPrincipals;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeVpcEndpointServicePermissionsResult({
    this.allowedPrincipals,
    this.nextToken,
  });
  static DescribeVpcEndpointServicePermissionsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeVpcEndpointServicePermissionsResult(
        allowedPrincipals: json.containsKey('AllowedPrincipals')
            ? (json['AllowedPrincipals'] as List)
                .map((e) => AllowedPrincipal.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

/// Contains the output of DescribeVpcEndpointServices.
class DescribeVpcEndpointServicesResult {
  /// A list of supported services.
  final List<String> serviceNames;

  /// Information about the service.
  final List<ServiceDetail> serviceDetails;

  /// The token to use when requesting the next set of items. If there are no
  /// additional items to return, the string is empty.
  final String nextToken;

  DescribeVpcEndpointServicesResult({
    this.serviceNames,
    this.serviceDetails,
    this.nextToken,
  });
  static DescribeVpcEndpointServicesResult fromJson(
          Map<String, dynamic> json) =>
      DescribeVpcEndpointServicesResult(
        serviceNames: json.containsKey('ServiceNames')
            ? (json['ServiceNames'] as List).map((e) => e as String).toList()
            : null,
        serviceDetails: json.containsKey('ServiceDetails')
            ? (json['ServiceDetails'] as List)
                .map((e) => ServiceDetail.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

/// Contains the output of DescribeVpcEndpoints.
class DescribeVpcEndpointsResult {
  /// Information about the endpoints.
  final List<VpcEndpoint> vpcEndpoints;

  /// The token to use when requesting the next set of items. If there are no
  /// additional items to return, the string is empty.
  final String nextToken;

  DescribeVpcEndpointsResult({
    this.vpcEndpoints,
    this.nextToken,
  });
  static DescribeVpcEndpointsResult fromJson(Map<String, dynamic> json) =>
      DescribeVpcEndpointsResult(
        vpcEndpoints: json.containsKey('VpcEndpoints')
            ? (json['VpcEndpoints'] as List)
                .map((e) => VpcEndpoint.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeVpcPeeringConnectionsResult {
  /// Information about the VPC peering connections.
  final List<VpcPeeringConnection> vpcPeeringConnections;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeVpcPeeringConnectionsResult({
    this.vpcPeeringConnections,
    this.nextToken,
  });
  static DescribeVpcPeeringConnectionsResult fromJson(
          Map<String, dynamic> json) =>
      DescribeVpcPeeringConnectionsResult(
        vpcPeeringConnections: json.containsKey('VpcPeeringConnections')
            ? (json['VpcPeeringConnections'] as List)
                .map((e) => VpcPeeringConnection.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class DescribeVpcsResult {
  /// Information about one or more VPCs.
  final List<Vpc> vpcs;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  DescribeVpcsResult({
    this.vpcs,
    this.nextToken,
  });
  static DescribeVpcsResult fromJson(Map<String, dynamic> json) =>
      DescribeVpcsResult(
        vpcs: json.containsKey('Vpcs')
            ? (json['Vpcs'] as List).map((e) => Vpc.fromJson(e)).toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

/// Contains the output of DescribeVpnConnections.
class DescribeVpnConnectionsResult {
  /// Information about one or more VPN connections.
  final List<VpnConnection> vpnConnections;

  DescribeVpnConnectionsResult({
    this.vpnConnections,
  });
  static DescribeVpnConnectionsResult fromJson(Map<String, dynamic> json) =>
      DescribeVpnConnectionsResult(
        vpnConnections: json.containsKey('VpnConnections')
            ? (json['VpnConnections'] as List)
                .map((e) => VpnConnection.fromJson(e))
                .toList()
            : null,
      );
}

/// Contains the output of DescribeVpnGateways.
class DescribeVpnGatewaysResult {
  /// Information about one or more virtual private gateways.
  final List<VpnGateway> vpnGateways;

  DescribeVpnGatewaysResult({
    this.vpnGateways,
  });
  static DescribeVpnGatewaysResult fromJson(Map<String, dynamic> json) =>
      DescribeVpnGatewaysResult(
        vpnGateways: json.containsKey('VpnGateways')
            ? (json['VpnGateways'] as List)
                .map((e) => VpnGateway.fromJson(e))
                .toList()
            : null,
      );
}

class DetachClassicLinkVpcResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool return$;

  DetachClassicLinkVpcResult({
    this.return$,
  });
  static DetachClassicLinkVpcResult fromJson(Map<String, dynamic> json) =>
      DetachClassicLinkVpcResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

/// Describes a DHCP configuration option.
class DhcpConfiguration {
  /// The name of a DHCP option.
  final String key;

  /// One or more values for the DHCP option.
  final List<AttributeValue> values;

  DhcpConfiguration({
    this.key,
    this.values,
  });
  static DhcpConfiguration fromJson(Map<String, dynamic> json) =>
      DhcpConfiguration(
        key: json.containsKey('Key') ? json['Key'] as String : null,
        values: json.containsKey('Values')
            ? (json['Values'] as List)
                .map((e) => AttributeValue.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes a set of DHCP options.
class DhcpOptions {
  /// One or more DHCP options in the set.
  final List<DhcpConfiguration> dhcpConfigurations;

  /// The ID of the set of DHCP options.
  final String dhcpOptionsId;

  /// The ID of the AWS account that owns the DHCP options set.
  final String ownerId;

  /// Any tags assigned to the DHCP options set.
  final List<Tag> tags;

  DhcpOptions({
    this.dhcpConfigurations,
    this.dhcpOptionsId,
    this.ownerId,
    this.tags,
  });
  static DhcpOptions fromJson(Map<String, dynamic> json) => DhcpOptions(
        dhcpConfigurations: json.containsKey('DhcpConfigurations')
            ? (json['DhcpConfigurations'] as List)
                .map((e) => DhcpConfiguration.fromJson(e))
                .toList()
            : null,
        dhcpOptionsId: json.containsKey('DhcpOptionsId')
            ? json['DhcpOptionsId'] as String
            : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes an Active Directory.
class DirectoryServiceAuthentication {
  /// The ID of the Active Directory used for authentication.
  final String directoryId;

  DirectoryServiceAuthentication({
    this.directoryId,
  });
  static DirectoryServiceAuthentication fromJson(Map<String, dynamic> json) =>
      DirectoryServiceAuthentication(
        directoryId: json.containsKey('DirectoryId')
            ? json['DirectoryId'] as String
            : null,
      );
}

/// Describes the Active Directory to be used for client authentication.
class DirectoryServiceAuthenticationRequest {
  /// The ID of the Active Directory to be used for authentication.
  final String directoryId;

  DirectoryServiceAuthenticationRequest({
    this.directoryId,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

class DisableEbsEncryptionByDefaultResult {
  /// The updated status of encryption by default.
  final bool ebsEncryptionByDefault;

  DisableEbsEncryptionByDefaultResult({
    this.ebsEncryptionByDefault,
  });
  static DisableEbsEncryptionByDefaultResult fromJson(
          Map<String, dynamic> json) =>
      DisableEbsEncryptionByDefaultResult(
        ebsEncryptionByDefault: json.containsKey('EbsEncryptionByDefault')
            ? json['EbsEncryptionByDefault'] as bool
            : null,
      );
}

class DisableTransitGatewayRouteTablePropagationResult {
  /// Information about route propagation.
  final TransitGatewayPropagation propagation;

  DisableTransitGatewayRouteTablePropagationResult({
    this.propagation,
  });
  static DisableTransitGatewayRouteTablePropagationResult fromJson(
          Map<String, dynamic> json) =>
      DisableTransitGatewayRouteTablePropagationResult(
        propagation: json.containsKey('Propagation')
            ? TransitGatewayPropagation.fromJson(json['Propagation'])
            : null,
      );
}

class DisableVpcClassicLinkDnsSupportResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool return$;

  DisableVpcClassicLinkDnsSupportResult({
    this.return$,
  });
  static DisableVpcClassicLinkDnsSupportResult fromJson(
          Map<String, dynamic> json) =>
      DisableVpcClassicLinkDnsSupportResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class DisableVpcClassicLinkResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool return$;

  DisableVpcClassicLinkResult({
    this.return$,
  });
  static DisableVpcClassicLinkResult fromJson(Map<String, dynamic> json) =>
      DisableVpcClassicLinkResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class DisassociateClientVpnTargetNetworkResult {
  /// The ID of the target network association.
  final String associationId;

  /// The current state of the target network association.
  final AssociationStatus status;

  DisassociateClientVpnTargetNetworkResult({
    this.associationId,
    this.status,
  });
  static DisassociateClientVpnTargetNetworkResult fromJson(
          Map<String, dynamic> json) =>
      DisassociateClientVpnTargetNetworkResult(
        associationId: json.containsKey('AssociationId')
            ? json['AssociationId'] as String
            : null,
        status: json.containsKey('Status')
            ? AssociationStatus.fromJson(json['Status'])
            : null,
      );
}

class DisassociateIamInstanceProfileResult {
  /// Information about the IAM instance profile association.
  final IamInstanceProfileAssociation iamInstanceProfileAssociation;

  DisassociateIamInstanceProfileResult({
    this.iamInstanceProfileAssociation,
  });
  static DisassociateIamInstanceProfileResult fromJson(
          Map<String, dynamic> json) =>
      DisassociateIamInstanceProfileResult(
        iamInstanceProfileAssociation:
            json.containsKey('IamInstanceProfileAssociation')
                ? IamInstanceProfileAssociation.fromJson(
                    json['IamInstanceProfileAssociation'])
                : null,
      );
}

class DisassociateSubnetCidrBlockResult {
  /// Information about the IPv6 CIDR block association.
  final SubnetIpv6CidrBlockAssociation ipv6CidrBlockAssociation;

  /// The ID of the subnet.
  final String subnetId;

  DisassociateSubnetCidrBlockResult({
    this.ipv6CidrBlockAssociation,
    this.subnetId,
  });
  static DisassociateSubnetCidrBlockResult fromJson(
          Map<String, dynamic> json) =>
      DisassociateSubnetCidrBlockResult(
        ipv6CidrBlockAssociation: json.containsKey('Ipv6CidrBlockAssociation')
            ? SubnetIpv6CidrBlockAssociation.fromJson(
                json['Ipv6CidrBlockAssociation'])
            : null,
        subnetId:
            json.containsKey('SubnetId') ? json['SubnetId'] as String : null,
      );
}

class DisassociateTransitGatewayRouteTableResult {
  /// Information about the association.
  final TransitGatewayAssociation association;

  DisassociateTransitGatewayRouteTableResult({
    this.association,
  });
  static DisassociateTransitGatewayRouteTableResult fromJson(
          Map<String, dynamic> json) =>
      DisassociateTransitGatewayRouteTableResult(
        association: json.containsKey('Association')
            ? TransitGatewayAssociation.fromJson(json['Association'])
            : null,
      );
}

class DisassociateVpcCidrBlockResult {
  /// Information about the IPv6 CIDR block association.
  final VpcIpv6CidrBlockAssociation ipv6CidrBlockAssociation;

  /// Information about the IPv4 CIDR block association.
  final VpcCidrBlockAssociation cidrBlockAssociation;

  /// The ID of the VPC.
  final String vpcId;

  DisassociateVpcCidrBlockResult({
    this.ipv6CidrBlockAssociation,
    this.cidrBlockAssociation,
    this.vpcId,
  });
  static DisassociateVpcCidrBlockResult fromJson(Map<String, dynamic> json) =>
      DisassociateVpcCidrBlockResult(
        ipv6CidrBlockAssociation: json.containsKey('Ipv6CidrBlockAssociation')
            ? VpcIpv6CidrBlockAssociation.fromJson(
                json['Ipv6CidrBlockAssociation'])
            : null,
        cidrBlockAssociation: json.containsKey('CidrBlockAssociation')
            ? VpcCidrBlockAssociation.fromJson(json['CidrBlockAssociation'])
            : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
      );
}

/// Describes a disk image.
class DiskImage {
  /// A description of the disk image.
  final String description;

  /// Information about the disk image.
  final DiskImageDetail image;

  /// Information about the volume.
  final VolumeDetail volume;

  DiskImage({
    this.description,
    this.image,
    this.volume,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a disk image.
class DiskImageDescription {
  /// The checksum computed for the disk image.
  final String checksum;

  /// The disk image format.
  final String format;

  /// A presigned URL for the import manifest stored in Amazon S3. For
  /// information about creating a presigned URL for an Amazon S3 object, read
  /// the "Query String Request Authentication Alternative" section of the
  /// [Authenticating REST Requests](https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html)
  /// topic in the _Amazon Simple Storage Service Developer Guide_.
  ///
  /// For information about the import manifest referenced by this API action,
  /// see
  /// [VM Import Manifest](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html).
  final String importManifestUrl;

  /// The size of the disk image, in GiB.
  final BigInt size;

  DiskImageDescription({
    this.checksum,
    this.format,
    this.importManifestUrl,
    this.size,
  });
  static DiskImageDescription fromJson(Map<String, dynamic> json) =>
      DiskImageDescription(
        checksum:
            json.containsKey('Checksum') ? json['Checksum'] as String : null,
        format: json.containsKey('Format') ? json['Format'] as String : null,
        importManifestUrl: json.containsKey('ImportManifestUrl')
            ? json['ImportManifestUrl'] as String
            : null,
        size: json.containsKey('Size') ? BigInt.from(json['Size']) : null,
      );
}

/// Describes a disk image.
class DiskImageDetail {
  /// The size of the disk image, in GiB.
  final BigInt bytes;

  /// The disk image format.
  final String format;

  /// A presigned URL for the import manifest stored in Amazon S3 and presented
  /// here as an Amazon S3 presigned URL. For information about creating a
  /// presigned URL for an Amazon S3 object, read the "Query String Request
  /// Authentication Alternative" section of the
  /// [Authenticating REST Requests](https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html)
  /// topic in the _Amazon Simple Storage Service Developer Guide_.
  ///
  /// For information about the import manifest referenced by this API action,
  /// see
  /// [VM Import Manifest](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html).
  final String importManifestUrl;

  DiskImageDetail({
    @required this.bytes,
    @required this.format,
    @required this.importManifestUrl,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a disk image volume.
class DiskImageVolumeDescription {
  /// The volume identifier.
  final String id;

  /// The size of the volume, in GiB.
  final BigInt size;

  DiskImageVolumeDescription({
    this.id,
    this.size,
  });
  static DiskImageVolumeDescription fromJson(Map<String, dynamic> json) =>
      DiskImageVolumeDescription(
        id: json.containsKey('Id') ? json['Id'] as String : null,
        size: json.containsKey('Size') ? BigInt.from(json['Size']) : null,
      );
}

/// Describes a DNS entry.
class DnsEntry {
  /// The DNS name.
  final String dnsName;

  /// The ID of the private hosted zone.
  final String hostedZoneId;

  DnsEntry({
    this.dnsName,
    this.hostedZoneId,
  });
  static DnsEntry fromJson(Map<String, dynamic> json) => DnsEntry(
        dnsName: json.containsKey('DnsName') ? json['DnsName'] as String : null,
        hostedZoneId: json.containsKey('HostedZoneId')
            ? json['HostedZoneId'] as String
            : null,
      );
}

/// Information about the DNS server to be used.
class DnsServersOptionsModifyStructure {
  /// The IPv4 address range, in CIDR notation, of the DNS servers to be used.
  /// You can specify up to two DNS servers. Ensure that the DNS servers can be
  /// reached by the clients. The specified values overwrite the existing
  /// values.
  final List<String> customDnsServers;

  /// Indicates whether DNS servers should be used. Specify `False` to delete
  /// the existing DNS servers.
  final bool enabled;

  DnsServersOptionsModifyStructure({
    this.customDnsServers,
    this.enabled,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a block device for an EBS volume.
class EbsBlockDevice {
  /// Indicates whether the EBS volume is deleted on instance termination.
  final bool deleteOnTermination;

  /// The number of I/O operations per second (IOPS) that the volume supports.
  /// For `io1` volumes, this represents the number of IOPS that are provisioned
  /// for the volume. For `gp2` volumes, this represents the baseline
  /// performance of the volume and the rate at which the volume accumulates I/O
  /// credits for bursting. For more information, see
  /// [Amazon EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// Constraints: Range is 100-16,000 IOPS for `gp2` volumes and 100 to
  /// 64,000IOPS for `io1` volumes in most Regions. Maximum `io1` IOPS of 64,000
  /// is guaranteed only on
  /// [Nitro-based instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances).
  /// Other instance families guarantee performance up to 32,000 IOPS. For more
  /// information, see
  /// [Amazon EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// Condition: This parameter is required for requests to create `io1`
  /// volumes; it is not used in requests to create `gp2`, `st1`, `sc1`, or
  /// `standard` volumes.
  final int iops;

  /// The ID of the snapshot.
  final String snapshotId;

  /// The size of the volume, in GiB.
  ///
  /// Default: If you're creating the volume from a snapshot and don't specify a
  /// volume size, the default is the snapshot size.
  ///
  /// Constraints: 1-16384 for General Purpose SSD (`gp2`), 4-16384 for
  /// Provisioned IOPS SSD (`io1`), 500-16384 for Throughput Optimized HDD
  /// (`st1`), 500-16384 for Cold HDD (`sc1`), and 1-1024 for Magnetic
  /// (`standard`) volumes. If you specify a snapshot, the volume size must be
  /// equal to or larger than the snapshot size.
  final int volumeSize;

  /// The volume type. If you set the type to `io1`, you must also specify the
  /// IOPS that the volume supports.
  ///
  /// Default: `gp2`
  final String volumeType;

  /// Indicates whether the encryption state of an EBS volume is changed while
  /// being restored from a backing snapshot. The effect of setting the
  /// encryption state to `true` depends on the volume origin (new or from a
  /// snapshot), starting encryption state, ownership, and whether encryption by
  /// default is enabled. For more information, see
  /// [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// In no case can you remove encryption from an encrypted volume.
  ///
  /// Encrypted volumes can only be attached to instances that support Amazon
  /// EBS encryption. For more information, see
  /// [Supported Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances).
  final bool encrypted;

  /// Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer
  /// managed CMK under which the EBS volume is encrypted.
  ///
  /// This parameter is only supported on `BlockDeviceMapping` objects called by
  /// [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html),
  /// [RequestSpotFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html),
  /// and
  /// [RequestSpotInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html).
  final String kmsKeyId;

  EbsBlockDevice({
    this.deleteOnTermination,
    this.iops,
    this.snapshotId,
    this.volumeSize,
    this.volumeType,
    this.encrypted,
    this.kmsKeyId,
  });
  static EbsBlockDevice fromJson(Map<String, dynamic> json) => EbsBlockDevice(
        deleteOnTermination: json.containsKey('DeleteOnTermination')
            ? json['DeleteOnTermination'] as bool
            : null,
        iops: json.containsKey('Iops') ? json['Iops'] as int : null,
        snapshotId: json.containsKey('SnapshotId')
            ? json['SnapshotId'] as String
            : null,
        volumeSize:
            json.containsKey('VolumeSize') ? json['VolumeSize'] as int : null,
        volumeType: json.containsKey('VolumeType')
            ? json['VolumeType'] as String
            : null,
        encrypted:
            json.containsKey('Encrypted') ? json['Encrypted'] as bool : null,
        kmsKeyId:
            json.containsKey('KmsKeyId') ? json['KmsKeyId'] as String : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a parameter used to set up an EBS volume in a block device
/// mapping.
class EbsInstanceBlockDevice {
  /// The time stamp when the attachment initiated.
  final DateTime attachTime;

  /// Indicates whether the volume is deleted on instance termination.
  final bool deleteOnTermination;

  /// The attachment state.
  final String status;

  /// The ID of the EBS volume.
  final String volumeId;

  EbsInstanceBlockDevice({
    this.attachTime,
    this.deleteOnTermination,
    this.status,
    this.volumeId,
  });
  static EbsInstanceBlockDevice fromJson(Map<String, dynamic> json) =>
      EbsInstanceBlockDevice(
        attachTime: json.containsKey('AttachTime')
            ? DateTime.parse(json['AttachTime'])
            : null,
        deleteOnTermination: json.containsKey('DeleteOnTermination')
            ? json['DeleteOnTermination'] as bool
            : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
        volumeId:
            json.containsKey('VolumeId') ? json['VolumeId'] as String : null,
      );
}

/// Describes information used to set up an EBS volume specified in a block
/// device mapping.
class EbsInstanceBlockDeviceSpecification {
  /// Indicates whether the volume is deleted on instance termination.
  final bool deleteOnTermination;

  /// The ID of the EBS volume.
  final String volumeId;

  EbsInstanceBlockDeviceSpecification({
    this.deleteOnTermination,
    this.volumeId,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes an egress-only internet gateway.
class EgressOnlyInternetGateway {
  /// Information about the attachment of the egress-only internet gateway.
  final List<InternetGatewayAttachment> attachments;

  /// The ID of the egress-only internet gateway.
  final String egressOnlyInternetGatewayId;

  EgressOnlyInternetGateway({
    this.attachments,
    this.egressOnlyInternetGatewayId,
  });
  static EgressOnlyInternetGateway fromJson(Map<String, dynamic> json) =>
      EgressOnlyInternetGateway(
        attachments: json.containsKey('Attachments')
            ? (json['Attachments'] as List)
                .map((e) => InternetGatewayAttachment.fromJson(e))
                .toList()
            : null,
        egressOnlyInternetGatewayId:
            json.containsKey('EgressOnlyInternetGatewayId')
                ? json['EgressOnlyInternetGatewayId'] as String
                : null,
      );
}

/// Describes the association between an instance and an Elastic Graphics
/// accelerator.
class ElasticGpuAssociation {
  /// The ID of the Elastic Graphics accelerator.
  final String elasticGpuId;

  /// The ID of the association.
  final String elasticGpuAssociationId;

  /// The state of the association between the instance and the Elastic Graphics
  /// accelerator.
  final String elasticGpuAssociationState;

  /// The time the Elastic Graphics accelerator was associated with the
  /// instance.
  final String elasticGpuAssociationTime;

  ElasticGpuAssociation({
    this.elasticGpuId,
    this.elasticGpuAssociationId,
    this.elasticGpuAssociationState,
    this.elasticGpuAssociationTime,
  });
  static ElasticGpuAssociation fromJson(Map<String, dynamic> json) =>
      ElasticGpuAssociation(
        elasticGpuId: json.containsKey('ElasticGpuId')
            ? json['ElasticGpuId'] as String
            : null,
        elasticGpuAssociationId: json.containsKey('ElasticGpuAssociationId')
            ? json['ElasticGpuAssociationId'] as String
            : null,
        elasticGpuAssociationState:
            json.containsKey('ElasticGpuAssociationState')
                ? json['ElasticGpuAssociationState'] as String
                : null,
        elasticGpuAssociationTime: json.containsKey('ElasticGpuAssociationTime')
            ? json['ElasticGpuAssociationTime'] as String
            : null,
      );
}

/// Describes the status of an Elastic Graphics accelerator.
class ElasticGpuHealth {
  /// The health status.
  final String status;

  ElasticGpuHealth({
    this.status,
  });
  static ElasticGpuHealth fromJson(Map<String, dynamic> json) =>
      ElasticGpuHealth(
        status: json.containsKey('Status') ? json['Status'] as String : null,
      );
}

/// A specification for an Elastic Graphics accelerator.
class ElasticGpuSpecification {
  /// The type of Elastic Graphics accelerator.
  final String type;

  ElasticGpuSpecification({
    @required this.type,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes an elastic GPU.
class ElasticGpuSpecificationResponse {
  /// The elastic GPU type.
  final String type;

  ElasticGpuSpecificationResponse({
    this.type,
  });
  static ElasticGpuSpecificationResponse fromJson(Map<String, dynamic> json) =>
      ElasticGpuSpecificationResponse(
        type: json.containsKey('Type') ? json['Type'] as String : null,
      );
}

/// Describes an Elastic Graphics accelerator.
class ElasticGpus {
  /// The ID of the Elastic Graphics accelerator.
  final String elasticGpuId;

  /// The Availability Zone in the which the Elastic Graphics accelerator
  /// resides.
  final String availabilityZone;

  /// The type of Elastic Graphics accelerator.
  final String elasticGpuType;

  /// The status of the Elastic Graphics accelerator.
  final ElasticGpuHealth elasticGpuHealth;

  /// The state of the Elastic Graphics accelerator.
  final String elasticGpuState;

  /// The ID of the instance to which the Elastic Graphics accelerator is
  /// attached.
  final String instanceId;

  ElasticGpus({
    this.elasticGpuId,
    this.availabilityZone,
    this.elasticGpuType,
    this.elasticGpuHealth,
    this.elasticGpuState,
    this.instanceId,
  });
  static ElasticGpus fromJson(Map<String, dynamic> json) => ElasticGpus(
        elasticGpuId: json.containsKey('ElasticGpuId')
            ? json['ElasticGpuId'] as String
            : null,
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        elasticGpuType: json.containsKey('ElasticGpuType')
            ? json['ElasticGpuType'] as String
            : null,
        elasticGpuHealth: json.containsKey('ElasticGpuHealth')
            ? ElasticGpuHealth.fromJson(json['ElasticGpuHealth'])
            : null,
        elasticGpuState: json.containsKey('ElasticGpuState')
            ? json['ElasticGpuState'] as String
            : null,
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
      );
}

///  Describes an elastic inference accelerator.
class ElasticInferenceAccelerator {
  ///  The type of elastic inference accelerator. The possible values are
  /// `eia1.small`, `eia1.medium`, and `eia1.large`.
  final String type;

  ElasticInferenceAccelerator({
    @required this.type,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

///  Describes the association between an instance and an elastic inference
/// accelerator.
class ElasticInferenceAcceleratorAssociation {
  ///  The Amazon Resource Name (ARN) of the elastic inference accelerator.
  final String elasticInferenceAcceleratorArn;

  ///  The ID of the association.
  final String elasticInferenceAcceleratorAssociationId;

  ///  The state of the elastic inference accelerator.
  final String elasticInferenceAcceleratorAssociationState;

  ///  The time at which the elastic inference accelerator is associated with an
  /// instance.
  final DateTime elasticInferenceAcceleratorAssociationTime;

  ElasticInferenceAcceleratorAssociation({
    this.elasticInferenceAcceleratorArn,
    this.elasticInferenceAcceleratorAssociationId,
    this.elasticInferenceAcceleratorAssociationState,
    this.elasticInferenceAcceleratorAssociationTime,
  });
  static ElasticInferenceAcceleratorAssociation fromJson(
          Map<String, dynamic> json) =>
      ElasticInferenceAcceleratorAssociation(
        elasticInferenceAcceleratorArn:
            json.containsKey('ElasticInferenceAcceleratorArn')
                ? json['ElasticInferenceAcceleratorArn'] as String
                : null,
        elasticInferenceAcceleratorAssociationId:
            json.containsKey('ElasticInferenceAcceleratorAssociationId')
                ? json['ElasticInferenceAcceleratorAssociationId'] as String
                : null,
        elasticInferenceAcceleratorAssociationState:
            json.containsKey('ElasticInferenceAcceleratorAssociationState')
                ? json['ElasticInferenceAcceleratorAssociationState'] as String
                : null,
        elasticInferenceAcceleratorAssociationTime: json
                .containsKey('ElasticInferenceAcceleratorAssociationTime')
            ? DateTime.parse(json['ElasticInferenceAcceleratorAssociationTime'])
            : null,
      );
}

class EnableEbsEncryptionByDefaultResult {
  /// The updated status of encryption by default.
  final bool ebsEncryptionByDefault;

  EnableEbsEncryptionByDefaultResult({
    this.ebsEncryptionByDefault,
  });
  static EnableEbsEncryptionByDefaultResult fromJson(
          Map<String, dynamic> json) =>
      EnableEbsEncryptionByDefaultResult(
        ebsEncryptionByDefault: json.containsKey('EbsEncryptionByDefault')
            ? json['EbsEncryptionByDefault'] as bool
            : null,
      );
}

class EnableTransitGatewayRouteTablePropagationResult {
  /// Information about route propagation.
  final TransitGatewayPropagation propagation;

  EnableTransitGatewayRouteTablePropagationResult({
    this.propagation,
  });
  static EnableTransitGatewayRouteTablePropagationResult fromJson(
          Map<String, dynamic> json) =>
      EnableTransitGatewayRouteTablePropagationResult(
        propagation: json.containsKey('Propagation')
            ? TransitGatewayPropagation.fromJson(json['Propagation'])
            : null,
      );
}

class EnableVpcClassicLinkDnsSupportResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool return$;

  EnableVpcClassicLinkDnsSupportResult({
    this.return$,
  });
  static EnableVpcClassicLinkDnsSupportResult fromJson(
          Map<String, dynamic> json) =>
      EnableVpcClassicLinkDnsSupportResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class EnableVpcClassicLinkResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool return$;

  EnableVpcClassicLinkResult({
    this.return$,
  });
  static EnableVpcClassicLinkResult fromJson(Map<String, dynamic> json) =>
      EnableVpcClassicLinkResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

/// Describes an EC2 Fleet or Spot Fleet event.
class EventInformation {
  /// The description of the event.
  final String eventDescription;

  /// The event.
  ///
  /// The following are the `error` events:
  ///
  /// *    `iamFleetRoleInvalid` - The EC2 Fleet or Spot Fleet did not have the
  /// required permissions either to launch or terminate an instance.
  ///
  /// *    `spotFleetRequestConfigurationInvalid` - The configuration is not
  /// valid. For more information, see the description of the event.
  ///
  /// *    `spotInstanceCountLimitExceeded` - You've reached the limit on the
  /// number of Spot Instances that you can launch.
  ///
  ///
  /// The following are the `fleetRequestChange` events:
  ///
  /// *    `active` - The EC2 Fleet or Spot Fleet request has been validated and
  /// Amazon EC2 is attempting to maintain the target number of running Spot
  /// Instances.
  ///
  /// *    `cancelled` - The EC2 Fleet or Spot Fleet request is canceled and has
  /// no running Spot Instances. The EC2 Fleet or Spot Fleet will be deleted two
  /// days after its instances were terminated.
  ///
  /// *    `cancelled_running` - The EC2 Fleet or Spot Fleet request is canceled
  /// and does not launch additional Spot Instances. Existing Spot Instances
  /// continue to run until they are interrupted or terminated.
  ///
  /// *    `cancelled_terminating` - The EC2 Fleet or Spot Fleet request is
  /// canceled and its Spot Instances are terminating.
  ///
  /// *    `expired` - The EC2 Fleet or Spot Fleet request has expired. A
  /// subsequent event indicates that the instances were terminated, if the
  /// request was created with `TerminateInstancesWithExpiration` set.
  ///
  /// *    `modify_in_progress` - A request to modify the EC2 Fleet or Spot
  /// Fleet request was accepted and is in progress.
  ///
  /// *    `modify_successful` - The EC2 Fleet or Spot Fleet request was
  /// modified.
  ///
  /// *    `price_update` - The price for a launch configuration was adjusted
  /// because it was too high. This change is permanent.
  ///
  /// *    `submitted` - The EC2 Fleet or Spot Fleet request is being evaluated
  /// and Amazon EC2 is preparing to launch the target number of Spot Instances.
  ///
  ///
  /// The following are the `instanceChange` events:
  ///
  /// *    `launched` - A request was fulfilled and a new instance was launched.
  ///
  /// *    `terminated` - An instance was terminated by the user.
  ///
  ///
  /// The following are the `Information` events:
  ///
  /// *    `launchSpecTemporarilyBlacklisted` - The configuration is not valid
  /// and several attempts to launch instances have failed. For more
  /// information, see the description of the event.
  ///
  /// *    `launchSpecUnusable` - The price in a launch specification is not
  /// valid because it is below the Spot price or the Spot price is above the
  /// On-Demand price.
  ///
  /// *    `fleetProgressHalted` - The price in every launch specification is
  /// not valid. A launch specification might become valid if the Spot price
  /// changes.
  final String eventSubType;

  /// The ID of the instance. This information is available only for
  /// `instanceChange` events.
  final String instanceId;

  EventInformation({
    this.eventDescription,
    this.eventSubType,
    this.instanceId,
  });
  static EventInformation fromJson(Map<String, dynamic> json) =>
      EventInformation(
        eventDescription: json.containsKey('EventDescription')
            ? json['EventDescription'] as String
            : null,
        eventSubType: json.containsKey('EventSubType')
            ? json['EventSubType'] as String
            : null,
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
      );
}

class ExportClientVpnClientCertificateRevocationListResult {
  /// Information about the client certificate revocation list.
  final String certificateRevocationList;

  /// The current state of the client certificate revocation list.
  final ClientCertificateRevocationListStatus status;

  ExportClientVpnClientCertificateRevocationListResult({
    this.certificateRevocationList,
    this.status,
  });
  static ExportClientVpnClientCertificateRevocationListResult fromJson(
          Map<String, dynamic> json) =>
      ExportClientVpnClientCertificateRevocationListResult(
        certificateRevocationList: json.containsKey('CertificateRevocationList')
            ? json['CertificateRevocationList'] as String
            : null,
        status: json.containsKey('Status')
            ? ClientCertificateRevocationListStatus.fromJson(json['Status'])
            : null,
      );
}

class ExportClientVpnClientConfigurationResult {
  /// The contents of the Client VPN endpoint configuration file.
  final String clientConfiguration;

  ExportClientVpnClientConfigurationResult({
    this.clientConfiguration,
  });
  static ExportClientVpnClientConfigurationResult fromJson(
          Map<String, dynamic> json) =>
      ExportClientVpnClientConfigurationResult(
        clientConfiguration: json.containsKey('ClientConfiguration')
            ? json['ClientConfiguration'] as String
            : null,
      );
}

class ExportImageResult {
  /// A description of the image being exported.
  final String description;

  /// The disk image format for the exported image.
  final String diskImageFormat;

  /// The ID of the export image task.
  final String exportImageTaskId;

  /// The ID of the image.
  final String imageId;

  /// The name of the role that grants VM Import/Export permission to export
  /// images to your S3 bucket.
  final String roleName;

  /// The percent complete of the export image task.
  final String progress;

  /// Information about the destination S3 bucket.
  final ExportTaskS3Location s3ExportLocation;

  /// The status of the export image task. The possible values are `active`,
  /// `completed`, `deleting`, and `deleted`.
  final String status;

  /// The status message for the export image task.
  final String statusMessage;

  ExportImageResult({
    this.description,
    this.diskImageFormat,
    this.exportImageTaskId,
    this.imageId,
    this.roleName,
    this.progress,
    this.s3ExportLocation,
    this.status,
    this.statusMessage,
  });
  static ExportImageResult fromJson(Map<String, dynamic> json) =>
      ExportImageResult(
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        diskImageFormat: json.containsKey('DiskImageFormat')
            ? json['DiskImageFormat'] as String
            : null,
        exportImageTaskId: json.containsKey('ExportImageTaskId')
            ? json['ExportImageTaskId'] as String
            : null,
        imageId: json.containsKey('ImageId') ? json['ImageId'] as String : null,
        roleName:
            json.containsKey('RoleName') ? json['RoleName'] as String : null,
        progress:
            json.containsKey('Progress') ? json['Progress'] as String : null,
        s3ExportLocation: json.containsKey('S3ExportLocation')
            ? ExportTaskS3Location.fromJson(json['S3ExportLocation'])
            : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
        statusMessage: json.containsKey('StatusMessage')
            ? json['StatusMessage'] as String
            : null,
      );
}

/// Describes an export image task.
class ExportImageTask {
  /// A description of the image being exported.
  final String description;

  /// The ID of the export image task.
  final String exportImageTaskId;

  /// The ID of the image.
  final String imageId;

  /// The percent complete of the export image task.
  final String progress;

  /// Information about the destination S3 bucket.
  final ExportTaskS3Location s3ExportLocation;

  /// The status of the export image task. The possible values are `active`,
  /// `completed`, `deleting`, and `deleted`.
  final String status;

  /// The status message for the export image task.
  final String statusMessage;

  ExportImageTask({
    this.description,
    this.exportImageTaskId,
    this.imageId,
    this.progress,
    this.s3ExportLocation,
    this.status,
    this.statusMessage,
  });
  static ExportImageTask fromJson(Map<String, dynamic> json) => ExportImageTask(
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        exportImageTaskId: json.containsKey('ExportImageTaskId')
            ? json['ExportImageTaskId'] as String
            : null,
        imageId: json.containsKey('ImageId') ? json['ImageId'] as String : null,
        progress:
            json.containsKey('Progress') ? json['Progress'] as String : null,
        s3ExportLocation: json.containsKey('S3ExportLocation')
            ? ExportTaskS3Location.fromJson(json['S3ExportLocation'])
            : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
        statusMessage: json.containsKey('StatusMessage')
            ? json['StatusMessage'] as String
            : null,
      );
}

/// Describes an instance export task.
class ExportTask {
  /// A description of the resource being exported.
  final String description;

  /// The ID of the export task.
  final String exportTaskId;

  /// Information about the export task.
  final ExportToS3Task exportToS3Task;

  /// Information about the instance to export.
  final InstanceExportDetails instanceExportDetails;

  /// The state of the export task.
  final String state;

  /// The status message related to the export task.
  final String statusMessage;

  ExportTask({
    this.description,
    this.exportTaskId,
    this.exportToS3Task,
    this.instanceExportDetails,
    this.state,
    this.statusMessage,
  });
  static ExportTask fromJson(Map<String, dynamic> json) => ExportTask(
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        exportTaskId: json.containsKey('ExportTaskId')
            ? json['ExportTaskId'] as String
            : null,
        exportToS3Task: json.containsKey('ExportToS3Task')
            ? ExportToS3Task.fromJson(json['ExportToS3Task'])
            : null,
        instanceExportDetails: json.containsKey('InstanceExportDetails')
            ? InstanceExportDetails.fromJson(json['InstanceExportDetails'])
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        statusMessage: json.containsKey('StatusMessage')
            ? json['StatusMessage'] as String
            : null,
      );
}

/// Describes the destination for an export image task.
class ExportTaskS3Location {
  /// The destination S3 bucket.
  final String s3Bucket;

  /// The prefix (logical hierarchy) in the bucket.
  final String s3Prefix;

  ExportTaskS3Location({
    this.s3Bucket,
    this.s3Prefix,
  });
  static ExportTaskS3Location fromJson(Map<String, dynamic> json) =>
      ExportTaskS3Location(
        s3Bucket:
            json.containsKey('S3Bucket') ? json['S3Bucket'] as String : null,
        s3Prefix:
            json.containsKey('S3Prefix') ? json['S3Prefix'] as String : null,
      );
}

/// Describes the destination for an export image task.
class ExportTaskS3LocationRequest {
  /// The destination S3 bucket.
  final String s3Bucket;

  /// The prefix (logical hierarchy) in the bucket.
  final String s3Prefix;

  ExportTaskS3LocationRequest({
    @required this.s3Bucket,
    this.s3Prefix,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the format and location for an instance export task.
class ExportToS3Task {
  /// The container format used to combine disk images with metadata (such as
  /// OVF). If absent, only the disk image is exported.
  final String containerFormat;

  /// The format for the exported image.
  final String diskImageFormat;

  /// The S3 bucket for the destination image. The destination bucket must exist
  /// and grant WRITE and READ_ACP permissions to the AWS account
  /// `vm-import-export@amazon.com`.
  final String s3Bucket;

  /// The encryption key for your S3 bucket.
  final String s3Key;

  ExportToS3Task({
    this.containerFormat,
    this.diskImageFormat,
    this.s3Bucket,
    this.s3Key,
  });
  static ExportToS3Task fromJson(Map<String, dynamic> json) => ExportToS3Task(
        containerFormat: json.containsKey('ContainerFormat')
            ? json['ContainerFormat'] as String
            : null,
        diskImageFormat: json.containsKey('DiskImageFormat')
            ? json['DiskImageFormat'] as String
            : null,
        s3Bucket:
            json.containsKey('S3Bucket') ? json['S3Bucket'] as String : null,
        s3Key: json.containsKey('S3Key') ? json['S3Key'] as String : null,
      );
}

/// Describes an instance export task.
class ExportToS3TaskSpecification {
  /// The container format used to combine disk images with metadata (such as
  /// OVF). If absent, only the disk image is exported.
  final String containerFormat;

  /// The format for the exported image.
  final String diskImageFormat;

  /// The S3 bucket for the destination image. The destination bucket must exist
  /// and grant WRITE and READ_ACP permissions to the AWS account
  /// `vm-import-export@amazon.com`.
  final String s3Bucket;

  /// The image is written to a single object in the S3 bucket at the S3 key
  /// s3prefix + exportTaskId + '.' + diskImageFormat.
  final String s3Prefix;

  ExportToS3TaskSpecification({
    this.containerFormat,
    this.diskImageFormat,
    this.s3Bucket,
    this.s3Prefix,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

class ExportTransitGatewayRoutesResult {
  /// The URL of the exported file in Amazon S3. For example,
  /// s3://_bucket_name_/VPCTransitGateway/TransitGatewayRouteTables/_file_name_.
  final String s3Location;

  ExportTransitGatewayRoutesResult({
    this.s3Location,
  });
  static ExportTransitGatewayRoutesResult fromJson(Map<String, dynamic> json) =>
      ExportTransitGatewayRoutesResult(
        s3Location: json.containsKey('S3Location')
            ? json['S3Location'] as String
            : null,
      );
}

/// A filter name and value pair that is used to return a more specific list of
/// results from a describe operation. Filters can be used to match a set of
/// resources by specific criteria, such as tags, attributes, or IDs. The
/// filters supported by a describe operation are documented with the describe
/// operation. For example:
///
/// *    DescribeAvailabilityZones
///
/// *    DescribeImages
///
/// *    DescribeInstances
///
/// *    DescribeKeyPairs
///
/// *    DescribeSecurityGroups
///
/// *    DescribeSnapshots
///
/// *    DescribeSubnets
///
/// *    DescribeTags
///
/// *    DescribeVolumes
///
/// *    DescribeVpcs
class Filter {
  /// The name of the filter. Filter names are case-sensitive.
  final String name;

  /// The filter values. Filter values are case-sensitive.
  final List<String> values;

  Filter({
    this.name,
    this.values,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes an EC2 Fleet.
class FleetData {
  /// The progress of the EC2 Fleet. If there is an error, the status is
  /// `error`. After all requests are placed, the status is
  /// `pending_fulfillment`. If the size of the EC2 Fleet is equal to or greater
  /// than its target capacity, the status is `fulfilled`. If the size of the
  /// EC2 Fleet is decreased, the status is `pending_termination` while
  /// instances are terminating.
  final String activityStatus;

  /// The creation date and time of the EC2 Fleet.
  final DateTime createTime;

  /// The ID of the EC2 Fleet.
  final String fleetId;

  /// The state of the EC2 Fleet.
  final String fleetState;

  /// Unique, case-sensitive identifier you provide to ensure the idempotency of
  /// the request. For more information, see
  /// [Ensuring Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  ///
  /// Constraints: Maximum 64 ASCII characters
  final String clientToken;

  /// Indicates whether running instances should be terminated if the target
  /// capacity of the EC2 Fleet is decreased below the current size of the EC2
  /// Fleet.
  final String excessCapacityTerminationPolicy;

  /// The number of units fulfilled by this request compared to the set target
  /// capacity.
  final double fulfilledCapacity;

  /// The number of units fulfilled by this request compared to the set target
  /// On-Demand capacity.
  final double fulfilledOnDemandCapacity;

  /// The launch template and overrides.
  final List<FleetLaunchTemplateConfig> launchTemplateConfigs;

  /// The number of units to request. You can choose to set the target capacity
  /// in terms of instances or a performance characteristic that is important to
  /// your application workload, such as vCPUs, memory, or I/O. If the request
  /// type is `maintain`, you can specify a target capacity of 0 and add
  /// capacity later.
  final TargetCapacitySpecification targetCapacitySpecification;

  /// Indicates whether running instances should be terminated when the EC2
  /// Fleet expires.
  final bool terminateInstancesWithExpiration;

  /// The type of request. Indicates whether the EC2 Fleet only `requests` the
  /// target capacity, or also attempts to `maintain` it. If you request a
  /// certain target capacity, EC2 Fleet only places the required requests; it
  /// does not attempt to replenish instances if capacity is diminished, and
  /// does not submit requests in alternative capacity pools if capacity is
  /// unavailable. To maintain a certain target capacity, EC2 Fleet places the
  /// required requests to meet this target capacity. It also automatically
  /// replenishes any interrupted Spot Instances. Default: `maintain`.
  final String type;

  /// The start date and time of the request, in UTC format (for example,
  /// _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z). The default is to start fulfilling the
  /// request immediately.
  final DateTime validFrom;

  /// The end date and time of the request, in UTC format (for example,
  /// _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z). At this point, no new instance requests
  /// are placed or able to fulfill the request. The default end date is 7 days
  /// from the current date.
  final DateTime validUntil;

  /// Indicates whether EC2 Fleet should replace unhealthy instances.
  final bool replaceUnhealthyInstances;

  /// The configuration of Spot Instances in an EC2 Fleet.
  final SpotOptions spotOptions;

  /// The allocation strategy of On-Demand Instances in an EC2 Fleet.
  final OnDemandOptions onDemandOptions;

  /// The tags for an EC2 Fleet resource.
  final List<Tag> tags;

  /// Information about the instances that could not be launched by the fleet.
  /// Valid only when **Type** is set to `instant`.
  final List<DescribeFleetError> errors;

  /// Information about the instances that were launched by the fleet. Valid
  /// only when **Type** is set to `instant`.
  final List<DescribeFleetsInstances> instances;

  FleetData({
    this.activityStatus,
    this.createTime,
    this.fleetId,
    this.fleetState,
    this.clientToken,
    this.excessCapacityTerminationPolicy,
    this.fulfilledCapacity,
    this.fulfilledOnDemandCapacity,
    this.launchTemplateConfigs,
    this.targetCapacitySpecification,
    this.terminateInstancesWithExpiration,
    this.type,
    this.validFrom,
    this.validUntil,
    this.replaceUnhealthyInstances,
    this.spotOptions,
    this.onDemandOptions,
    this.tags,
    this.errors,
    this.instances,
  });
  static FleetData fromJson(Map<String, dynamic> json) => FleetData(
        activityStatus: json.containsKey('ActivityStatus')
            ? json['ActivityStatus'] as String
            : null,
        createTime: json.containsKey('CreateTime')
            ? DateTime.parse(json['CreateTime'])
            : null,
        fleetId: json.containsKey('FleetId') ? json['FleetId'] as String : null,
        fleetState: json.containsKey('FleetState')
            ? json['FleetState'] as String
            : null,
        clientToken: json.containsKey('ClientToken')
            ? json['ClientToken'] as String
            : null,
        excessCapacityTerminationPolicy:
            json.containsKey('ExcessCapacityTerminationPolicy')
                ? json['ExcessCapacityTerminationPolicy'] as String
                : null,
        fulfilledCapacity: json.containsKey('FulfilledCapacity')
            ? json['FulfilledCapacity'] as double
            : null,
        fulfilledOnDemandCapacity: json.containsKey('FulfilledOnDemandCapacity')
            ? json['FulfilledOnDemandCapacity'] as double
            : null,
        launchTemplateConfigs: json.containsKey('LaunchTemplateConfigs')
            ? (json['LaunchTemplateConfigs'] as List)
                .map((e) => FleetLaunchTemplateConfig.fromJson(e))
                .toList()
            : null,
        targetCapacitySpecification:
            json.containsKey('TargetCapacitySpecification')
                ? TargetCapacitySpecification.fromJson(
                    json['TargetCapacitySpecification'])
                : null,
        terminateInstancesWithExpiration:
            json.containsKey('TerminateInstancesWithExpiration')
                ? json['TerminateInstancesWithExpiration'] as bool
                : null,
        type: json.containsKey('Type') ? json['Type'] as String : null,
        validFrom: json.containsKey('ValidFrom')
            ? DateTime.parse(json['ValidFrom'])
            : null,
        validUntil: json.containsKey('ValidUntil')
            ? DateTime.parse(json['ValidUntil'])
            : null,
        replaceUnhealthyInstances: json.containsKey('ReplaceUnhealthyInstances')
            ? json['ReplaceUnhealthyInstances'] as bool
            : null,
        spotOptions: json.containsKey('SpotOptions')
            ? SpotOptions.fromJson(json['SpotOptions'])
            : null,
        onDemandOptions: json.containsKey('OnDemandOptions')
            ? OnDemandOptions.fromJson(json['OnDemandOptions'])
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        errors: json.containsKey('Errors')
            ? (json['Errors'] as List)
                .map((e) => DescribeFleetError.fromJson(e))
                .toList()
            : null,
        instances: json.containsKey('Instances')
            ? (json['Instances'] as List)
                .map((e) => DescribeFleetsInstances.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes a launch template and overrides.
class FleetLaunchTemplateConfig {
  /// The launch template.
  final FleetLaunchTemplateSpecification launchTemplateSpecification;

  /// Any parameters that you specify override the same parameters in the launch
  /// template.
  final List<FleetLaunchTemplateOverrides> overrides;

  FleetLaunchTemplateConfig({
    this.launchTemplateSpecification,
    this.overrides,
  });
  static FleetLaunchTemplateConfig fromJson(Map<String, dynamic> json) =>
      FleetLaunchTemplateConfig(
        launchTemplateSpecification:
            json.containsKey('LaunchTemplateSpecification')
                ? FleetLaunchTemplateSpecification.fromJson(
                    json['LaunchTemplateSpecification'])
                : null,
        overrides: json.containsKey('Overrides')
            ? (json['Overrides'] as List)
                .map((e) => FleetLaunchTemplateOverrides.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes a launch template and overrides.
class FleetLaunchTemplateConfigRequest {
  /// The launch template to use. You must specify either the launch template ID
  /// or launch template name in the request.
  final FleetLaunchTemplateSpecificationRequest launchTemplateSpecification;

  /// Any parameters that you specify override the same parameters in the launch
  /// template.
  final List<FleetLaunchTemplateOverridesRequest> overrides;

  FleetLaunchTemplateConfigRequest({
    this.launchTemplateSpecification,
    this.overrides,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes overrides for a launch template.
class FleetLaunchTemplateOverrides {
  /// The instance type.
  final String instanceType;

  /// The maximum price per unit hour that you are willing to pay for a Spot
  /// Instance.
  final String maxPrice;

  /// The ID of the subnet in which to launch the instances.
  final String subnetId;

  /// The Availability Zone in which to launch the instances.
  final String availabilityZone;

  /// The number of units provided by the specified instance type.
  final double weightedCapacity;

  /// The priority for the launch template override. If **AllocationStrategy**
  /// is set to `prioritized`, EC2 Fleet uses priority to determine which launch
  /// template override to use first in fulfilling On-Demand capacity. The
  /// highest priority is launched first. Valid values are whole numbers
  /// starting at `0`. The lower the number, the higher the priority. If no
  /// number is set, the override has the lowest priority.
  final double priority;

  /// The location where the instance launched, if applicable.
  final PlacementResponse placement;

  FleetLaunchTemplateOverrides({
    this.instanceType,
    this.maxPrice,
    this.subnetId,
    this.availabilityZone,
    this.weightedCapacity,
    this.priority,
    this.placement,
  });
  static FleetLaunchTemplateOverrides fromJson(Map<String, dynamic> json) =>
      FleetLaunchTemplateOverrides(
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        maxPrice:
            json.containsKey('MaxPrice') ? json['MaxPrice'] as String : null,
        subnetId:
            json.containsKey('SubnetId') ? json['SubnetId'] as String : null,
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        weightedCapacity: json.containsKey('WeightedCapacity')
            ? json['WeightedCapacity'] as double
            : null,
        priority:
            json.containsKey('Priority') ? json['Priority'] as double : null,
        placement: json.containsKey('Placement')
            ? PlacementResponse.fromJson(json['Placement'])
            : null,
      );
}

/// Describes overrides for a launch template.
class FleetLaunchTemplateOverridesRequest {
  /// The instance type.
  final String instanceType;

  /// The maximum price per unit hour that you are willing to pay for a Spot
  /// Instance.
  final String maxPrice;

  /// The ID of the subnet in which to launch the instances.
  final String subnetId;

  /// The Availability Zone in which to launch the instances.
  final String availabilityZone;

  /// The number of units provided by the specified instance type.
  final double weightedCapacity;

  /// The priority for the launch template override. If **AllocationStrategy**
  /// is set to `prioritized`, EC2 Fleet uses priority to determine which launch
  /// template override to use first in fulfilling On-Demand capacity. The
  /// highest priority is launched first. Valid values are whole numbers
  /// starting at `0`. The lower the number, the higher the priority. If no
  /// number is set, the launch template override has the lowest priority.
  final double priority;

  /// The location where the instance launched, if applicable.
  final Placement placement;

  FleetLaunchTemplateOverridesRequest({
    this.instanceType,
    this.maxPrice,
    this.subnetId,
    this.availabilityZone,
    this.weightedCapacity,
    this.priority,
    this.placement,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a launch template.
class FleetLaunchTemplateSpecification {
  /// The ID of the launch template. You must specify either a template ID or a
  /// template name.
  final String launchTemplateId;

  /// The name of the launch template. You must specify either a template name
  /// or a template ID.
  final String launchTemplateName;

  /// The version number of the launch template. You must specify a version
  /// number.
  final String version;

  FleetLaunchTemplateSpecification({
    this.launchTemplateId,
    this.launchTemplateName,
    this.version,
  });
  static FleetLaunchTemplateSpecification fromJson(Map<String, dynamic> json) =>
      FleetLaunchTemplateSpecification(
        launchTemplateId: json.containsKey('LaunchTemplateId')
            ? json['LaunchTemplateId'] as String
            : null,
        launchTemplateName: json.containsKey('LaunchTemplateName')
            ? json['LaunchTemplateName'] as String
            : null,
        version: json.containsKey('Version') ? json['Version'] as String : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// The launch template to use. You must specify either the launch template ID
/// or launch template name in the request.
class FleetLaunchTemplateSpecificationRequest {
  /// The ID of the launch template.
  final String launchTemplateId;

  /// The name of the launch template.
  final String launchTemplateName;

  /// The version number of the launch template. Note: This is a required
  /// parameter and will be updated soon.
  final String version;

  FleetLaunchTemplateSpecificationRequest({
    this.launchTemplateId,
    this.launchTemplateName,
    this.version,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a flow log.
class FlowLog {
  /// The date and time the flow log was created.
  final DateTime creationTime;

  /// Information about the error that occurred. `Rate limited` indicates that
  /// CloudWatch Logs throttling has been applied for one or more network
  /// interfaces, or that you've reached the limit on the number of log groups
  /// that you can create. `Access error` indicates that the IAM role associated
  /// with the flow log does not have sufficient permissions to publish to
  /// CloudWatch Logs. `Unknown error` indicates an internal error.
  final String deliverLogsErrorMessage;

  /// The ARN of the IAM role that posts logs to CloudWatch Logs.
  final String deliverLogsPermissionArn;

  /// The status of the logs delivery (`SUCCESS` | `FAILED`).
  final String deliverLogsStatus;

  /// The flow log ID.
  final String flowLogId;

  /// The status of the flow log (`ACTIVE`).
  final String flowLogStatus;

  /// The name of the flow log group.
  final String logGroupName;

  /// The ID of the resource on which the flow log was created.
  final String resourceId;

  /// The type of traffic captured for the flow log.
  final String trafficType;

  /// Specifies the type of destination to which the flow log data is published.
  /// Flow log data can be published to CloudWatch Logs or Amazon S3.
  final String logDestinationType;

  /// Specifies the destination to which the flow log data is published. Flow
  /// log data can be published to an CloudWatch Logs log group or an Amazon S3
  /// bucket. If the flow log publishes to CloudWatch Logs, this element
  /// indicates the Amazon Resource Name (ARN) of the CloudWatch Logs log group
  /// to which the data is published. If the flow log publishes to Amazon S3,
  /// this element indicates the ARN of the Amazon S3 bucket to which the data
  /// is published.
  final String logDestination;

  /// The format of the flow log record.
  final String logFormat;

  FlowLog({
    this.creationTime,
    this.deliverLogsErrorMessage,
    this.deliverLogsPermissionArn,
    this.deliverLogsStatus,
    this.flowLogId,
    this.flowLogStatus,
    this.logGroupName,
    this.resourceId,
    this.trafficType,
    this.logDestinationType,
    this.logDestination,
    this.logFormat,
  });
  static FlowLog fromJson(Map<String, dynamic> json) => FlowLog(
        creationTime: json.containsKey('CreationTime')
            ? DateTime.parse(json['CreationTime'])
            : null,
        deliverLogsErrorMessage: json.containsKey('DeliverLogsErrorMessage')
            ? json['DeliverLogsErrorMessage'] as String
            : null,
        deliverLogsPermissionArn: json.containsKey('DeliverLogsPermissionArn')
            ? json['DeliverLogsPermissionArn'] as String
            : null,
        deliverLogsStatus: json.containsKey('DeliverLogsStatus')
            ? json['DeliverLogsStatus'] as String
            : null,
        flowLogId:
            json.containsKey('FlowLogId') ? json['FlowLogId'] as String : null,
        flowLogStatus: json.containsKey('FlowLogStatus')
            ? json['FlowLogStatus'] as String
            : null,
        logGroupName: json.containsKey('LogGroupName')
            ? json['LogGroupName'] as String
            : null,
        resourceId: json.containsKey('ResourceId')
            ? json['ResourceId'] as String
            : null,
        trafficType: json.containsKey('TrafficType')
            ? json['TrafficType'] as String
            : null,
        logDestinationType: json.containsKey('LogDestinationType')
            ? json['LogDestinationType'] as String
            : null,
        logDestination: json.containsKey('LogDestination')
            ? json['LogDestination'] as String
            : null,
        logFormat:
            json.containsKey('LogFormat') ? json['LogFormat'] as String : null,
      );
}

/// Describes an Amazon FPGA image (AFI).
class FpgaImage {
  /// The FPGA image identifier (AFI ID).
  final String fpgaImageId;

  /// The global FPGA image identifier (AGFI ID).
  final String fpgaImageGlobalId;

  /// The name of the AFI.
  final String name;

  /// The description of the AFI.
  final String description;

  /// The version of the AWS Shell that was used to create the bitstream.
  final String shellVersion;

  /// Information about the PCI bus.
  final PciId pciId;

  /// Information about the state of the AFI.
  final FpgaImageState state;

  /// The date and time the AFI was created.
  final DateTime createTime;

  /// The time of the most recent update to the AFI.
  final DateTime updateTime;

  /// The AWS account ID of the AFI owner.
  final String ownerId;

  /// The alias of the AFI owner. Possible values include `self`, `amazon`, and
  /// `aws-marketplace`.
  final String ownerAlias;

  /// The product codes for the AFI.
  final List<ProductCode> productCodes;

  /// Any tags assigned to the AFI.
  final List<Tag> tags;

  /// Indicates whether the AFI is public.
  final bool public;

  /// Indicates whether data retention support is enabled for the AFI.
  final bool dataRetentionSupport;

  FpgaImage({
    this.fpgaImageId,
    this.fpgaImageGlobalId,
    this.name,
    this.description,
    this.shellVersion,
    this.pciId,
    this.state,
    this.createTime,
    this.updateTime,
    this.ownerId,
    this.ownerAlias,
    this.productCodes,
    this.tags,
    this.public,
    this.dataRetentionSupport,
  });
  static FpgaImage fromJson(Map<String, dynamic> json) => FpgaImage(
        fpgaImageId: json.containsKey('FpgaImageId')
            ? json['FpgaImageId'] as String
            : null,
        fpgaImageGlobalId: json.containsKey('FpgaImageGlobalId')
            ? json['FpgaImageGlobalId'] as String
            : null,
        name: json.containsKey('Name') ? json['Name'] as String : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        shellVersion: json.containsKey('ShellVersion')
            ? json['ShellVersion'] as String
            : null,
        pciId: json.containsKey('PciId') ? PciId.fromJson(json['PciId']) : null,
        state: json.containsKey('State')
            ? FpgaImageState.fromJson(json['State'])
            : null,
        createTime: json.containsKey('CreateTime')
            ? DateTime.parse(json['CreateTime'])
            : null,
        updateTime: json.containsKey('UpdateTime')
            ? DateTime.parse(json['UpdateTime'])
            : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        ownerAlias: json.containsKey('OwnerAlias')
            ? json['OwnerAlias'] as String
            : null,
        productCodes: json.containsKey('ProductCodes')
            ? (json['ProductCodes'] as List)
                .map((e) => ProductCode.fromJson(e))
                .toList()
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        public: json.containsKey('Public') ? json['Public'] as bool : null,
        dataRetentionSupport: json.containsKey('DataRetentionSupport')
            ? json['DataRetentionSupport'] as bool
            : null,
      );
}

/// Describes an Amazon FPGA image (AFI) attribute.
class FpgaImageAttribute {
  /// The ID of the AFI.
  final String fpgaImageId;

  /// The name of the AFI.
  final String name;

  /// The description of the AFI.
  final String description;

  /// The load permissions.
  final List<LoadPermission> loadPermissions;

  /// The product codes.
  final List<ProductCode> productCodes;

  FpgaImageAttribute({
    this.fpgaImageId,
    this.name,
    this.description,
    this.loadPermissions,
    this.productCodes,
  });
  static FpgaImageAttribute fromJson(Map<String, dynamic> json) =>
      FpgaImageAttribute(
        fpgaImageId: json.containsKey('FpgaImageId')
            ? json['FpgaImageId'] as String
            : null,
        name: json.containsKey('Name') ? json['Name'] as String : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        loadPermissions: json.containsKey('LoadPermissions')
            ? (json['LoadPermissions'] as List)
                .map((e) => LoadPermission.fromJson(e))
                .toList()
            : null,
        productCodes: json.containsKey('ProductCodes')
            ? (json['ProductCodes'] as List)
                .map((e) => ProductCode.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes the state of the bitstream generation process for an Amazon FPGA
/// image (AFI).
class FpgaImageState {
  /// The state. The following are the possible values:
  ///
  /// *    `pending` - AFI bitstream generation is in progress.
  ///
  /// *    `available` - The AFI is available for use.
  ///
  /// *    `failed` - AFI bitstream generation failed.
  ///
  /// *    `unavailable` - The AFI is no longer available for use.
  final String code;

  /// If the state is `failed`, this is the error message.
  final String message;

  FpgaImageState({
    this.code,
    this.message,
  });
  static FpgaImageState fromJson(Map<String, dynamic> json) => FpgaImageState(
        code: json.containsKey('Code') ? json['Code'] as String : null,
        message: json.containsKey('Message') ? json['Message'] as String : null,
      );
}

class GetCapacityReservationUsageResult {
  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  /// The ID of the Capacity Reservation.
  final String capacityReservationId;

  /// The type of instance for which the Capacity Reservation reserves capacity.
  final String instanceType;

  /// The number of instances for which the Capacity Reservation reserves
  /// capacity.
  final int totalInstanceCount;

  /// The remaining capacity. Indicates the number of instances that can be
  /// launched in the Capacity Reservation.
  final int availableInstanceCount;

  /// The current state of the Capacity Reservation. A Capacity Reservation can
  /// be in one of the following states:
  ///
  /// *    `active` - The Capacity Reservation is active and the capacity is
  /// available for your use.
  ///
  /// *    `expired` - The Capacity Reservation expired automatically at the
  /// date and time specified in your request. The reserved capacity is no
  /// longer available for your use.
  ///
  /// *    `cancelled` - The Capacity Reservation was manually cancelled. The
  /// reserved capacity is no longer available for your use.
  ///
  /// *    `pending` - The Capacity Reservation request was successful but the
  /// capacity provisioning is still pending.
  ///
  /// *    `failed` - The Capacity Reservation request has failed. A request
  /// might fail due to invalid request parameters, capacity constraints, or
  /// instance limit constraints. Failed requests are retained for 60 minutes.
  final String state;

  /// Information about the Capacity Reservation usage.
  final List<InstanceUsage> instanceUsages;

  GetCapacityReservationUsageResult({
    this.nextToken,
    this.capacityReservationId,
    this.instanceType,
    this.totalInstanceCount,
    this.availableInstanceCount,
    this.state,
    this.instanceUsages,
  });
  static GetCapacityReservationUsageResult fromJson(
          Map<String, dynamic> json) =>
      GetCapacityReservationUsageResult(
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
        capacityReservationId: json.containsKey('CapacityReservationId')
            ? json['CapacityReservationId'] as String
            : null,
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        totalInstanceCount: json.containsKey('TotalInstanceCount')
            ? json['TotalInstanceCount'] as int
            : null,
        availableInstanceCount: json.containsKey('AvailableInstanceCount')
            ? json['AvailableInstanceCount'] as int
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        instanceUsages: json.containsKey('InstanceUsages')
            ? (json['InstanceUsages'] as List)
                .map((e) => InstanceUsage.fromJson(e))
                .toList()
            : null,
      );
}

class GetConsoleOutputResult {
  /// The ID of the instance.
  final String instanceId;

  /// The console output, base64-encoded. If you are using a command line tool,
  /// the tool decodes the output for you.
  final String output;

  /// The time at which the output was last updated.
  final DateTime timestamp;

  GetConsoleOutputResult({
    this.instanceId,
    this.output,
    this.timestamp,
  });
  static GetConsoleOutputResult fromJson(Map<String, dynamic> json) =>
      GetConsoleOutputResult(
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        output: json.containsKey('Output') ? json['Output'] as String : null,
        timestamp: json.containsKey('Timestamp')
            ? DateTime.parse(json['Timestamp'])
            : null,
      );
}

class GetConsoleScreenshotResult {
  /// The data that comprises the image.
  final String imageData;

  /// The ID of the instance.
  final String instanceId;

  GetConsoleScreenshotResult({
    this.imageData,
    this.instanceId,
  });
  static GetConsoleScreenshotResult fromJson(Map<String, dynamic> json) =>
      GetConsoleScreenshotResult(
        imageData:
            json.containsKey('ImageData') ? json['ImageData'] as String : null,
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
      );
}

class GetEbsDefaultKmsKeyIdResult {
  /// The Amazon Resource Name (ARN) of the default CMK for encryption by
  /// default.
  final String kmsKeyId;

  GetEbsDefaultKmsKeyIdResult({
    this.kmsKeyId,
  });
  static GetEbsDefaultKmsKeyIdResult fromJson(Map<String, dynamic> json) =>
      GetEbsDefaultKmsKeyIdResult(
        kmsKeyId:
            json.containsKey('KmsKeyId') ? json['KmsKeyId'] as String : null,
      );
}

class GetEbsEncryptionByDefaultResult {
  /// Indicates whether encryption by default is enabled.
  final bool ebsEncryptionByDefault;

  GetEbsEncryptionByDefaultResult({
    this.ebsEncryptionByDefault,
  });
  static GetEbsEncryptionByDefaultResult fromJson(Map<String, dynamic> json) =>
      GetEbsEncryptionByDefaultResult(
        ebsEncryptionByDefault: json.containsKey('EbsEncryptionByDefault')
            ? json['EbsEncryptionByDefault'] as bool
            : null,
      );
}

class GetHostReservationPurchasePreviewResult {
  /// The currency in which the `totalUpfrontPrice` and `totalHourlyPrice`
  /// amounts are specified. At this time, the only supported currency is `USD`.
  final String currencyCode;

  /// The purchase information of the Dedicated Host reservation and the
  /// Dedicated Hosts associated with it.
  final List<Purchase> purchase;

  /// The potential total hourly price of the reservation per hour.
  final String totalHourlyPrice;

  /// The potential total upfront price. This is billed immediately.
  final String totalUpfrontPrice;

  GetHostReservationPurchasePreviewResult({
    this.currencyCode,
    this.purchase,
    this.totalHourlyPrice,
    this.totalUpfrontPrice,
  });
  static GetHostReservationPurchasePreviewResult fromJson(
          Map<String, dynamic> json) =>
      GetHostReservationPurchasePreviewResult(
        currencyCode: json.containsKey('CurrencyCode')
            ? json['CurrencyCode'] as String
            : null,
        purchase: json.containsKey('Purchase')
            ? (json['Purchase'] as List)
                .map((e) => Purchase.fromJson(e))
                .toList()
            : null,
        totalHourlyPrice: json.containsKey('TotalHourlyPrice')
            ? json['TotalHourlyPrice'] as String
            : null,
        totalUpfrontPrice: json.containsKey('TotalUpfrontPrice')
            ? json['TotalUpfrontPrice'] as String
            : null,
      );
}

class GetLaunchTemplateDataResult {
  /// The instance data.
  final ResponseLaunchTemplateData launchTemplateData;

  GetLaunchTemplateDataResult({
    this.launchTemplateData,
  });
  static GetLaunchTemplateDataResult fromJson(Map<String, dynamic> json) =>
      GetLaunchTemplateDataResult(
        launchTemplateData: json.containsKey('LaunchTemplateData')
            ? ResponseLaunchTemplateData.fromJson(json['LaunchTemplateData'])
            : null,
      );
}

class GetPasswordDataResult {
  /// The ID of the Windows instance.
  final String instanceId;

  /// The password of the instance. Returns an empty string if the password is
  /// not available.
  final String passwordData;

  /// The time the data was last updated.
  final DateTime timestamp;

  GetPasswordDataResult({
    this.instanceId,
    this.passwordData,
    this.timestamp,
  });
  static GetPasswordDataResult fromJson(Map<String, dynamic> json) =>
      GetPasswordDataResult(
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        passwordData: json.containsKey('PasswordData')
            ? json['PasswordData'] as String
            : null,
        timestamp: json.containsKey('Timestamp')
            ? DateTime.parse(json['Timestamp'])
            : null,
      );
}

/// Contains the output of GetReservedInstancesExchangeQuote.
class GetReservedInstancesExchangeQuoteResult {
  /// The currency of the transaction.
  final String currencyCode;

  /// If `true`, the exchange is valid. If `false`, the exchange cannot be
  /// completed.
  final bool isValidExchange;

  /// The new end date of the reservation term.
  final DateTime outputReservedInstancesWillExpireAt;

  /// The total true upfront charge for the exchange.
  final String paymentDue;

  /// The cost associated with the Reserved Instance.
  final ReservationValue reservedInstanceValueRollup;

  /// The configuration of your Convertible Reserved Instances.
  final List<ReservedInstanceReservationValue> reservedInstanceValueSet;

  /// The cost associated with the Reserved Instance.
  final ReservationValue targetConfigurationValueRollup;

  /// The values of the target Convertible Reserved Instances.
  final List<TargetReservationValue> targetConfigurationValueSet;

  /// Describes the reason why the exchange cannot be completed.
  final String validationFailureReason;

  GetReservedInstancesExchangeQuoteResult({
    this.currencyCode,
    this.isValidExchange,
    this.outputReservedInstancesWillExpireAt,
    this.paymentDue,
    this.reservedInstanceValueRollup,
    this.reservedInstanceValueSet,
    this.targetConfigurationValueRollup,
    this.targetConfigurationValueSet,
    this.validationFailureReason,
  });
  static GetReservedInstancesExchangeQuoteResult fromJson(
          Map<String, dynamic> json) =>
      GetReservedInstancesExchangeQuoteResult(
        currencyCode: json.containsKey('CurrencyCode')
            ? json['CurrencyCode'] as String
            : null,
        isValidExchange: json.containsKey('IsValidExchange')
            ? json['IsValidExchange'] as bool
            : null,
        outputReservedInstancesWillExpireAt:
            json.containsKey('OutputReservedInstancesWillExpireAt')
                ? DateTime.parse(json['OutputReservedInstancesWillExpireAt'])
                : null,
        paymentDue: json.containsKey('PaymentDue')
            ? json['PaymentDue'] as String
            : null,
        reservedInstanceValueRollup:
            json.containsKey('ReservedInstanceValueRollup')
                ? ReservationValue.fromJson(json['ReservedInstanceValueRollup'])
                : null,
        reservedInstanceValueSet: json.containsKey('ReservedInstanceValueSet')
            ? (json['ReservedInstanceValueSet'] as List)
                .map((e) => ReservedInstanceReservationValue.fromJson(e))
                .toList()
            : null,
        targetConfigurationValueRollup: json
                .containsKey('TargetConfigurationValueRollup')
            ? ReservationValue.fromJson(json['TargetConfigurationValueRollup'])
            : null,
        targetConfigurationValueSet:
            json.containsKey('TargetConfigurationValueSet')
                ? (json['TargetConfigurationValueSet'] as List)
                    .map((e) => TargetReservationValue.fromJson(e))
                    .toList()
                : null,
        validationFailureReason: json.containsKey('ValidationFailureReason')
            ? json['ValidationFailureReason'] as String
            : null,
      );
}

class GetTransitGatewayAttachmentPropagationsResult {
  /// Information about the propagation route tables.
  final List<TransitGatewayAttachmentPropagation>
      transitGatewayAttachmentPropagations;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  GetTransitGatewayAttachmentPropagationsResult({
    this.transitGatewayAttachmentPropagations,
    this.nextToken,
  });
  static GetTransitGatewayAttachmentPropagationsResult fromJson(
          Map<String, dynamic> json) =>
      GetTransitGatewayAttachmentPropagationsResult(
        transitGatewayAttachmentPropagations:
            json.containsKey('TransitGatewayAttachmentPropagations')
                ? (json['TransitGatewayAttachmentPropagations'] as List)
                    .map((e) => TransitGatewayAttachmentPropagation.fromJson(e))
                    .toList()
                : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class GetTransitGatewayRouteTableAssociationsResult {
  /// Information about the associations.
  final List<TransitGatewayRouteTableAssociation> associations;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  GetTransitGatewayRouteTableAssociationsResult({
    this.associations,
    this.nextToken,
  });
  static GetTransitGatewayRouteTableAssociationsResult fromJson(
          Map<String, dynamic> json) =>
      GetTransitGatewayRouteTableAssociationsResult(
        associations: json.containsKey('Associations')
            ? (json['Associations'] as List)
                .map((e) => TransitGatewayRouteTableAssociation.fromJson(e))
                .toList()
            : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

class GetTransitGatewayRouteTablePropagationsResult {
  /// Information about the route table propagations.
  final List<TransitGatewayRouteTablePropagation>
      transitGatewayRouteTablePropagations;

  /// The token to use to retrieve the next page of results. This value is
  /// `null` when there are no more results to return.
  final String nextToken;

  GetTransitGatewayRouteTablePropagationsResult({
    this.transitGatewayRouteTablePropagations,
    this.nextToken,
  });
  static GetTransitGatewayRouteTablePropagationsResult fromJson(
          Map<String, dynamic> json) =>
      GetTransitGatewayRouteTablePropagationsResult(
        transitGatewayRouteTablePropagations:
            json.containsKey('TransitGatewayRouteTablePropagations')
                ? (json['TransitGatewayRouteTablePropagations'] as List)
                    .map((e) => TransitGatewayRouteTablePropagation.fromJson(e))
                    .toList()
                : null,
        nextToken:
            json.containsKey('NextToken') ? json['NextToken'] as String : null,
      );
}

/// Describes a security group.
class GroupIdentifier {
  /// The name of the security group.
  final String groupName;

  /// The ID of the security group.
  final String groupId;

  GroupIdentifier({
    this.groupName,
    this.groupId,
  });
  static GroupIdentifier fromJson(Map<String, dynamic> json) => GroupIdentifier(
        groupName:
            json.containsKey('GroupName') ? json['GroupName'] as String : null,
        groupId: json.containsKey('GroupId') ? json['GroupId'] as String : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Indicates whether your instance is configured for hibernation. This
/// parameter is valid only if the instance meets the
/// [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites).
/// Hibernation is currently supported only for Amazon Linux. For more
/// information, see
/// [Hibernate Your Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html)
/// in the _Amazon Elastic Compute Cloud User Guide_.
class HibernationOptions {
  /// If this parameter is set to `true`, your instance is enabled for
  /// hibernation; otherwise, it is not enabled for hibernation.
  final bool configured;

  HibernationOptions({
    this.configured,
  });
  static HibernationOptions fromJson(Map<String, dynamic> json) =>
      HibernationOptions(
        configured:
            json.containsKey('Configured') ? json['Configured'] as bool : null,
      );
}

/// Indicates whether your instance is configured for hibernation. This
/// parameter is valid only if the instance meets the
/// [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites).
/// Hibernation is currently supported only for Amazon Linux. For more
/// information, see
/// [Hibernate Your Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html)
/// in the _Amazon Elastic Compute Cloud User Guide_.
class HibernationOptionsRequest {
  /// If you set this parameter to `true`, your instance is enabled for
  /// hibernation.
  ///
  /// Default: `false`
  final bool configured;

  HibernationOptionsRequest({
    this.configured,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes an event in the history of the Spot Fleet request.
class HistoryRecord {
  /// Information about the event.
  final EventInformation eventInformation;

  /// The event type.
  ///
  /// *    `error` - An error with the Spot Fleet request.
  ///
  /// *    `fleetRequestChange` - A change in the status or configuration of the
  /// Spot Fleet request.
  ///
  /// *    `instanceChange` - An instance was launched or terminated.
  ///
  /// *    `Information` - An informational event.
  final String eventType;

  /// The date and time of the event, in UTC format (for example,
  /// _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z).
  final DateTime timestamp;

  HistoryRecord({
    this.eventInformation,
    this.eventType,
    this.timestamp,
  });
  static HistoryRecord fromJson(Map<String, dynamic> json) => HistoryRecord(
        eventInformation: json.containsKey('EventInformation')
            ? EventInformation.fromJson(json['EventInformation'])
            : null,
        eventType:
            json.containsKey('EventType') ? json['EventType'] as String : null,
        timestamp: json.containsKey('Timestamp')
            ? DateTime.parse(json['Timestamp'])
            : null,
      );
}

/// Describes an event in the history of an EC2 Fleet.
class HistoryRecordEntry {
  /// Information about the event.
  final EventInformation eventInformation;

  /// The event type.
  final String eventType;

  /// The date and time of the event, in UTC format (for example,
  /// _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z).
  final DateTime timestamp;

  HistoryRecordEntry({
    this.eventInformation,
    this.eventType,
    this.timestamp,
  });
  static HistoryRecordEntry fromJson(Map<String, dynamic> json) =>
      HistoryRecordEntry(
        eventInformation: json.containsKey('EventInformation')
            ? EventInformation.fromJson(json['EventInformation'])
            : null,
        eventType:
            json.containsKey('EventType') ? json['EventType'] as String : null,
        timestamp: json.containsKey('Timestamp')
            ? DateTime.parse(json['Timestamp'])
            : null,
      );
}

/// Describes the properties of the Dedicated Host.
class Host {
  /// Whether auto-placement is on or off.
  final String autoPlacement;

  /// The Availability Zone of the Dedicated Host.
  final String availabilityZone;

  /// The number of new instances that can be launched onto the Dedicated Host.
  final AvailableCapacity availableCapacity;

  /// Unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  final String clientToken;

  /// The ID of the Dedicated Host.
  final String hostId;

  /// The hardware specifications of the Dedicated Host.
  final HostProperties hostProperties;

  /// The reservation ID of the Dedicated Host. This returns a `null` response
  /// if the Dedicated Host doesn't have an associated reservation.
  final String hostReservationId;

  /// The IDs and instance type that are currently running on the Dedicated
  /// Host.
  final List<HostInstance> instances;

  /// The Dedicated Host's state.
  final String state;

  /// The time that the Dedicated Host was allocated.
  final DateTime allocationTime;

  /// The time that the Dedicated Host was released.
  final DateTime releaseTime;

  /// Any tags assigned to the Dedicated Host.
  final List<Tag> tags;

  /// Indicates whether host recovery is enabled or disabled for the Dedicated
  /// Host.
  final String hostRecovery;

  Host({
    this.autoPlacement,
    this.availabilityZone,
    this.availableCapacity,
    this.clientToken,
    this.hostId,
    this.hostProperties,
    this.hostReservationId,
    this.instances,
    this.state,
    this.allocationTime,
    this.releaseTime,
    this.tags,
    this.hostRecovery,
  });
  static Host fromJson(Map<String, dynamic> json) => Host(
        autoPlacement: json.containsKey('AutoPlacement')
            ? json['AutoPlacement'] as String
            : null,
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        availableCapacity: json.containsKey('AvailableCapacity')
            ? AvailableCapacity.fromJson(json['AvailableCapacity'])
            : null,
        clientToken: json.containsKey('ClientToken')
            ? json['ClientToken'] as String
            : null,
        hostId: json.containsKey('HostId') ? json['HostId'] as String : null,
        hostProperties: json.containsKey('HostProperties')
            ? HostProperties.fromJson(json['HostProperties'])
            : null,
        hostReservationId: json.containsKey('HostReservationId')
            ? json['HostReservationId'] as String
            : null,
        instances: json.containsKey('Instances')
            ? (json['Instances'] as List)
                .map((e) => HostInstance.fromJson(e))
                .toList()
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        allocationTime: json.containsKey('AllocationTime')
            ? DateTime.parse(json['AllocationTime'])
            : null,
        releaseTime: json.containsKey('ReleaseTime')
            ? DateTime.parse(json['ReleaseTime'])
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        hostRecovery: json.containsKey('HostRecovery')
            ? json['HostRecovery'] as String
            : null,
      );
}

/// Describes an instance running on a Dedicated Host.
class HostInstance {
  /// the IDs of instances that are running on the Dedicated Host.
  final String instanceId;

  /// The instance type size (for example, `m3.medium`) of the running instance.
  final String instanceType;

  HostInstance({
    this.instanceId,
    this.instanceType,
  });
  static HostInstance fromJson(Map<String, dynamic> json) => HostInstance(
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
      );
}

/// Details about the Dedicated Host Reservation offering.
class HostOffering {
  /// The currency of the offering.
  final String currencyCode;

  /// The duration of the offering (in seconds).
  final int duration;

  /// The hourly price of the offering.
  final String hourlyPrice;

  /// The instance family of the offering.
  final String instanceFamily;

  /// The ID of the offering.
  final String offeringId;

  /// The available payment option.
  final String paymentOption;

  /// The upfront price of the offering. Does not apply to No Upfront offerings.
  final String upfrontPrice;

  HostOffering({
    this.currencyCode,
    this.duration,
    this.hourlyPrice,
    this.instanceFamily,
    this.offeringId,
    this.paymentOption,
    this.upfrontPrice,
  });
  static HostOffering fromJson(Map<String, dynamic> json) => HostOffering(
        currencyCode: json.containsKey('CurrencyCode')
            ? json['CurrencyCode'] as String
            : null,
        duration: json.containsKey('Duration') ? json['Duration'] as int : null,
        hourlyPrice: json.containsKey('HourlyPrice')
            ? json['HourlyPrice'] as String
            : null,
        instanceFamily: json.containsKey('InstanceFamily')
            ? json['InstanceFamily'] as String
            : null,
        offeringId: json.containsKey('OfferingId')
            ? json['OfferingId'] as String
            : null,
        paymentOption: json.containsKey('PaymentOption')
            ? json['PaymentOption'] as String
            : null,
        upfrontPrice: json.containsKey('UpfrontPrice')
            ? json['UpfrontPrice'] as String
            : null,
      );
}

/// Describes properties of a Dedicated Host.
class HostProperties {
  /// The number of cores on the Dedicated Host.
  final int cores;

  /// The instance type size that the Dedicated Host supports (for example,
  /// `m3.medium`).
  final String instanceType;

  /// The number of sockets on the Dedicated Host.
  final int sockets;

  /// The number of vCPUs on the Dedicated Host.
  final int totalvCpus;

  HostProperties({
    this.cores,
    this.instanceType,
    this.sockets,
    this.totalvCpus,
  });
  static HostProperties fromJson(Map<String, dynamic> json) => HostProperties(
        cores: json.containsKey('Cores') ? json['Cores'] as int : null,
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        sockets: json.containsKey('Sockets') ? json['Sockets'] as int : null,
        totalvCpus:
            json.containsKey('TotalVCpus') ? json['TotalVCpus'] as int : null,
      );
}

/// Details about the Dedicated Host Reservation and associated Dedicated Hosts.
class HostReservation {
  /// The number of Dedicated Hosts the reservation is associated with.
  final int count;

  /// The currency in which the `upfrontPrice` and `hourlyPrice` amounts are
  /// specified. At this time, the only supported currency is `USD`.
  final String currencyCode;

  /// The length of the reservation's term, specified in seconds. Can be
  /// `31536000 (1 year)` | `94608000 (3 years)`.
  final int duration;

  /// The date and time that the reservation ends.
  final DateTime end;

  /// The IDs of the Dedicated Hosts associated with the reservation.
  final List<String> hostIdSet;

  /// The ID of the reservation that specifies the associated Dedicated Hosts.
  final String hostReservationId;

  /// The hourly price of the reservation.
  final String hourlyPrice;

  /// The instance family of the Dedicated Host Reservation. The instance family
  /// on the Dedicated Host must be the same in order for it to benefit from the
  /// reservation.
  final String instanceFamily;

  /// The ID of the reservation. This remains the same regardless of which
  /// Dedicated Hosts are associated with it.
  final String offeringId;

  /// The payment option selected for this reservation.
  final String paymentOption;

  /// The date and time that the reservation started.
  final DateTime start;

  /// The state of the reservation.
  final String state;

  /// The upfront price of the reservation.
  final String upfrontPrice;

  /// Any tags assigned to the Dedicated Host Reservation.
  final List<Tag> tags;

  HostReservation({
    this.count,
    this.currencyCode,
    this.duration,
    this.end,
    this.hostIdSet,
    this.hostReservationId,
    this.hourlyPrice,
    this.instanceFamily,
    this.offeringId,
    this.paymentOption,
    this.start,
    this.state,
    this.upfrontPrice,
    this.tags,
  });
  static HostReservation fromJson(Map<String, dynamic> json) => HostReservation(
        count: json.containsKey('Count') ? json['Count'] as int : null,
        currencyCode: json.containsKey('CurrencyCode')
            ? json['CurrencyCode'] as String
            : null,
        duration: json.containsKey('Duration') ? json['Duration'] as int : null,
        end: json.containsKey('End') ? DateTime.parse(json['End']) : null,
        hostIdSet: json.containsKey('HostIdSet')
            ? (json['HostIdSet'] as List).map((e) => e as String).toList()
            : null,
        hostReservationId: json.containsKey('HostReservationId')
            ? json['HostReservationId'] as String
            : null,
        hourlyPrice: json.containsKey('HourlyPrice')
            ? json['HourlyPrice'] as String
            : null,
        instanceFamily: json.containsKey('InstanceFamily')
            ? json['InstanceFamily'] as String
            : null,
        offeringId: json.containsKey('OfferingId')
            ? json['OfferingId'] as String
            : null,
        paymentOption: json.containsKey('PaymentOption')
            ? json['PaymentOption'] as String
            : null,
        start: json.containsKey('Start') ? DateTime.parse(json['Start']) : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        upfrontPrice: json.containsKey('UpfrontPrice')
            ? json['UpfrontPrice'] as String
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// The internet key exchange (IKE) version permitted for the VPN tunnel.
class IkeVersionsListValue {
  /// The IKE version.
  final String value;

  IkeVersionsListValue({
    this.value,
  });
  static IkeVersionsListValue fromJson(Map<String, dynamic> json) =>
      IkeVersionsListValue(
        value: json.containsKey('Value') ? json['Value'] as String : null,
      );
}

/// The IKE version that is permitted for the VPN tunnel.
class IkeVersionsRequestListValue {
  /// The IKE version.
  final String value;

  IkeVersionsRequestListValue({
    this.value,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes an IAM instance profile.
class IamInstanceProfile {
  /// The Amazon Resource Name (ARN) of the instance profile.
  final String arn;

  /// The ID of the instance profile.
  final String id;

  IamInstanceProfile({
    this.arn,
    this.id,
  });
  static IamInstanceProfile fromJson(Map<String, dynamic> json) =>
      IamInstanceProfile(
        arn: json.containsKey('Arn') ? json['Arn'] as String : null,
        id: json.containsKey('Id') ? json['Id'] as String : null,
      );
}

/// Describes an association between an IAM instance profile and an instance.
class IamInstanceProfileAssociation {
  /// The ID of the association.
  final String associationId;

  /// The ID of the instance.
  final String instanceId;

  /// The IAM instance profile.
  final IamInstanceProfile iamInstanceProfile;

  /// The state of the association.
  final String state;

  /// The time the IAM instance profile was associated with the instance.
  final DateTime timestamp;

  IamInstanceProfileAssociation({
    this.associationId,
    this.instanceId,
    this.iamInstanceProfile,
    this.state,
    this.timestamp,
  });
  static IamInstanceProfileAssociation fromJson(Map<String, dynamic> json) =>
      IamInstanceProfileAssociation(
        associationId: json.containsKey('AssociationId')
            ? json['AssociationId'] as String
            : null,
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        iamInstanceProfile: json.containsKey('IamInstanceProfile')
            ? IamInstanceProfile.fromJson(json['IamInstanceProfile'])
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        timestamp: json.containsKey('Timestamp')
            ? DateTime.parse(json['Timestamp'])
            : null,
      );
}

/// Describes an IAM instance profile.
class IamInstanceProfileSpecification {
  /// The Amazon Resource Name (ARN) of the instance profile.
  final String arn;

  /// The name of the instance profile.
  final String name;

  IamInstanceProfileSpecification({
    this.arn,
    this.name,
  });
  static IamInstanceProfileSpecification fromJson(Map<String, dynamic> json) =>
      IamInstanceProfileSpecification(
        arn: json.containsKey('Arn') ? json['Arn'] as String : null,
        name: json.containsKey('Name') ? json['Name'] as String : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the ICMP type and code.
class IcmpTypeCode {
  /// The ICMP code. A value of -1 means all codes for the specified ICMP type.
  final int code;

  /// The ICMP type. A value of -1 means all types.
  final int type;

  IcmpTypeCode({
    this.code,
    this.type,
  });
  static IcmpTypeCode fromJson(Map<String, dynamic> json) => IcmpTypeCode(
        code: json.containsKey('Code') ? json['Code'] as int : null,
        type: json.containsKey('Type') ? json['Type'] as int : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the ID format for a resource.
class IdFormat {
  /// The date in UTC at which you are permanently switched over to using longer
  /// IDs. If a deadline is not yet available for this resource type, this field
  /// is not returned.
  final DateTime deadline;

  /// The type of resource.
  final String resource;

  /// Indicates whether longer IDs (17-character IDs) are enabled for the
  /// resource.
  final bool useLongIds;

  IdFormat({
    this.deadline,
    this.resource,
    this.useLongIds,
  });
  static IdFormat fromJson(Map<String, dynamic> json) => IdFormat(
        deadline: json.containsKey('Deadline')
            ? DateTime.parse(json['Deadline'])
            : null,
        resource:
            json.containsKey('Resource') ? json['Resource'] as String : null,
        useLongIds:
            json.containsKey('UseLongIds') ? json['UseLongIds'] as bool : null,
      );
}

/// Describes an image.
class Image {
  /// The architecture of the image.
  final String architecture;

  /// The date and time the image was created.
  final String creationDate;

  /// The ID of the AMI.
  final String imageId;

  /// The location of the AMI.
  final String imageLocation;

  /// The type of image.
  final String imageType;

  /// Indicates whether the image has public launch permissions. The value is
  /// `true` if this image has public launch permissions or `false` if it has
  /// only implicit and explicit launch permissions.
  final bool public;

  /// The kernel associated with the image, if any. Only applicable for machine
  /// images.
  final String kernelId;

  /// The AWS account ID of the image owner.
  final String ownerId;

  /// This value is set to `windows` for Windows AMIs; otherwise, it is blank.
  final String platform;

  /// Any product codes associated with the AMI.
  final List<ProductCode> productCodes;

  /// The RAM disk associated with the image, if any. Only applicable for
  /// machine images.
  final String ramdiskId;

  /// The current state of the AMI. If the state is `available`, the image is
  /// successfully registered and can be used to launch an instance.
  final String state;

  /// Any block device mapping entries.
  final List<BlockDeviceMapping> blockDeviceMappings;

  /// The description of the AMI that was provided during image creation.
  final String description;

  /// Specifies whether enhanced networking with ENA is enabled.
  final bool enaSupport;

  /// The hypervisor type of the image.
  final String hypervisor;

  /// The AWS account alias (for example, `amazon`, `self`) or the AWS account
  /// ID of the AMI owner.
  final String imageOwnerAlias;

  /// The name of the AMI that was provided during image creation.
  final String name;

  /// The device name of the root device volume (for example, `/dev/sda1`).
  final String rootDeviceName;

  /// The type of root device used by the AMI. The AMI can use an EBS volume or
  /// an instance store volume.
  final String rootDeviceType;

  /// Specifies whether enhanced networking with the Intel 82599 Virtual
  /// Function interface is enabled.
  final String sriovNetSupport;

  /// The reason for the state change.
  final StateReason stateReason;

  /// Any tags assigned to the image.
  final List<Tag> tags;

  /// The type of virtualization of the AMI.
  final String virtualizationType;

  Image({
    this.architecture,
    this.creationDate,
    this.imageId,
    this.imageLocation,
    this.imageType,
    this.public,
    this.kernelId,
    this.ownerId,
    this.platform,
    this.productCodes,
    this.ramdiskId,
    this.state,
    this.blockDeviceMappings,
    this.description,
    this.enaSupport,
    this.hypervisor,
    this.imageOwnerAlias,
    this.name,
    this.rootDeviceName,
    this.rootDeviceType,
    this.sriovNetSupport,
    this.stateReason,
    this.tags,
    this.virtualizationType,
  });
  static Image fromJson(Map<String, dynamic> json) => Image(
        architecture: json.containsKey('Architecture')
            ? json['Architecture'] as String
            : null,
        creationDate: json.containsKey('CreationDate')
            ? json['CreationDate'] as String
            : null,
        imageId: json.containsKey('ImageId') ? json['ImageId'] as String : null,
        imageLocation: json.containsKey('ImageLocation')
            ? json['ImageLocation'] as String
            : null,
        imageType:
            json.containsKey('ImageType') ? json['ImageType'] as String : null,
        public: json.containsKey('Public') ? json['Public'] as bool : null,
        kernelId:
            json.containsKey('KernelId') ? json['KernelId'] as String : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        platform:
            json.containsKey('Platform') ? json['Platform'] as String : null,
        productCodes: json.containsKey('ProductCodes')
            ? (json['ProductCodes'] as List)
                .map((e) => ProductCode.fromJson(e))
                .toList()
            : null,
        ramdiskId:
            json.containsKey('RamdiskId') ? json['RamdiskId'] as String : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        blockDeviceMappings: json.containsKey('BlockDeviceMappings')
            ? (json['BlockDeviceMappings'] as List)
                .map((e) => BlockDeviceMapping.fromJson(e))
                .toList()
            : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        enaSupport:
            json.containsKey('EnaSupport') ? json['EnaSupport'] as bool : null,
        hypervisor: json.containsKey('Hypervisor')
            ? json['Hypervisor'] as String
            : null,
        imageOwnerAlias: json.containsKey('ImageOwnerAlias')
            ? json['ImageOwnerAlias'] as String
            : null,
        name: json.containsKey('Name') ? json['Name'] as String : null,
        rootDeviceName: json.containsKey('RootDeviceName')
            ? json['RootDeviceName'] as String
            : null,
        rootDeviceType: json.containsKey('RootDeviceType')
            ? json['RootDeviceType'] as String
            : null,
        sriovNetSupport: json.containsKey('SriovNetSupport')
            ? json['SriovNetSupport'] as String
            : null,
        stateReason: json.containsKey('StateReason')
            ? StateReason.fromJson(json['StateReason'])
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        virtualizationType: json.containsKey('VirtualizationType')
            ? json['VirtualizationType'] as String
            : null,
      );
}

/// Describes an image attribute.
class ImageAttribute {
  /// The block device mapping entries.
  final List<BlockDeviceMapping> blockDeviceMappings;

  /// The ID of the AMI.
  final String imageId;

  /// The launch permissions.
  final List<LaunchPermission> launchPermissions;

  /// The product codes.
  final List<ProductCode> productCodes;

  /// A description for the AMI.
  final AttributeValue description;

  /// The kernel ID.
  final AttributeValue kernelId;

  /// The RAM disk ID.
  final AttributeValue ramdiskId;

  /// Indicates whether enhanced networking with the Intel 82599 Virtual
  /// Function interface is enabled.
  final AttributeValue sriovNetSupport;

  ImageAttribute({
    this.blockDeviceMappings,
    this.imageId,
    this.launchPermissions,
    this.productCodes,
    this.description,
    this.kernelId,
    this.ramdiskId,
    this.sriovNetSupport,
  });
  static ImageAttribute fromJson(Map<String, dynamic> json) => ImageAttribute(
        blockDeviceMappings: json.containsKey('BlockDeviceMappings')
            ? (json['BlockDeviceMappings'] as List)
                .map((e) => BlockDeviceMapping.fromJson(e))
                .toList()
            : null,
        imageId: json.containsKey('ImageId') ? json['ImageId'] as String : null,
        launchPermissions: json.containsKey('LaunchPermissions')
            ? (json['LaunchPermissions'] as List)
                .map((e) => LaunchPermission.fromJson(e))
                .toList()
            : null,
        productCodes: json.containsKey('ProductCodes')
            ? (json['ProductCodes'] as List)
                .map((e) => ProductCode.fromJson(e))
                .toList()
            : null,
        description: json.containsKey('Description')
            ? AttributeValue.fromJson(json['Description'])
            : null,
        kernelId: json.containsKey('KernelId')
            ? AttributeValue.fromJson(json['KernelId'])
            : null,
        ramdiskId: json.containsKey('RamdiskId')
            ? AttributeValue.fromJson(json['RamdiskId'])
            : null,
        sriovNetSupport: json.containsKey('SriovNetSupport')
            ? AttributeValue.fromJson(json['SriovNetSupport'])
            : null,
      );
}

/// Describes the disk container object for an import image task.
class ImageDiskContainer {
  /// The description of the disk image.
  final String description;

  /// The block device mapping for the disk.
  final String deviceName;

  /// The format of the disk image being imported.
  ///
  /// Valid values: `VHD` | `VMDK` | `OVA`
  final String format;

  /// The ID of the EBS snapshot to be used for importing the snapshot.
  final String snapshotId;

  /// The URL to the Amazon S3-based disk image being imported. The URL can
  /// either be a https URL (https://..) or an Amazon S3 URL (s3://..)
  final String url;

  /// The S3 bucket for the disk image.
  final UserBucket userBucket;

  ImageDiskContainer({
    this.description,
    this.deviceName,
    this.format,
    this.snapshotId,
    this.url,
    this.userBucket,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

class ImportClientVpnClientCertificateRevocationListResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool return$;

  ImportClientVpnClientCertificateRevocationListResult({
    this.return$,
  });
  static ImportClientVpnClientCertificateRevocationListResult fromJson(
          Map<String, dynamic> json) =>
      ImportClientVpnClientCertificateRevocationListResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class ImportImageResult {
  /// The architecture of the virtual machine.
  final String architecture;

  /// A description of the import task.
  final String description;

  /// Indicates whether the AMI is encypted.
  final bool encrypted;

  /// The target hypervisor of the import task.
  final String hypervisor;

  /// The ID of the Amazon Machine Image (AMI) created by the import task.
  final String imageId;

  /// The task ID of the import image task.
  final String importTaskId;

  /// The identifier for the AWS Key Management Service (AWS KMS) customer
  /// master key (CMK) that was used to create the encrypted AMI.
  final String kmsKeyId;

  /// The license type of the virtual machine.
  final String licenseType;

  /// The operating system of the virtual machine.
  final String platform;

  /// The progress of the task.
  final String progress;

  /// Information about the snapshots.
  final List<SnapshotDetail> snapshotDetails;

  /// A brief status of the task.
  final String status;

  /// A detailed status message of the import task.
  final String statusMessage;

  ImportImageResult({
    this.architecture,
    this.description,
    this.encrypted,
    this.hypervisor,
    this.imageId,
    this.importTaskId,
    this.kmsKeyId,
    this.licenseType,
    this.platform,
    this.progress,
    this.snapshotDetails,
    this.status,
    this.statusMessage,
  });
  static ImportImageResult fromJson(Map<String, dynamic> json) =>
      ImportImageResult(
        architecture: json.containsKey('Architecture')
            ? json['Architecture'] as String
            : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        encrypted:
            json.containsKey('Encrypted') ? json['Encrypted'] as bool : null,
        hypervisor: json.containsKey('Hypervisor')
            ? json['Hypervisor'] as String
            : null,
        imageId: json.containsKey('ImageId') ? json['ImageId'] as String : null,
        importTaskId: json.containsKey('ImportTaskId')
            ? json['ImportTaskId'] as String
            : null,
        kmsKeyId:
            json.containsKey('KmsKeyId') ? json['KmsKeyId'] as String : null,
        licenseType: json.containsKey('LicenseType')
            ? json['LicenseType'] as String
            : null,
        platform:
            json.containsKey('Platform') ? json['Platform'] as String : null,
        progress:
            json.containsKey('Progress') ? json['Progress'] as String : null,
        snapshotDetails: json.containsKey('SnapshotDetails')
            ? (json['SnapshotDetails'] as List)
                .map((e) => SnapshotDetail.fromJson(e))
                .toList()
            : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
        statusMessage: json.containsKey('StatusMessage')
            ? json['StatusMessage'] as String
            : null,
      );
}

/// Describes an import image task.
class ImportImageTask {
  /// The architecture of the virtual machine.
  ///
  /// Valid values: `i386` | `x86_64` | `arm64`
  final String architecture;

  /// A description of the import task.
  final String description;

  /// Indicates whether the image is encrypted.
  final bool encrypted;

  /// The target hypervisor for the import task.
  ///
  /// Valid values: `xen`
  final String hypervisor;

  /// The ID of the Amazon Machine Image (AMI) of the imported virtual machine.
  final String imageId;

  /// The ID of the import image task.
  final String importTaskId;

  /// The identifier for the AWS Key Management Service (AWS KMS) customer
  /// master key (CMK) that was used to create the encrypted image.
  final String kmsKeyId;

  /// The license type of the virtual machine.
  final String licenseType;

  /// The description string for the import image task.
  final String platform;

  /// The percentage of progress of the import image task.
  final String progress;

  /// Information about the snapshots.
  final List<SnapshotDetail> snapshotDetails;

  /// A brief status for the import image task.
  final String status;

  /// A descriptive status message for the import image task.
  final String statusMessage;

  ImportImageTask({
    this.architecture,
    this.description,
    this.encrypted,
    this.hypervisor,
    this.imageId,
    this.importTaskId,
    this.kmsKeyId,
    this.licenseType,
    this.platform,
    this.progress,
    this.snapshotDetails,
    this.status,
    this.statusMessage,
  });
  static ImportImageTask fromJson(Map<String, dynamic> json) => ImportImageTask(
        architecture: json.containsKey('Architecture')
            ? json['Architecture'] as String
            : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        encrypted:
            json.containsKey('Encrypted') ? json['Encrypted'] as bool : null,
        hypervisor: json.containsKey('Hypervisor')
            ? json['Hypervisor'] as String
            : null,
        imageId: json.containsKey('ImageId') ? json['ImageId'] as String : null,
        importTaskId: json.containsKey('ImportTaskId')
            ? json['ImportTaskId'] as String
            : null,
        kmsKeyId:
            json.containsKey('KmsKeyId') ? json['KmsKeyId'] as String : null,
        licenseType: json.containsKey('LicenseType')
            ? json['LicenseType'] as String
            : null,
        platform:
            json.containsKey('Platform') ? json['Platform'] as String : null,
        progress:
            json.containsKey('Progress') ? json['Progress'] as String : null,
        snapshotDetails: json.containsKey('SnapshotDetails')
            ? (json['SnapshotDetails'] as List)
                .map((e) => SnapshotDetail.fromJson(e))
                .toList()
            : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
        statusMessage: json.containsKey('StatusMessage')
            ? json['StatusMessage'] as String
            : null,
      );
}

/// Describes the launch specification for VM import.
class ImportInstanceLaunchSpecification {
  /// Reserved.
  final String additionalInfo;

  /// The architecture of the instance.
  final String architecture;

  /// The security group IDs.
  final List<String> groupIds;

  /// The security group names.
  final List<String> groupNames;

  /// Indicates whether an instance stops or terminates when you initiate
  /// shutdown from the instance (using the operating system command for system
  /// shutdown).
  final String instanceInitiatedShutdownBehavior;

  /// The instance type. For more information about the instance types that you
  /// can import, see
  /// [Instance Types](https://docs.aws.amazon.com/vm-import/latest/userguide/vmie_prereqs.html#vmimport-instance-types)
  /// in the VM Import/Export User Guide.
  final String instanceType;

  /// Indicates whether monitoring is enabled.
  final bool monitoring;

  /// The placement information for the instance.
  final Placement placement;

  /// [EC2-VPC] An available IP address from the IP address range of the subnet.
  final String privateIpAddress;

  /// [EC2-VPC] The ID of the subnet in which to launch the instance.
  final String subnetId;

  /// The Base64-encoded user data to make available to the instance.
  final UserData userData;

  ImportInstanceLaunchSpecification({
    this.additionalInfo,
    this.architecture,
    this.groupIds,
    this.groupNames,
    this.instanceInitiatedShutdownBehavior,
    this.instanceType,
    this.monitoring,
    this.placement,
    this.privateIpAddress,
    this.subnetId,
    this.userData,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

class ImportInstanceResult {
  /// Information about the conversion task.
  final ConversionTask conversionTask;

  ImportInstanceResult({
    this.conversionTask,
  });
  static ImportInstanceResult fromJson(Map<String, dynamic> json) =>
      ImportInstanceResult(
        conversionTask: json.containsKey('ConversionTask')
            ? ConversionTask.fromJson(json['ConversionTask'])
            : null,
      );
}

/// Describes an import instance task.
class ImportInstanceTaskDetails {
  /// A description of the task.
  final String description;

  /// The ID of the instance.
  final String instanceId;

  /// The instance operating system.
  final String platform;

  /// The volumes.
  final List<ImportInstanceVolumeDetailItem> volumes;

  ImportInstanceTaskDetails({
    this.description,
    this.instanceId,
    this.platform,
    this.volumes,
  });
  static ImportInstanceTaskDetails fromJson(Map<String, dynamic> json) =>
      ImportInstanceTaskDetails(
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        platform:
            json.containsKey('Platform') ? json['Platform'] as String : null,
        volumes: json.containsKey('Volumes')
            ? (json['Volumes'] as List)
                .map((e) => ImportInstanceVolumeDetailItem.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes an import volume task.
class ImportInstanceVolumeDetailItem {
  /// The Availability Zone where the resulting instance will reside.
  final String availabilityZone;

  /// The number of bytes converted so far.
  final BigInt bytesConverted;

  /// A description of the task.
  final String description;

  /// The image.
  final DiskImageDescription image;

  /// The status of the import of this particular disk image.
  final String status;

  /// The status information or errors related to the disk image.
  final String statusMessage;

  /// The volume.
  final DiskImageVolumeDescription volume;

  ImportInstanceVolumeDetailItem({
    this.availabilityZone,
    this.bytesConverted,
    this.description,
    this.image,
    this.status,
    this.statusMessage,
    this.volume,
  });
  static ImportInstanceVolumeDetailItem fromJson(Map<String, dynamic> json) =>
      ImportInstanceVolumeDetailItem(
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        bytesConverted: json.containsKey('BytesConverted')
            ? BigInt.from(json['BytesConverted'])
            : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        image: json.containsKey('Image')
            ? DiskImageDescription.fromJson(json['Image'])
            : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
        statusMessage: json.containsKey('StatusMessage')
            ? json['StatusMessage'] as String
            : null,
        volume: json.containsKey('Volume')
            ? DiskImageVolumeDescription.fromJson(json['Volume'])
            : null,
      );
}

class ImportKeyPairResult {
  /// The MD5 public key fingerprint as specified in section 4 of RFC 4716.
  final String keyFingerprint;

  /// The key pair name you provided.
  final String keyName;

  ImportKeyPairResult({
    this.keyFingerprint,
    this.keyName,
  });
  static ImportKeyPairResult fromJson(Map<String, dynamic> json) =>
      ImportKeyPairResult(
        keyFingerprint: json.containsKey('KeyFingerprint')
            ? json['KeyFingerprint'] as String
            : null,
        keyName: json.containsKey('KeyName') ? json['KeyName'] as String : null,
      );
}

class ImportSnapshotResult {
  /// A description of the import snapshot task.
  final String description;

  /// The ID of the import snapshot task.
  final String importTaskId;

  /// Information about the import snapshot task.
  final SnapshotTaskDetail snapshotTaskDetail;

  ImportSnapshotResult({
    this.description,
    this.importTaskId,
    this.snapshotTaskDetail,
  });
  static ImportSnapshotResult fromJson(Map<String, dynamic> json) =>
      ImportSnapshotResult(
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        importTaskId: json.containsKey('ImportTaskId')
            ? json['ImportTaskId'] as String
            : null,
        snapshotTaskDetail: json.containsKey('SnapshotTaskDetail')
            ? SnapshotTaskDetail.fromJson(json['SnapshotTaskDetail'])
            : null,
      );
}

/// Describes an import snapshot task.
class ImportSnapshotTask {
  /// A description of the import snapshot task.
  final String description;

  /// The ID of the import snapshot task.
  final String importTaskId;

  /// Describes an import snapshot task.
  final SnapshotTaskDetail snapshotTaskDetail;

  ImportSnapshotTask({
    this.description,
    this.importTaskId,
    this.snapshotTaskDetail,
  });
  static ImportSnapshotTask fromJson(Map<String, dynamic> json) =>
      ImportSnapshotTask(
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        importTaskId: json.containsKey('ImportTaskId')
            ? json['ImportTaskId'] as String
            : null,
        snapshotTaskDetail: json.containsKey('SnapshotTaskDetail')
            ? SnapshotTaskDetail.fromJson(json['SnapshotTaskDetail'])
            : null,
      );
}

class ImportVolumeResult {
  /// Information about the conversion task.
  final ConversionTask conversionTask;

  ImportVolumeResult({
    this.conversionTask,
  });
  static ImportVolumeResult fromJson(Map<String, dynamic> json) =>
      ImportVolumeResult(
        conversionTask: json.containsKey('ConversionTask')
            ? ConversionTask.fromJson(json['ConversionTask'])
            : null,
      );
}

/// Describes an import volume task.
class ImportVolumeTaskDetails {
  /// The Availability Zone where the resulting volume will reside.
  final String availabilityZone;

  /// The number of bytes converted so far.
  final BigInt bytesConverted;

  /// The description you provided when starting the import volume task.
  final String description;

  /// The image.
  final DiskImageDescription image;

  /// The volume.
  final DiskImageVolumeDescription volume;

  ImportVolumeTaskDetails({
    this.availabilityZone,
    this.bytesConverted,
    this.description,
    this.image,
    this.volume,
  });
  static ImportVolumeTaskDetails fromJson(Map<String, dynamic> json) =>
      ImportVolumeTaskDetails(
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        bytesConverted: json.containsKey('BytesConverted')
            ? BigInt.from(json['BytesConverted'])
            : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        image: json.containsKey('Image')
            ? DiskImageDescription.fromJson(json['Image'])
            : null,
        volume: json.containsKey('Volume')
            ? DiskImageVolumeDescription.fromJson(json['Volume'])
            : null,
      );
}

/// Describes an instance.
class Instance {
  /// The AMI launch index, which can be used to find this instance in the
  /// launch group.
  final int amiLaunchIndex;

  /// The ID of the AMI used to launch the instance.
  final String imageId;

  /// The ID of the instance.
  final String instanceId;

  /// The instance type.
  final String instanceType;

  /// The kernel associated with this instance, if applicable.
  final String kernelId;

  /// The name of the key pair, if this instance was launched with an associated
  /// key pair.
  final String keyName;

  /// The time the instance was launched.
  final DateTime launchTime;

  /// The monitoring for the instance.
  final Monitoring monitoring;

  /// The location where the instance launched, if applicable.
  final Placement placement;

  /// The value is `Windows` for Windows instances; otherwise blank.
  final String platform;

  /// (IPv4 only) The private DNS hostname name assigned to the instance. This
  /// DNS hostname can only be used inside the Amazon EC2 network. This name is
  /// not available until the instance enters the `running` state.
  ///
  /// [EC2-VPC] The Amazon-provided DNS server resolves Amazon-provided private
  /// DNS hostnames if you've enabled DNS resolution and DNS hostnames in your
  /// VPC. If you are not using the Amazon-provided DNS server in your VPC, your
  /// custom domain name servers must resolve the hostname as appropriate.
  final String privateDnsName;

  /// The private IPv4 address assigned to the instance.
  final String privateIpAddress;

  /// The product codes attached to this instance, if applicable.
  final List<ProductCode> productCodes;

  /// (IPv4 only) The public DNS name assigned to the instance. This name is not
  /// available until the instance enters the `running` state. For EC2-VPC, this
  /// name is only available if you've enabled DNS hostnames for your VPC.
  final String publicDnsName;

  /// The public IPv4 address assigned to the instance, if applicable.
  final String publicIpAddress;

  /// The RAM disk associated with this instance, if applicable.
  final String ramdiskId;

  /// The current state of the instance.
  final InstanceState state;

  /// The reason for the most recent state transition. This might be an empty
  /// string.
  final String stateTransitionReason;

  /// [EC2-VPC] The ID of the subnet in which the instance is running.
  final String subnetId;

  /// [EC2-VPC] The ID of the VPC in which the instance is running.
  final String vpcId;

  /// The architecture of the image.
  final String architecture;

  /// Any block device mapping entries for the instance.
  final List<InstanceBlockDeviceMapping> blockDeviceMappings;

  /// The idempotency token you provided when you launched the instance, if
  /// applicable.
  final String clientToken;

  /// Indicates whether the instance is optimized for Amazon EBS I/O. This
  /// optimization provides dedicated throughput to Amazon EBS and an optimized
  /// configuration stack to provide optimal I/O performance. This optimization
  /// isn't available with all instance types. Additional usage charges apply
  /// when using an EBS Optimized instance.
  final bool ebsOptimized;

  /// Specifies whether enhanced networking with ENA is enabled.
  final bool enaSupport;

  /// The hypervisor type of the instance.
  final String hypervisor;

  /// The IAM instance profile associated with the instance, if applicable.
  final IamInstanceProfile iamInstanceProfile;

  /// Indicates whether this is a Spot Instance or a Scheduled Instance.
  final String instanceLifecycle;

  /// The Elastic GPU associated with the instance.
  final List<ElasticGpuAssociation> elasticGpuAssociations;

  ///  The elastic inference accelerator associated with the instance.
  final List<ElasticInferenceAcceleratorAssociation>
      elasticInferenceAcceleratorAssociations;

  /// [EC2-VPC] The network interfaces for the instance.
  final List<InstanceNetworkInterface> networkInterfaces;

  /// The device name of the root device volume (for example, `/dev/sda1`).
  final String rootDeviceName;

  /// The root device type used by the AMI. The AMI can use an EBS volume or an
  /// instance store volume.
  final String rootDeviceType;

  /// The security groups for the instance.
  final List<GroupIdentifier> securityGroups;

  /// Specifies whether to enable an instance launched in a VPC to perform NAT.
  /// This controls whether source/destination checking is enabled on the
  /// instance. A value of `true` means that checking is enabled, and `false`
  /// means that checking is disabled. The value must be `false` for the
  /// instance to perform NAT. For more information, see
  /// [NAT Instances](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_NAT_Instance.html)
  /// in the _Amazon Virtual Private Cloud User Guide_.
  final bool sourceDestCheck;

  /// If the request is a Spot Instance request, the ID of the request.
  final String spotInstanceRequestId;

  /// Specifies whether enhanced networking with the Intel 82599 Virtual
  /// Function interface is enabled.
  final String sriovNetSupport;

  /// The reason for the most recent state transition.
  final StateReason stateReason;

  /// Any tags assigned to the instance.
  final List<Tag> tags;

  /// The virtualization type of the instance.
  final String virtualizationType;

  /// The CPU options for the instance.
  final CpuOptions cpuOptions;

  /// The ID of the Capacity Reservation.
  final String capacityReservationId;

  /// Information about the Capacity Reservation targeting option.
  final CapacityReservationSpecificationResponse
      capacityReservationSpecification;

  /// Indicates whether the instance is enabled for hibernation.
  final HibernationOptions hibernationOptions;

  /// The license configurations.
  final List<LicenseConfiguration> licenses;

  Instance({
    this.amiLaunchIndex,
    this.imageId,
    this.instanceId,
    this.instanceType,
    this.kernelId,
    this.keyName,
    this.launchTime,
    this.monitoring,
    this.placement,
    this.platform,
    this.privateDnsName,
    this.privateIpAddress,
    this.productCodes,
    this.publicDnsName,
    this.publicIpAddress,
    this.ramdiskId,
    this.state,
    this.stateTransitionReason,
    this.subnetId,
    this.vpcId,
    this.architecture,
    this.blockDeviceMappings,
    this.clientToken,
    this.ebsOptimized,
    this.enaSupport,
    this.hypervisor,
    this.iamInstanceProfile,
    this.instanceLifecycle,
    this.elasticGpuAssociations,
    this.elasticInferenceAcceleratorAssociations,
    this.networkInterfaces,
    this.rootDeviceName,
    this.rootDeviceType,
    this.securityGroups,
    this.sourceDestCheck,
    this.spotInstanceRequestId,
    this.sriovNetSupport,
    this.stateReason,
    this.tags,
    this.virtualizationType,
    this.cpuOptions,
    this.capacityReservationId,
    this.capacityReservationSpecification,
    this.hibernationOptions,
    this.licenses,
  });
  static Instance fromJson(Map<String, dynamic> json) => Instance(
        amiLaunchIndex: json.containsKey('AmiLaunchIndex')
            ? json['AmiLaunchIndex'] as int
            : null,
        imageId: json.containsKey('ImageId') ? json['ImageId'] as String : null,
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        kernelId:
            json.containsKey('KernelId') ? json['KernelId'] as String : null,
        keyName: json.containsKey('KeyName') ? json['KeyName'] as String : null,
        launchTime: json.containsKey('LaunchTime')
            ? DateTime.parse(json['LaunchTime'])
            : null,
        monitoring: json.containsKey('Monitoring')
            ? Monitoring.fromJson(json['Monitoring'])
            : null,
        placement: json.containsKey('Placement')
            ? Placement.fromJson(json['Placement'])
            : null,
        platform:
            json.containsKey('Platform') ? json['Platform'] as String : null,
        privateDnsName: json.containsKey('PrivateDnsName')
            ? json['PrivateDnsName'] as String
            : null,
        privateIpAddress: json.containsKey('PrivateIpAddress')
            ? json['PrivateIpAddress'] as String
            : null,
        productCodes: json.containsKey('ProductCodes')
            ? (json['ProductCodes'] as List)
                .map((e) => ProductCode.fromJson(e))
                .toList()
            : null,
        publicDnsName: json.containsKey('PublicDnsName')
            ? json['PublicDnsName'] as String
            : null,
        publicIpAddress: json.containsKey('PublicIpAddress')
            ? json['PublicIpAddress'] as String
            : null,
        ramdiskId:
            json.containsKey('RamdiskId') ? json['RamdiskId'] as String : null,
        state: json.containsKey('State')
            ? InstanceState.fromJson(json['State'])
            : null,
        stateTransitionReason: json.containsKey('StateTransitionReason')
            ? json['StateTransitionReason'] as String
            : null,
        subnetId:
            json.containsKey('SubnetId') ? json['SubnetId'] as String : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
        architecture: json.containsKey('Architecture')
            ? json['Architecture'] as String
            : null,
        blockDeviceMappings: json.containsKey('BlockDeviceMappings')
            ? (json['BlockDeviceMappings'] as List)
                .map((e) => InstanceBlockDeviceMapping.fromJson(e))
                .toList()
            : null,
        clientToken: json.containsKey('ClientToken')
            ? json['ClientToken'] as String
            : null,
        ebsOptimized: json.containsKey('EbsOptimized')
            ? json['EbsOptimized'] as bool
            : null,
        enaSupport:
            json.containsKey('EnaSupport') ? json['EnaSupport'] as bool : null,
        hypervisor: json.containsKey('Hypervisor')
            ? json['Hypervisor'] as String
            : null,
        iamInstanceProfile: json.containsKey('IamInstanceProfile')
            ? IamInstanceProfile.fromJson(json['IamInstanceProfile'])
            : null,
        instanceLifecycle: json.containsKey('InstanceLifecycle')
            ? json['InstanceLifecycle'] as String
            : null,
        elasticGpuAssociations: json.containsKey('ElasticGpuAssociations')
            ? (json['ElasticGpuAssociations'] as List)
                .map((e) => ElasticGpuAssociation.fromJson(e))
                .toList()
            : null,
        elasticInferenceAcceleratorAssociations: json
                .containsKey('ElasticInferenceAcceleratorAssociations')
            ? (json['ElasticInferenceAcceleratorAssociations'] as List)
                .map((e) => ElasticInferenceAcceleratorAssociation.fromJson(e))
                .toList()
            : null,
        networkInterfaces: json.containsKey('NetworkInterfaces')
            ? (json['NetworkInterfaces'] as List)
                .map((e) => InstanceNetworkInterface.fromJson(e))
                .toList()
            : null,
        rootDeviceName: json.containsKey('RootDeviceName')
            ? json['RootDeviceName'] as String
            : null,
        rootDeviceType: json.containsKey('RootDeviceType')
            ? json['RootDeviceType'] as String
            : null,
        securityGroups: json.containsKey('SecurityGroups')
            ? (json['SecurityGroups'] as List)
                .map((e) => GroupIdentifier.fromJson(e))
                .toList()
            : null,
        sourceDestCheck: json.containsKey('SourceDestCheck')
            ? json['SourceDestCheck'] as bool
            : null,
        spotInstanceRequestId: json.containsKey('SpotInstanceRequestId')
            ? json['SpotInstanceRequestId'] as String
            : null,
        sriovNetSupport: json.containsKey('SriovNetSupport')
            ? json['SriovNetSupport'] as String
            : null,
        stateReason: json.containsKey('StateReason')
            ? StateReason.fromJson(json['StateReason'])
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        virtualizationType: json.containsKey('VirtualizationType')
            ? json['VirtualizationType'] as String
            : null,
        cpuOptions: json.containsKey('CpuOptions')
            ? CpuOptions.fromJson(json['CpuOptions'])
            : null,
        capacityReservationId: json.containsKey('CapacityReservationId')
            ? json['CapacityReservationId'] as String
            : null,
        capacityReservationSpecification:
            json.containsKey('CapacityReservationSpecification')
                ? CapacityReservationSpecificationResponse.fromJson(
                    json['CapacityReservationSpecification'])
                : null,
        hibernationOptions: json.containsKey('HibernationOptions')
            ? HibernationOptions.fromJson(json['HibernationOptions'])
            : null,
        licenses: json.containsKey('Licenses')
            ? (json['Licenses'] as List)
                .map((e) => LicenseConfiguration.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes an instance attribute.
class InstanceAttribute {
  /// The security groups associated with the instance.
  final List<GroupIdentifier> groups;

  /// The block device mapping of the instance.
  final List<InstanceBlockDeviceMapping> blockDeviceMappings;

  /// If the value is `true`, you can't terminate the instance through the
  /// Amazon EC2 console, CLI, or API; otherwise, you can.
  final AttributeBooleanValue disableApiTermination;

  /// Indicates whether enhanced networking with ENA is enabled.
  final AttributeBooleanValue enaSupport;

  /// Indicates whether the instance is optimized for Amazon EBS I/O.
  final AttributeBooleanValue ebsOptimized;

  /// The ID of the instance.
  final String instanceId;

  /// Indicates whether an instance stops or terminates when you initiate
  /// shutdown from the instance (using the operating system command for system
  /// shutdown).
  final AttributeValue instanceInitiatedShutdownBehavior;

  /// The instance type.
  final AttributeValue instanceType;

  /// The kernel ID.
  final AttributeValue kernelId;

  /// A list of product codes.
  final List<ProductCode> productCodes;

  /// The RAM disk ID.
  final AttributeValue ramdiskId;

  /// The device name of the root device volume (for example, `/dev/sda1`).
  final AttributeValue rootDeviceName;

  /// Indicates whether source/destination checking is enabled. A value of
  /// `true` means that checking is enabled, and `false` means that checking is
  /// disabled. This value must be `false` for a NAT instance to perform NAT.
  final AttributeBooleanValue sourceDestCheck;

  /// Indicates whether enhanced networking with the Intel 82599 Virtual
  /// Function interface is enabled.
  final AttributeValue sriovNetSupport;

  /// The user data.
  final AttributeValue userData;

  InstanceAttribute({
    this.groups,
    this.blockDeviceMappings,
    this.disableApiTermination,
    this.enaSupport,
    this.ebsOptimized,
    this.instanceId,
    this.instanceInitiatedShutdownBehavior,
    this.instanceType,
    this.kernelId,
    this.productCodes,
    this.ramdiskId,
    this.rootDeviceName,
    this.sourceDestCheck,
    this.sriovNetSupport,
    this.userData,
  });
  static InstanceAttribute fromJson(Map<String, dynamic> json) =>
      InstanceAttribute(
        groups: json.containsKey('Groups')
            ? (json['Groups'] as List)
                .map((e) => GroupIdentifier.fromJson(e))
                .toList()
            : null,
        blockDeviceMappings: json.containsKey('BlockDeviceMappings')
            ? (json['BlockDeviceMappings'] as List)
                .map((e) => InstanceBlockDeviceMapping.fromJson(e))
                .toList()
            : null,
        disableApiTermination: json.containsKey('DisableApiTermination')
            ? AttributeBooleanValue.fromJson(json['DisableApiTermination'])
            : null,
        enaSupport: json.containsKey('EnaSupport')
            ? AttributeBooleanValue.fromJson(json['EnaSupport'])
            : null,
        ebsOptimized: json.containsKey('EbsOptimized')
            ? AttributeBooleanValue.fromJson(json['EbsOptimized'])
            : null,
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        instanceInitiatedShutdownBehavior: json
                .containsKey('InstanceInitiatedShutdownBehavior')
            ? AttributeValue.fromJson(json['InstanceInitiatedShutdownBehavior'])
            : null,
        instanceType: json.containsKey('InstanceType')
            ? AttributeValue.fromJson(json['InstanceType'])
            : null,
        kernelId: json.containsKey('KernelId')
            ? AttributeValue.fromJson(json['KernelId'])
            : null,
        productCodes: json.containsKey('ProductCodes')
            ? (json['ProductCodes'] as List)
                .map((e) => ProductCode.fromJson(e))
                .toList()
            : null,
        ramdiskId: json.containsKey('RamdiskId')
            ? AttributeValue.fromJson(json['RamdiskId'])
            : null,
        rootDeviceName: json.containsKey('RootDeviceName')
            ? AttributeValue.fromJson(json['RootDeviceName'])
            : null,
        sourceDestCheck: json.containsKey('SourceDestCheck')
            ? AttributeBooleanValue.fromJson(json['SourceDestCheck'])
            : null,
        sriovNetSupport: json.containsKey('SriovNetSupport')
            ? AttributeValue.fromJson(json['SriovNetSupport'])
            : null,
        userData: json.containsKey('UserData')
            ? AttributeValue.fromJson(json['UserData'])
            : null,
      );
}

/// Describes a block device mapping.
class InstanceBlockDeviceMapping {
  /// The device name (for example, `/dev/sdh` or `xvdh`).
  final String deviceName;

  /// Parameters used to automatically set up EBS volumes when the instance is
  /// launched.
  final EbsInstanceBlockDevice ebs;

  InstanceBlockDeviceMapping({
    this.deviceName,
    this.ebs,
  });
  static InstanceBlockDeviceMapping fromJson(Map<String, dynamic> json) =>
      InstanceBlockDeviceMapping(
        deviceName: json.containsKey('DeviceName')
            ? json['DeviceName'] as String
            : null,
        ebs: json.containsKey('Ebs')
            ? EbsInstanceBlockDevice.fromJson(json['Ebs'])
            : null,
      );
}

/// Describes a block device mapping entry.
class InstanceBlockDeviceMappingSpecification {
  /// The device name (for example, `/dev/sdh` or `xvdh`).
  final String deviceName;

  /// Parameters used to automatically set up EBS volumes when the instance is
  /// launched.
  final EbsInstanceBlockDeviceSpecification ebs;

  /// suppress the specified device included in the block device mapping.
  final String noDevice;

  /// The virtual device name.
  final String virtualName;

  InstanceBlockDeviceMappingSpecification({
    this.deviceName,
    this.ebs,
    this.noDevice,
    this.virtualName,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Information about the instance type that the Dedicated Host supports.
class InstanceCapacity {
  /// The number of instances that can still be launched onto the Dedicated
  /// Host.
  final int availableCapacity;

  /// The instance type size supported by the Dedicated Host.
  final String instanceType;

  /// The total number of instances that can be launched onto the Dedicated
  /// Host.
  final int totalCapacity;

  InstanceCapacity({
    this.availableCapacity,
    this.instanceType,
    this.totalCapacity,
  });
  static InstanceCapacity fromJson(Map<String, dynamic> json) =>
      InstanceCapacity(
        availableCapacity: json.containsKey('AvailableCapacity')
            ? json['AvailableCapacity'] as int
            : null,
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        totalCapacity: json.containsKey('TotalCapacity')
            ? json['TotalCapacity'] as int
            : null,
      );
}

/// Describes a Reserved Instance listing state.
class InstanceCount {
  /// The number of listed Reserved Instances in the state specified by the
  /// `state`.
  final int instanceCount;

  /// The states of the listed Reserved Instances.
  final String state;

  InstanceCount({
    this.instanceCount,
    this.state,
  });
  static InstanceCount fromJson(Map<String, dynamic> json) => InstanceCount(
        instanceCount: json.containsKey('InstanceCount')
            ? json['InstanceCount'] as int
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
      );
}

/// Describes the credit option for CPU usage of a T2 or T3 instance.
class InstanceCreditSpecification {
  /// The ID of the instance.
  final String instanceId;

  /// The credit option for CPU usage of the instance. Valid values are
  /// `standard` and `unlimited`.
  final String cpuCredits;

  InstanceCreditSpecification({
    this.instanceId,
    this.cpuCredits,
  });
  static InstanceCreditSpecification fromJson(Map<String, dynamic> json) =>
      InstanceCreditSpecification(
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        cpuCredits: json.containsKey('CpuCredits')
            ? json['CpuCredits'] as String
            : null,
      );
}

/// Describes the credit option for CPU usage of a T2 or T3 instance.
class InstanceCreditSpecificationRequest {
  /// The ID of the instance.
  final String instanceId;

  /// The credit option for CPU usage of the instance. Valid values are
  /// `standard` and `unlimited`.
  final String cpuCredits;

  InstanceCreditSpecificationRequest({
    this.instanceId,
    this.cpuCredits,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes an instance to export.
class InstanceExportDetails {
  /// The ID of the resource being exported.
  final String instanceId;

  /// The target virtualization environment.
  final String targetEnvironment;

  InstanceExportDetails({
    this.instanceId,
    this.targetEnvironment,
  });
  static InstanceExportDetails fromJson(Map<String, dynamic> json) =>
      InstanceExportDetails(
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        targetEnvironment: json.containsKey('TargetEnvironment')
            ? json['TargetEnvironment'] as String
            : null,
      );
}

/// Describes an IPv6 address.
class InstanceIpv6Address {
  /// The IPv6 address.
  final String ipv6Address;

  InstanceIpv6Address({
    this.ipv6Address,
  });
  static InstanceIpv6Address fromJson(Map<String, dynamic> json) =>
      InstanceIpv6Address(
        ipv6Address: json.containsKey('Ipv6Address')
            ? json['Ipv6Address'] as String
            : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes an IPv6 address.
class InstanceIpv6AddressRequest {
  /// The IPv6 address.
  final String ipv6Address;

  InstanceIpv6AddressRequest({
    this.ipv6Address,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the market (purchasing) option for the instances.
class InstanceMarketOptionsRequest {
  /// The market type.
  final String marketType;

  /// The options for Spot Instances.
  final SpotMarketOptions spotOptions;

  InstanceMarketOptionsRequest({
    this.marketType,
    this.spotOptions,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the monitoring of an instance.
class InstanceMonitoring {
  /// The ID of the instance.
  final String instanceId;

  /// The monitoring for the instance.
  final Monitoring monitoring;

  InstanceMonitoring({
    this.instanceId,
    this.monitoring,
  });
  static InstanceMonitoring fromJson(Map<String, dynamic> json) =>
      InstanceMonitoring(
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        monitoring: json.containsKey('Monitoring')
            ? Monitoring.fromJson(json['Monitoring'])
            : null,
      );
}

/// Describes a network interface.
class InstanceNetworkInterface {
  /// The association information for an Elastic IPv4 associated with the
  /// network interface.
  final InstanceNetworkInterfaceAssociation association;

  /// The network interface attachment.
  final InstanceNetworkInterfaceAttachment attachment;

  /// The description.
  final String description;

  /// One or more security groups.
  final List<GroupIdentifier> groups;

  /// One or more IPv6 addresses associated with the network interface.
  final List<InstanceIpv6Address> ipv6Addresses;

  /// The MAC address.
  final String macAddress;

  /// The ID of the network interface.
  final String networkInterfaceId;

  /// The ID of the AWS account that created the network interface.
  final String ownerId;

  /// The private DNS name.
  final String privateDnsName;

  /// The IPv4 address of the network interface within the subnet.
  final String privateIpAddress;

  /// One or more private IPv4 addresses associated with the network interface.
  final List<InstancePrivateIpAddress> privateIpAddresses;

  /// Indicates whether to validate network traffic to or from this network
  /// interface.
  final bool sourceDestCheck;

  /// The status of the network interface.
  final String status;

  /// The ID of the subnet.
  final String subnetId;

  /// The ID of the VPC.
  final String vpcId;

  /// Describes the type of network interface.
  ///
  /// Valid values: `interface` | `efa`
  final String interfaceType;

  InstanceNetworkInterface({
    this.association,
    this.attachment,
    this.description,
    this.groups,
    this.ipv6Addresses,
    this.macAddress,
    this.networkInterfaceId,
    this.ownerId,
    this.privateDnsName,
    this.privateIpAddress,
    this.privateIpAddresses,
    this.sourceDestCheck,
    this.status,
    this.subnetId,
    this.vpcId,
    this.interfaceType,
  });
  static InstanceNetworkInterface fromJson(Map<String, dynamic> json) =>
      InstanceNetworkInterface(
        association: json.containsKey('Association')
            ? InstanceNetworkInterfaceAssociation.fromJson(json['Association'])
            : null,
        attachment: json.containsKey('Attachment')
            ? InstanceNetworkInterfaceAttachment.fromJson(json['Attachment'])
            : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        groups: json.containsKey('Groups')
            ? (json['Groups'] as List)
                .map((e) => GroupIdentifier.fromJson(e))
                .toList()
            : null,
        ipv6Addresses: json.containsKey('Ipv6Addresses')
            ? (json['Ipv6Addresses'] as List)
                .map((e) => InstanceIpv6Address.fromJson(e))
                .toList()
            : null,
        macAddress: json.containsKey('MacAddress')
            ? json['MacAddress'] as String
            : null,
        networkInterfaceId: json.containsKey('NetworkInterfaceId')
            ? json['NetworkInterfaceId'] as String
            : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        privateDnsName: json.containsKey('PrivateDnsName')
            ? json['PrivateDnsName'] as String
            : null,
        privateIpAddress: json.containsKey('PrivateIpAddress')
            ? json['PrivateIpAddress'] as String
            : null,
        privateIpAddresses: json.containsKey('PrivateIpAddresses')
            ? (json['PrivateIpAddresses'] as List)
                .map((e) => InstancePrivateIpAddress.fromJson(e))
                .toList()
            : null,
        sourceDestCheck: json.containsKey('SourceDestCheck')
            ? json['SourceDestCheck'] as bool
            : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
        subnetId:
            json.containsKey('SubnetId') ? json['SubnetId'] as String : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
        interfaceType: json.containsKey('InterfaceType')
            ? json['InterfaceType'] as String
            : null,
      );
}

/// Describes association information for an Elastic IP address (IPv4).
class InstanceNetworkInterfaceAssociation {
  /// The ID of the owner of the Elastic IP address.
  final String ipOwnerId;

  /// The public DNS name.
  final String publicDnsName;

  /// The public IP address or Elastic IP address bound to the network
  /// interface.
  final String publicIp;

  InstanceNetworkInterfaceAssociation({
    this.ipOwnerId,
    this.publicDnsName,
    this.publicIp,
  });
  static InstanceNetworkInterfaceAssociation fromJson(
          Map<String, dynamic> json) =>
      InstanceNetworkInterfaceAssociation(
        ipOwnerId:
            json.containsKey('IpOwnerId') ? json['IpOwnerId'] as String : null,
        publicDnsName: json.containsKey('PublicDnsName')
            ? json['PublicDnsName'] as String
            : null,
        publicIp:
            json.containsKey('PublicIp') ? json['PublicIp'] as String : null,
      );
}

/// Describes a network interface attachment.
class InstanceNetworkInterfaceAttachment {
  /// The time stamp when the attachment initiated.
  final DateTime attachTime;

  /// The ID of the network interface attachment.
  final String attachmentId;

  /// Indicates whether the network interface is deleted when the instance is
  /// terminated.
  final bool deleteOnTermination;

  /// The index of the device on the instance for the network interface
  /// attachment.
  final int deviceIndex;

  /// The attachment state.
  final String status;

  InstanceNetworkInterfaceAttachment({
    this.attachTime,
    this.attachmentId,
    this.deleteOnTermination,
    this.deviceIndex,
    this.status,
  });
  static InstanceNetworkInterfaceAttachment fromJson(
          Map<String, dynamic> json) =>
      InstanceNetworkInterfaceAttachment(
        attachTime: json.containsKey('AttachTime')
            ? DateTime.parse(json['AttachTime'])
            : null,
        attachmentId: json.containsKey('AttachmentId')
            ? json['AttachmentId'] as String
            : null,
        deleteOnTermination: json.containsKey('DeleteOnTermination')
            ? json['DeleteOnTermination'] as bool
            : null,
        deviceIndex:
            json.containsKey('DeviceIndex') ? json['DeviceIndex'] as int : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
      );
}

/// Describes a network interface.
class InstanceNetworkInterfaceSpecification {
  /// Indicates whether to assign a public IPv4 address to an instance you
  /// launch in a VPC. The public IP address can only be assigned to a network
  /// interface for eth0, and can only be assigned to a new network interface,
  /// not an existing one. You cannot specify more than one network interface in
  /// the request. If launching into a default subnet, the default value is
  /// `true`.
  final bool associatePublicIpAddress;

  /// If set to `true`, the interface is deleted when the instance is
  /// terminated. You can specify `true` only if creating a new network
  /// interface when launching an instance.
  final bool deleteOnTermination;

  /// The description of the network interface. Applies only if creating a
  /// network interface when launching an instance.
  final String description;

  /// The position of the network interface in the attachment order. A primary
  /// network interface has a device index of 0.
  ///
  /// If you specify a network interface when launching an instance, you must
  /// specify the device index.
  final int deviceIndex;

  /// The IDs of the security groups for the network interface. Applies only if
  /// creating a network interface when launching an instance.
  final List<String> groups;

  /// A number of IPv6 addresses to assign to the network interface. Amazon EC2
  /// chooses the IPv6 addresses from the range of the subnet. You cannot
  /// specify this option and the option to assign specific IPv6 addresses in
  /// the same request. You can specify this option if you've specified a
  /// minimum number of instances to launch.
  final int ipv6AddressCount;

  /// One or more IPv6 addresses to assign to the network interface. You cannot
  /// specify this option and the option to assign a number of IPv6 addresses in
  /// the same request. You cannot specify this option if you've specified a
  /// minimum number of instances to launch.
  final List<InstanceIpv6Address> ipv6Addresses;

  /// The ID of the network interface.
  final String networkInterfaceId;

  /// The private IPv4 address of the network interface. Applies only if
  /// creating a network interface when launching an instance. You cannot
  /// specify this option if you're launching more than one instance in a
  /// [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html)
  /// request.
  final String privateIpAddress;

  /// One or more private IPv4 addresses to assign to the network interface.
  /// Only one private IPv4 address can be designated as primary. You cannot
  /// specify this option if you're launching more than one instance in a
  /// [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html)
  /// request.
  final List<PrivateIpAddressSpecification> privateIpAddresses;

  /// The number of secondary private IPv4 addresses. You can't specify this
  /// option and specify more than one private IP address using the private IP
  /// addresses option. You cannot specify this option if you're launching more
  /// than one instance in a
  /// [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html)
  /// request.
  final int secondaryPrivateIpAddressCount;

  /// The ID of the subnet associated with the network interface. Applies only
  /// if creating a network interface when launching an instance.
  final String subnetId;

  /// The type of network interface. To create an Elastic Fabric Adapter (EFA),
  /// specify `efa`. For more information, see
  /// [Elastic Fabric Adapter](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// If you are not creating an EFA, specify `interface` or omit this
  /// parameter.
  ///
  /// Valid values: `interface` | `efa`
  final String interfaceType;

  InstanceNetworkInterfaceSpecification({
    this.associatePublicIpAddress,
    this.deleteOnTermination,
    this.description,
    this.deviceIndex,
    this.groups,
    this.ipv6AddressCount,
    this.ipv6Addresses,
    this.networkInterfaceId,
    this.privateIpAddress,
    this.privateIpAddresses,
    this.secondaryPrivateIpAddressCount,
    this.subnetId,
    this.interfaceType,
  });
  static InstanceNetworkInterfaceSpecification fromJson(
          Map<String, dynamic> json) =>
      InstanceNetworkInterfaceSpecification(
        associatePublicIpAddress: json.containsKey('AssociatePublicIpAddress')
            ? json['AssociatePublicIpAddress'] as bool
            : null,
        deleteOnTermination: json.containsKey('DeleteOnTermination')
            ? json['DeleteOnTermination'] as bool
            : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        deviceIndex:
            json.containsKey('DeviceIndex') ? json['DeviceIndex'] as int : null,
        groups: json.containsKey('Groups')
            ? (json['Groups'] as List).map((e) => e as String).toList()
            : null,
        ipv6AddressCount: json.containsKey('Ipv6AddressCount')
            ? json['Ipv6AddressCount'] as int
            : null,
        ipv6Addresses: json.containsKey('Ipv6Addresses')
            ? (json['Ipv6Addresses'] as List)
                .map((e) => InstanceIpv6Address.fromJson(e))
                .toList()
            : null,
        networkInterfaceId: json.containsKey('NetworkInterfaceId')
            ? json['NetworkInterfaceId'] as String
            : null,
        privateIpAddress: json.containsKey('PrivateIpAddress')
            ? json['PrivateIpAddress'] as String
            : null,
        privateIpAddresses: json.containsKey('PrivateIpAddresses')
            ? (json['PrivateIpAddresses'] as List)
                .map((e) => PrivateIpAddressSpecification.fromJson(e))
                .toList()
            : null,
        secondaryPrivateIpAddressCount:
            json.containsKey('SecondaryPrivateIpAddressCount')
                ? json['SecondaryPrivateIpAddressCount'] as int
                : null,
        subnetId:
            json.containsKey('SubnetId') ? json['SubnetId'] as String : null,
        interfaceType: json.containsKey('InterfaceType')
            ? json['InterfaceType'] as String
            : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a private IPv4 address.
class InstancePrivateIpAddress {
  /// The association information for an Elastic IP address for the network
  /// interface.
  final InstanceNetworkInterfaceAssociation association;

  /// Indicates whether this IPv4 address is the primary private IP address of
  /// the network interface.
  final bool primary;

  /// The private IPv4 DNS name.
  final String privateDnsName;

  /// The private IPv4 address of the network interface.
  final String privateIpAddress;

  InstancePrivateIpAddress({
    this.association,
    this.primary,
    this.privateDnsName,
    this.privateIpAddress,
  });
  static InstancePrivateIpAddress fromJson(Map<String, dynamic> json) =>
      InstancePrivateIpAddress(
        association: json.containsKey('Association')
            ? InstanceNetworkInterfaceAssociation.fromJson(json['Association'])
            : null,
        primary: json.containsKey('Primary') ? json['Primary'] as bool : null,
        privateDnsName: json.containsKey('PrivateDnsName')
            ? json['PrivateDnsName'] as String
            : null,
        privateIpAddress: json.containsKey('PrivateIpAddress')
            ? json['PrivateIpAddress'] as String
            : null,
      );
}

/// The instance details to specify which volumes should be snapshotted.
class InstanceSpecification {
  /// The instance to specify which volumes should be snapshotted.
  final String instanceId;

  /// Excludes the root volume from being snapshotted.
  final bool excludeBootVolume;

  InstanceSpecification({
    this.instanceId,
    this.excludeBootVolume,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the current state of an instance.
class InstanceState {
  /// The state of the instance as a 16-bit unsigned integer.
  ///
  /// The high byte is all of the bits between 2^8 and (2^16)-1, which equals
  /// decimal values between 256 and 65,535. These numerical values are used for
  /// internal purposes and should be ignored.
  ///
  /// The low byte is all of the bits between 2^0 and (2^8)-1, which equals
  /// decimal values between 0 and 255.
  ///
  /// The valid values for instance-state-code will all be in the range of the
  /// low byte and they are:
  ///
  /// *    `0` : `pending`
  ///
  /// *    `16` : `running`
  ///
  /// *    `32` : `shutting-down`
  ///
  /// *    `48` : `terminated`
  ///
  /// *    `64` : `stopping`
  ///
  /// *    `80` : `stopped`
  ///
  ///
  /// You can ignore the high byte value by zeroing out all of the bits above
  /// 2^8 or 256 in decimal.
  final int code;

  /// The current state of the instance.
  final String name;

  InstanceState({
    this.code,
    this.name,
  });
  static InstanceState fromJson(Map<String, dynamic> json) => InstanceState(
        code: json.containsKey('Code') ? json['Code'] as int : null,
        name: json.containsKey('Name') ? json['Name'] as String : null,
      );
}

/// Describes an instance state change.
class InstanceStateChange {
  /// The current state of the instance.
  final InstanceState currentState;

  /// The ID of the instance.
  final String instanceId;

  /// The previous state of the instance.
  final InstanceState previousState;

  InstanceStateChange({
    this.currentState,
    this.instanceId,
    this.previousState,
  });
  static InstanceStateChange fromJson(Map<String, dynamic> json) =>
      InstanceStateChange(
        currentState: json.containsKey('CurrentState')
            ? InstanceState.fromJson(json['CurrentState'])
            : null,
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        previousState: json.containsKey('PreviousState')
            ? InstanceState.fromJson(json['PreviousState'])
            : null,
      );
}

/// Describes the status of an instance.
class InstanceStatus {
  /// The Availability Zone of the instance.
  final String availabilityZone;

  /// Any scheduled events associated with the instance.
  final List<InstanceStatusEvent> events;

  /// The ID of the instance.
  final String instanceId;

  /// The intended state of the instance. DescribeInstanceStatus requires that
  /// an instance be in the `running` state.
  final InstanceState instanceState;

  /// Reports impaired functionality that stems from issues internal to the
  /// instance, such as impaired reachability.
  final InstanceStatusSummary instanceStatus;

  /// Reports impaired functionality that stems from issues related to the
  /// systems that support an instance, such as hardware failures and network
  /// connectivity problems.
  final InstanceStatusSummary systemStatus;

  InstanceStatus({
    this.availabilityZone,
    this.events,
    this.instanceId,
    this.instanceState,
    this.instanceStatus,
    this.systemStatus,
  });
  static InstanceStatus fromJson(Map<String, dynamic> json) => InstanceStatus(
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        events: json.containsKey('Events')
            ? (json['Events'] as List)
                .map((e) => InstanceStatusEvent.fromJson(e))
                .toList()
            : null,
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        instanceState: json.containsKey('InstanceState')
            ? InstanceState.fromJson(json['InstanceState'])
            : null,
        instanceStatus: json.containsKey('InstanceStatus')
            ? InstanceStatusSummary.fromJson(json['InstanceStatus'])
            : null,
        systemStatus: json.containsKey('SystemStatus')
            ? InstanceStatusSummary.fromJson(json['SystemStatus'])
            : null,
      );
}

/// Describes the instance status.
class InstanceStatusDetails {
  /// The time when a status check failed. For an instance that was launched and
  /// impaired, this is the time when the instance was launched.
  final DateTime impairedSince;

  /// The type of instance status.
  final String name;

  /// The status.
  final String status;

  InstanceStatusDetails({
    this.impairedSince,
    this.name,
    this.status,
  });
  static InstanceStatusDetails fromJson(Map<String, dynamic> json) =>
      InstanceStatusDetails(
        impairedSince: json.containsKey('ImpairedSince')
            ? DateTime.parse(json['ImpairedSince'])
            : null,
        name: json.containsKey('Name') ? json['Name'] as String : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
      );
}

/// Describes a scheduled event for an instance.
class InstanceStatusEvent {
  /// The ID of the event.
  final String instanceEventId;

  /// The event code.
  final String code;

  /// A description of the event.
  ///
  /// After a scheduled event is completed, it can still be described for up to
  /// a week. If the event has been completed, this description starts with the
  /// following text: [Completed].
  final String description;

  /// The latest scheduled end time for the event.
  final DateTime notAfter;

  /// The earliest scheduled start time for the event.
  final DateTime notBefore;

  /// The deadline for starting the event.
  final DateTime notBeforeDeadline;

  InstanceStatusEvent({
    this.instanceEventId,
    this.code,
    this.description,
    this.notAfter,
    this.notBefore,
    this.notBeforeDeadline,
  });
  static InstanceStatusEvent fromJson(Map<String, dynamic> json) =>
      InstanceStatusEvent(
        instanceEventId: json.containsKey('InstanceEventId')
            ? json['InstanceEventId'] as String
            : null,
        code: json.containsKey('Code') ? json['Code'] as String : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        notAfter: json.containsKey('NotAfter')
            ? DateTime.parse(json['NotAfter'])
            : null,
        notBefore: json.containsKey('NotBefore')
            ? DateTime.parse(json['NotBefore'])
            : null,
        notBeforeDeadline: json.containsKey('NotBeforeDeadline')
            ? DateTime.parse(json['NotBeforeDeadline'])
            : null,
      );
}

/// Describes the status of an instance.
class InstanceStatusSummary {
  /// The system instance health or application instance health.
  final List<InstanceStatusDetails> details;

  /// The status.
  final String status;

  InstanceStatusSummary({
    this.details,
    this.status,
  });
  static InstanceStatusSummary fromJson(Map<String, dynamic> json) =>
      InstanceStatusSummary(
        details: json.containsKey('Details')
            ? (json['Details'] as List)
                .map((e) => InstanceStatusDetails.fromJson(e))
                .toList()
            : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
      );
}

/// Information about the Capacity Reservation usage.
class InstanceUsage {
  /// The ID of the AWS account that is making use of the Capacity Reservation.
  final String accountId;

  /// The number of instances the AWS account currently has in the Capacity
  /// Reservation.
  final int usedInstanceCount;

  InstanceUsage({
    this.accountId,
    this.usedInstanceCount,
  });
  static InstanceUsage fromJson(Map<String, dynamic> json) => InstanceUsage(
        accountId:
            json.containsKey('AccountId') ? json['AccountId'] as String : null,
        usedInstanceCount: json.containsKey('UsedInstanceCount')
            ? json['UsedInstanceCount'] as int
            : null,
      );
}

/// Describes an internet gateway.
class InternetGateway {
  /// Any VPCs attached to the internet gateway.
  final List<InternetGatewayAttachment> attachments;

  /// The ID of the internet gateway.
  final String internetGatewayId;

  /// The ID of the AWS account that owns the internet gateway.
  final String ownerId;

  /// Any tags assigned to the internet gateway.
  final List<Tag> tags;

  InternetGateway({
    this.attachments,
    this.internetGatewayId,
    this.ownerId,
    this.tags,
  });
  static InternetGateway fromJson(Map<String, dynamic> json) => InternetGateway(
        attachments: json.containsKey('Attachments')
            ? (json['Attachments'] as List)
                .map((e) => InternetGatewayAttachment.fromJson(e))
                .toList()
            : null,
        internetGatewayId: json.containsKey('InternetGatewayId')
            ? json['InternetGatewayId'] as String
            : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes the attachment of a VPC to an internet gateway or an egress-only
/// internet gateway.
class InternetGatewayAttachment {
  /// The current state of the attachment. For an internet gateway, the state is
  /// `available` when attached to a VPC; otherwise, this value is not returned.
  final String state;

  /// The ID of the VPC.
  final String vpcId;

  InternetGatewayAttachment({
    this.state,
    this.vpcId,
  });
  static InternetGatewayAttachment fromJson(Map<String, dynamic> json) =>
      InternetGatewayAttachment(
        state: json.containsKey('State') ? json['State'] as String : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
      );
}

/// Describes a set of permissions for a security group rule.
class IpPermission {
  /// The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6
  /// type number. A value of `-1` indicates all ICMP/ICMPv6 types. If you
  /// specify all ICMP/ICMPv6 types, you must specify all codes.
  final int fromPort;

  /// The IP protocol name (`tcp`, `udp`, `icmp`, `icmpv6`) or number (see
  /// [Protocol Numbers](http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)).
  ///
  /// [VPC only] Use `-1` to specify all protocols. When authorizing security
  /// group rules, specifying `-1` or a protocol number other than `tcp`, `udp`,
  /// `icmp`, or `icmpv6` allows traffic on all ports, regardless of any port
  /// range you specify. For `tcp`, `udp`, and `icmp`, you must specify a port
  /// range. For `icmpv6`, the port range is optional; if you omit the port
  /// range, traffic for all types and codes is allowed.
  final String ipProtocol;

  /// The IPv4 ranges.
  final List<IpRange> ipRanges;

  /// [VPC only] The IPv6 ranges.
  final List<Ipv6Range> ipv6Ranges;

  /// [VPC only] The prefix list IDs for an AWS service. With outbound rules,
  /// this is the AWS service to access through a VPC endpoint from instances
  /// associated with the security group.
  final List<PrefixListId> prefixListIds;

  /// The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6
  /// code. A value of `-1` indicates all ICMP/ICMPv6 codes. If you specify all
  /// ICMP/ICMPv6 types, you must specify all codes.
  final int toPort;

  /// The security group and AWS account ID pairs.
  final List<UserIdGroupPair> userIdGroupPairs;

  IpPermission({
    this.fromPort,
    this.ipProtocol,
    this.ipRanges,
    this.ipv6Ranges,
    this.prefixListIds,
    this.toPort,
    this.userIdGroupPairs,
  });
  static IpPermission fromJson(Map<String, dynamic> json) => IpPermission(
        fromPort: json.containsKey('FromPort') ? json['FromPort'] as int : null,
        ipProtocol: json.containsKey('IpProtocol')
            ? json['IpProtocol'] as String
            : null,
        ipRanges: json.containsKey('IpRanges')
            ? (json['IpRanges'] as List)
                .map((e) => IpRange.fromJson(e))
                .toList()
            : null,
        ipv6Ranges: json.containsKey('Ipv6Ranges')
            ? (json['Ipv6Ranges'] as List)
                .map((e) => Ipv6Range.fromJson(e))
                .toList()
            : null,
        prefixListIds: json.containsKey('PrefixListIds')
            ? (json['PrefixListIds'] as List)
                .map((e) => PrefixListId.fromJson(e))
                .toList()
            : null,
        toPort: json.containsKey('ToPort') ? json['ToPort'] as int : null,
        userIdGroupPairs: json.containsKey('UserIdGroupPairs')
            ? (json['UserIdGroupPairs'] as List)
                .map((e) => UserIdGroupPair.fromJson(e))
                .toList()
            : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes an IPv4 range.
class IpRange {
  /// The IPv4 CIDR range. You can either specify a CIDR range or a source
  /// security group, not both. To specify a single IPv4 address, use the /32
  /// prefix length.
  final String cidrIp;

  /// A description for the security group rule that references this IPv4
  /// address range.
  ///
  /// Constraints: Up to 255 characters in length. Allowed characters are a-z,
  /// A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
  final String description;

  IpRange({
    this.cidrIp,
    this.description,
  });
  static IpRange fromJson(Map<String, dynamic> json) => IpRange(
        cidrIp: json.containsKey('CidrIp') ? json['CidrIp'] as String : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes an IPv6 CIDR block.
class Ipv6CidrBlock {
  /// The IPv6 CIDR block.
  final String ipv6CidrBlock;

  Ipv6CidrBlock({
    this.ipv6CidrBlock,
  });
  static Ipv6CidrBlock fromJson(Map<String, dynamic> json) => Ipv6CidrBlock(
        ipv6CidrBlock: json.containsKey('Ipv6CidrBlock')
            ? json['Ipv6CidrBlock'] as String
            : null,
      );
}

/// [EC2-VPC only] Describes an IPv6 range.
class Ipv6Range {
  /// The IPv6 CIDR range. You can either specify a CIDR range or a source
  /// security group, not both. To specify a single IPv6 address, use the /128
  /// prefix length.
  final String cidrIpv6;

  /// A description for the security group rule that references this IPv6
  /// address range.
  ///
  /// Constraints: Up to 255 characters in length. Allowed characters are a-z,
  /// A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
  final String description;

  Ipv6Range({
    this.cidrIpv6,
    this.description,
  });
  static Ipv6Range fromJson(Map<String, dynamic> json) => Ipv6Range(
        cidrIpv6:
            json.containsKey('CidrIpv6') ? json['CidrIpv6'] as String : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a key pair.
class KeyPair {
  /// The SHA-1 digest of the DER encoded private key.
  final String keyFingerprint;

  /// An unencrypted PEM encoded RSA private key.
  final String keyMaterial;

  /// The name of the key pair.
  final String keyName;

  KeyPair({
    this.keyFingerprint,
    this.keyMaterial,
    this.keyName,
  });
  static KeyPair fromJson(Map<String, dynamic> json) => KeyPair(
        keyFingerprint: json.containsKey('KeyFingerprint')
            ? json['KeyFingerprint'] as String
            : null,
        keyMaterial: json.containsKey('KeyMaterial')
            ? json['KeyMaterial'] as String
            : null,
        keyName: json.containsKey('KeyName') ? json['KeyName'] as String : null,
      );
}

/// Describes a key pair.
class KeyPairInfo {
  /// If you used CreateKeyPair to create the key pair, this is the SHA-1 digest
  /// of the DER encoded private key. If you used ImportKeyPair to provide AWS
  /// the public key, this is the MD5 public key fingerprint as specified in
  /// section 4 of RFC4716.
  final String keyFingerprint;

  /// The name of the key pair.
  final String keyName;

  KeyPairInfo({
    this.keyFingerprint,
    this.keyName,
  });
  static KeyPairInfo fromJson(Map<String, dynamic> json) => KeyPairInfo(
        keyFingerprint: json.containsKey('KeyFingerprint')
            ? json['KeyFingerprint'] as String
            : null,
        keyName: json.containsKey('KeyName') ? json['KeyName'] as String : null,
      );
}

/// Describes a launch permission.
class LaunchPermission {
  /// The name of the group.
  final String group;

  /// The AWS account ID.
  final String userId;

  LaunchPermission({
    this.group,
    this.userId,
  });
  static LaunchPermission fromJson(Map<String, dynamic> json) =>
      LaunchPermission(
        group: json.containsKey('Group') ? json['Group'] as String : null,
        userId: json.containsKey('UserId') ? json['UserId'] as String : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a launch permission modification.
class LaunchPermissionModifications {
  /// The AWS account ID to add to the list of launch permissions for the AMI.
  final List<LaunchPermission> add;

  /// The AWS account ID to remove from the list of launch permissions for the
  /// AMI.
  final List<LaunchPermission> remove;

  LaunchPermissionModifications({
    this.add,
    this.remove,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the launch specification for an instance.
class LaunchSpecification {
  /// The Base64-encoded user data for the instance.
  final String userData;

  /// One or more security groups. When requesting instances in a VPC, you must
  /// specify the IDs of the security groups. When requesting instances in
  /// EC2-Classic, you can specify the names or the IDs of the security groups.
  final List<GroupIdentifier> securityGroups;

  /// Deprecated.
  final String addressingType;

  /// One or more block device mapping entries.
  final List<BlockDeviceMapping> blockDeviceMappings;

  /// Indicates whether the instance is optimized for EBS I/O. This optimization
  /// provides dedicated throughput to Amazon EBS and an optimized configuration
  /// stack to provide optimal EBS I/O performance. This optimization isn't
  /// available with all instance types. Additional usage charges apply when
  /// using an EBS Optimized instance.
  ///
  /// Default: `false`
  final bool ebsOptimized;

  /// The IAM instance profile.
  final IamInstanceProfileSpecification iamInstanceProfile;

  /// The ID of the AMI.
  final String imageId;

  /// The instance type.
  final String instanceType;

  /// The ID of the kernel.
  final String kernelId;

  /// The name of the key pair.
  final String keyName;

  /// One or more network interfaces. If you specify a network interface, you
  /// must specify subnet IDs and security group IDs using the network
  /// interface.
  final List<InstanceNetworkInterfaceSpecification> networkInterfaces;

  /// The placement information for the instance.
  final SpotPlacement placement;

  /// The ID of the RAM disk.
  final String ramdiskId;

  /// The ID of the subnet in which to launch the instance.
  final String subnetId;

  final RunInstancesMonitoringEnabled monitoring;

  LaunchSpecification({
    this.userData,
    this.securityGroups,
    this.addressingType,
    this.blockDeviceMappings,
    this.ebsOptimized,
    this.iamInstanceProfile,
    this.imageId,
    this.instanceType,
    this.kernelId,
    this.keyName,
    this.networkInterfaces,
    this.placement,
    this.ramdiskId,
    this.subnetId,
    this.monitoring,
  });
  static LaunchSpecification fromJson(Map<String, dynamic> json) =>
      LaunchSpecification(
        userData:
            json.containsKey('UserData') ? json['UserData'] as String : null,
        securityGroups: json.containsKey('SecurityGroups')
            ? (json['SecurityGroups'] as List)
                .map((e) => GroupIdentifier.fromJson(e))
                .toList()
            : null,
        addressingType: json.containsKey('AddressingType')
            ? json['AddressingType'] as String
            : null,
        blockDeviceMappings: json.containsKey('BlockDeviceMappings')
            ? (json['BlockDeviceMappings'] as List)
                .map((e) => BlockDeviceMapping.fromJson(e))
                .toList()
            : null,
        ebsOptimized: json.containsKey('EbsOptimized')
            ? json['EbsOptimized'] as bool
            : null,
        iamInstanceProfile: json.containsKey('IamInstanceProfile')
            ? IamInstanceProfileSpecification.fromJson(
                json['IamInstanceProfile'])
            : null,
        imageId: json.containsKey('ImageId') ? json['ImageId'] as String : null,
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        kernelId:
            json.containsKey('KernelId') ? json['KernelId'] as String : null,
        keyName: json.containsKey('KeyName') ? json['KeyName'] as String : null,
        networkInterfaces: json.containsKey('NetworkInterfaces')
            ? (json['NetworkInterfaces'] as List)
                .map((e) => InstanceNetworkInterfaceSpecification.fromJson(e))
                .toList()
            : null,
        placement: json.containsKey('Placement')
            ? SpotPlacement.fromJson(json['Placement'])
            : null,
        ramdiskId:
            json.containsKey('RamdiskId') ? json['RamdiskId'] as String : null,
        subnetId:
            json.containsKey('SubnetId') ? json['SubnetId'] as String : null,
        monitoring: json.containsKey('Monitoring')
            ? RunInstancesMonitoringEnabled.fromJson(json['Monitoring'])
            : null,
      );
}

/// Describes a launch template.
class LaunchTemplate {
  /// The ID of the launch template.
  final String launchTemplateId;

  /// The name of the launch template.
  final String launchTemplateName;

  /// The time launch template was created.
  final DateTime createTime;

  /// The principal that created the launch template.
  final String createdBy;

  /// The version number of the default version of the launch template.
  final BigInt defaultVersionNumber;

  /// The version number of the latest version of the launch template.
  final BigInt latestVersionNumber;

  /// The tags for the launch template.
  final List<Tag> tags;

  LaunchTemplate({
    this.launchTemplateId,
    this.launchTemplateName,
    this.createTime,
    this.createdBy,
    this.defaultVersionNumber,
    this.latestVersionNumber,
    this.tags,
  });
  static LaunchTemplate fromJson(Map<String, dynamic> json) => LaunchTemplate(
        launchTemplateId: json.containsKey('LaunchTemplateId')
            ? json['LaunchTemplateId'] as String
            : null,
        launchTemplateName: json.containsKey('LaunchTemplateName')
            ? json['LaunchTemplateName'] as String
            : null,
        createTime: json.containsKey('CreateTime')
            ? DateTime.parse(json['CreateTime'])
            : null,
        createdBy:
            json.containsKey('CreatedBy') ? json['CreatedBy'] as String : null,
        defaultVersionNumber: json.containsKey('DefaultVersionNumber')
            ? BigInt.from(json['DefaultVersionNumber'])
            : null,
        latestVersionNumber: json.containsKey('LatestVersionNumber')
            ? BigInt.from(json['LatestVersionNumber'])
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes a launch template and overrides.
class LaunchTemplateAndOverridesResponse {
  /// The launch template.
  final FleetLaunchTemplateSpecification launchTemplateSpecification;

  /// Any parameters that you specify override the same parameters in the launch
  /// template.
  final FleetLaunchTemplateOverrides overrides;

  LaunchTemplateAndOverridesResponse({
    this.launchTemplateSpecification,
    this.overrides,
  });
  static LaunchTemplateAndOverridesResponse fromJson(
          Map<String, dynamic> json) =>
      LaunchTemplateAndOverridesResponse(
        launchTemplateSpecification:
            json.containsKey('LaunchTemplateSpecification')
                ? FleetLaunchTemplateSpecification.fromJson(
                    json['LaunchTemplateSpecification'])
                : null,
        overrides: json.containsKey('Overrides')
            ? FleetLaunchTemplateOverrides.fromJson(json['Overrides'])
            : null,
      );
}

/// Describes a block device mapping.
class LaunchTemplateBlockDeviceMapping {
  /// The device name.
  final String deviceName;

  /// The virtual device name (ephemeralN).
  final String virtualName;

  /// Information about the block device for an EBS volume.
  final LaunchTemplateEbsBlockDevice ebs;

  /// Suppresses the specified device included in the block device mapping of
  /// the AMI.
  final String noDevice;

  LaunchTemplateBlockDeviceMapping({
    this.deviceName,
    this.virtualName,
    this.ebs,
    this.noDevice,
  });
  static LaunchTemplateBlockDeviceMapping fromJson(Map<String, dynamic> json) =>
      LaunchTemplateBlockDeviceMapping(
        deviceName: json.containsKey('DeviceName')
            ? json['DeviceName'] as String
            : null,
        virtualName: json.containsKey('VirtualName')
            ? json['VirtualName'] as String
            : null,
        ebs: json.containsKey('Ebs')
            ? LaunchTemplateEbsBlockDevice.fromJson(json['Ebs'])
            : null,
        noDevice:
            json.containsKey('NoDevice') ? json['NoDevice'] as String : null,
      );
}

/// Describes a block device mapping.
class LaunchTemplateBlockDeviceMappingRequest {
  /// The device name (for example, /dev/sdh or xvdh).
  final String deviceName;

  /// The virtual device name (ephemeralN). Instance store volumes are numbered
  /// starting from 0. An instance type with 2 available instance store volumes
  /// can specify mappings for ephemeral0 and ephemeral1. The number of
  /// available instance store volumes depends on the instance type. After you
  /// connect to the instance, you must mount the volume.
  final String virtualName;

  /// Parameters used to automatically set up EBS volumes when the instance is
  /// launched.
  final LaunchTemplateEbsBlockDeviceRequest ebs;

  /// Suppresses the specified device included in the block device mapping of
  /// the AMI.
  final String noDevice;

  LaunchTemplateBlockDeviceMappingRequest({
    this.deviceName,
    this.virtualName,
    this.ebs,
    this.noDevice,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes an instance's Capacity Reservation targeting option. You can
/// specify only one option at a time. Use the `CapacityReservationPreference`
/// parameter to configure the instance to run in On-Demand capacity or to run
/// in any `open` Capacity Reservation that has matching attributes (instance
/// type, platform, Availability Zone). Use the `CapacityReservationTarget`
/// parameter to explicitly target a specific Capacity Reservation.
class LaunchTemplateCapacityReservationSpecificationRequest {
  /// Indicates the instance's Capacity Reservation preferences. Possible
  /// preferences include:
  ///
  /// *    `open` - The instance can run in any `open` Capacity Reservation that
  /// has matching attributes (instance type, platform, Availability Zone).
  ///
  /// *    `none` - The instance avoids running in a Capacity Reservation even
  /// if one is available. The instance runs in On-Demand capacity.
  final String capacityReservationPreference;

  /// Information about the target Capacity Reservation.
  final CapacityReservationTarget capacityReservationTarget;

  LaunchTemplateCapacityReservationSpecificationRequest({
    this.capacityReservationPreference,
    this.capacityReservationTarget,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Information about the Capacity Reservation targeting option.
class LaunchTemplateCapacityReservationSpecificationResponse {
  /// Indicates the instance's Capacity Reservation preferences. Possible
  /// preferences include:
  ///
  /// *    `open` - The instance can run in any `open` Capacity Reservation that
  /// has matching attributes (instance type, platform, Availability Zone).
  ///
  /// *    `none` - The instance avoids running in a Capacity Reservation even
  /// if one is available. The instance runs in On-Demand capacity.
  final String capacityReservationPreference;

  /// Information about the target Capacity Reservation.
  final CapacityReservationTargetResponse capacityReservationTarget;

  LaunchTemplateCapacityReservationSpecificationResponse({
    this.capacityReservationPreference,
    this.capacityReservationTarget,
  });
  static LaunchTemplateCapacityReservationSpecificationResponse fromJson(
          Map<String, dynamic> json) =>
      LaunchTemplateCapacityReservationSpecificationResponse(
        capacityReservationPreference:
            json.containsKey('CapacityReservationPreference')
                ? json['CapacityReservationPreference'] as String
                : null,
        capacityReservationTarget: json.containsKey('CapacityReservationTarget')
            ? CapacityReservationTargetResponse.fromJson(
                json['CapacityReservationTarget'])
            : null,
      );
}

/// Describes a launch template and overrides.
class LaunchTemplateConfig {
  /// The launch template.
  final FleetLaunchTemplateSpecification launchTemplateSpecification;

  /// Any parameters that you specify override the same parameters in the launch
  /// template.
  final List<LaunchTemplateOverrides> overrides;

  LaunchTemplateConfig({
    this.launchTemplateSpecification,
    this.overrides,
  });
  static LaunchTemplateConfig fromJson(Map<String, dynamic> json) =>
      LaunchTemplateConfig(
        launchTemplateSpecification:
            json.containsKey('LaunchTemplateSpecification')
                ? FleetLaunchTemplateSpecification.fromJson(
                    json['LaunchTemplateSpecification'])
                : null,
        overrides: json.containsKey('Overrides')
            ? (json['Overrides'] as List)
                .map((e) => LaunchTemplateOverrides.fromJson(e))
                .toList()
            : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// The CPU options for the instance.
class LaunchTemplateCpuOptions {
  /// The number of CPU cores for the instance.
  final int coreCount;

  /// The number of threads per CPU core.
  final int threadsPerCore;

  LaunchTemplateCpuOptions({
    this.coreCount,
    this.threadsPerCore,
  });
  static LaunchTemplateCpuOptions fromJson(Map<String, dynamic> json) =>
      LaunchTemplateCpuOptions(
        coreCount:
            json.containsKey('CoreCount') ? json['CoreCount'] as int : null,
        threadsPerCore: json.containsKey('ThreadsPerCore')
            ? json['ThreadsPerCore'] as int
            : null,
      );
}

/// The CPU options for the instance. Both the core count and threads per core
/// must be specified in the request.
class LaunchTemplateCpuOptionsRequest {
  /// The number of CPU cores for the instance.
  final int coreCount;

  /// The number of threads per CPU core. To disable multithreading for the
  /// instance, specify a value of 1. Otherwise, specify the default value of 2.
  final int threadsPerCore;

  LaunchTemplateCpuOptionsRequest({
    this.coreCount,
    this.threadsPerCore,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a block device for an EBS volume.
class LaunchTemplateEbsBlockDevice {
  /// Indicates whether the EBS volume is encrypted.
  final bool encrypted;

  /// Indicates whether the EBS volume is deleted on instance termination.
  final bool deleteOnTermination;

  /// The number of I/O operations per second (IOPS) that the volume supports.
  final int iops;

  /// The ARN of the AWS Key Management Service (AWS KMS) CMK used for
  /// encryption.
  final String kmsKeyId;

  /// The ID of the snapshot.
  final String snapshotId;

  /// The size of the volume, in GiB.
  final int volumeSize;

  /// The volume type.
  final String volumeType;

  LaunchTemplateEbsBlockDevice({
    this.encrypted,
    this.deleteOnTermination,
    this.iops,
    this.kmsKeyId,
    this.snapshotId,
    this.volumeSize,
    this.volumeType,
  });
  static LaunchTemplateEbsBlockDevice fromJson(Map<String, dynamic> json) =>
      LaunchTemplateEbsBlockDevice(
        encrypted:
            json.containsKey('Encrypted') ? json['Encrypted'] as bool : null,
        deleteOnTermination: json.containsKey('DeleteOnTermination')
            ? json['DeleteOnTermination'] as bool
            : null,
        iops: json.containsKey('Iops') ? json['Iops'] as int : null,
        kmsKeyId:
            json.containsKey('KmsKeyId') ? json['KmsKeyId'] as String : null,
        snapshotId: json.containsKey('SnapshotId')
            ? json['SnapshotId'] as String
            : null,
        volumeSize:
            json.containsKey('VolumeSize') ? json['VolumeSize'] as int : null,
        volumeType: json.containsKey('VolumeType')
            ? json['VolumeType'] as String
            : null,
      );
}

/// The parameters for a block device for an EBS volume.
class LaunchTemplateEbsBlockDeviceRequest {
  /// Indicates whether the EBS volume is encrypted. Encrypted volumes can only
  /// be attached to instances that support Amazon EBS encryption. If you are
  /// creating a volume from a snapshot, you can't specify an encryption value.
  final bool encrypted;

  /// Indicates whether the EBS volume is deleted on instance termination.
  final bool deleteOnTermination;

  /// The number of I/O operations per second (IOPS) that the volume supports.
  /// For io1, this represents the number of IOPS that are provisioned for the
  /// volume. For gp2, this represents the baseline performance of the volume
  /// and the rate at which the volume accumulates I/O credits for bursting. For
  /// more information about General Purpose SSD baseline performance, I/O
  /// credits, and bursting, see
  /// [Amazon EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// Condition: This parameter is required for requests to create io1 volumes;
  /// it is not used in requests to create gp2, st1, sc1, or standard volumes.
  final int iops;

  /// The ARN of the AWS Key Management Service (AWS KMS) CMK used for
  /// encryption.
  final String kmsKeyId;

  /// The ID of the snapshot.
  final String snapshotId;

  /// The size of the volume, in GiB.
  ///
  /// Default: If you're creating the volume from a snapshot and don't specify a
  /// volume size, the default is the snapshot size.
  final int volumeSize;

  /// The volume type.
  final String volumeType;

  LaunchTemplateEbsBlockDeviceRequest({
    this.encrypted,
    this.deleteOnTermination,
    this.iops,
    this.kmsKeyId,
    this.snapshotId,
    this.volumeSize,
    this.volumeType,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

///  Describes an elastic inference accelerator.
class LaunchTemplateElasticInferenceAccelerator {
  ///  The type of elastic inference accelerator. The possible values are
  /// eia1.medium, eia1.large, and eia1.xlarge.
  final String type;

  LaunchTemplateElasticInferenceAccelerator({
    @required this.type,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

///  Describes an elastic inference accelerator.
class LaunchTemplateElasticInferenceAcceleratorResponse {
  ///  The type of elastic inference accelerator. The possible values are
  /// eia1.medium, eia1.large, and eia1.xlarge.
  final String type;

  LaunchTemplateElasticInferenceAcceleratorResponse({
    this.type,
  });
  static LaunchTemplateElasticInferenceAcceleratorResponse fromJson(
          Map<String, dynamic> json) =>
      LaunchTemplateElasticInferenceAcceleratorResponse(
        type: json.containsKey('Type') ? json['Type'] as String : null,
      );
}

/// Indicates whether an instance is configured for hibernation.
class LaunchTemplateHibernationOptions {
  /// If this parameter is set to `true`, the instance is enabled for
  /// hibernation; otherwise, it is not enabled for hibernation.
  final bool configured;

  LaunchTemplateHibernationOptions({
    this.configured,
  });
  static LaunchTemplateHibernationOptions fromJson(Map<String, dynamic> json) =>
      LaunchTemplateHibernationOptions(
        configured:
            json.containsKey('Configured') ? json['Configured'] as bool : null,
      );
}

/// Indicates whether the instance is configured for hibernation. This parameter
/// is valid only if the instance meets the
/// [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites).
/// Hibernation is currently supported only for Amazon Linux.
class LaunchTemplateHibernationOptionsRequest {
  /// If you set this parameter to `true`, the instance is enabled for
  /// hibernation.
  ///
  /// Default: `false`
  final bool configured;

  LaunchTemplateHibernationOptionsRequest({
    this.configured,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes an IAM instance profile.
class LaunchTemplateIamInstanceProfileSpecification {
  /// The Amazon Resource Name (ARN) of the instance profile.
  final String arn;

  /// The name of the instance profile.
  final String name;

  LaunchTemplateIamInstanceProfileSpecification({
    this.arn,
    this.name,
  });
  static LaunchTemplateIamInstanceProfileSpecification fromJson(
          Map<String, dynamic> json) =>
      LaunchTemplateIamInstanceProfileSpecification(
        arn: json.containsKey('Arn') ? json['Arn'] as String : null,
        name: json.containsKey('Name') ? json['Name'] as String : null,
      );
}

/// An IAM instance profile.
class LaunchTemplateIamInstanceProfileSpecificationRequest {
  /// The Amazon Resource Name (ARN) of the instance profile.
  final String arn;

  /// The name of the instance profile.
  final String name;

  LaunchTemplateIamInstanceProfileSpecificationRequest({
    this.arn,
    this.name,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// The market (purchasing) option for the instances.
class LaunchTemplateInstanceMarketOptions {
  /// The market type.
  final String marketType;

  /// The options for Spot Instances.
  final LaunchTemplateSpotMarketOptions spotOptions;

  LaunchTemplateInstanceMarketOptions({
    this.marketType,
    this.spotOptions,
  });
  static LaunchTemplateInstanceMarketOptions fromJson(
          Map<String, dynamic> json) =>
      LaunchTemplateInstanceMarketOptions(
        marketType: json.containsKey('MarketType')
            ? json['MarketType'] as String
            : null,
        spotOptions: json.containsKey('SpotOptions')
            ? LaunchTemplateSpotMarketOptions.fromJson(json['SpotOptions'])
            : null,
      );
}

/// The market (purchasing) option for the instances.
class LaunchTemplateInstanceMarketOptionsRequest {
  /// The market type.
  final String marketType;

  /// The options for Spot Instances.
  final LaunchTemplateSpotMarketOptionsRequest spotOptions;

  LaunchTemplateInstanceMarketOptionsRequest({
    this.marketType,
    this.spotOptions,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a network interface.
class LaunchTemplateInstanceNetworkInterfaceSpecification {
  /// Indicates whether to associate a public IPv4 address with eth0 for a new
  /// network interface.
  final bool associatePublicIpAddress;

  /// Indicates whether the network interface is deleted when the instance is
  /// terminated.
  final bool deleteOnTermination;

  /// A description for the network interface.
  final String description;

  /// The device index for the network interface attachment.
  final int deviceIndex;

  /// The IDs of one or more security groups.
  final List<String> groups;

  /// The type of network interface.
  final String interfaceType;

  /// The number of IPv6 addresses for the network interface.
  final int ipv6AddressCount;

  /// The IPv6 addresses for the network interface.
  final List<InstanceIpv6Address> ipv6Addresses;

  /// The ID of the network interface.
  final String networkInterfaceId;

  /// The primary private IPv4 address of the network interface.
  final String privateIpAddress;

  /// One or more private IPv4 addresses.
  final List<PrivateIpAddressSpecification> privateIpAddresses;

  /// The number of secondary private IPv4 addresses for the network interface.
  final int secondaryPrivateIpAddressCount;

  /// The ID of the subnet for the network interface.
  final String subnetId;

  LaunchTemplateInstanceNetworkInterfaceSpecification({
    this.associatePublicIpAddress,
    this.deleteOnTermination,
    this.description,
    this.deviceIndex,
    this.groups,
    this.interfaceType,
    this.ipv6AddressCount,
    this.ipv6Addresses,
    this.networkInterfaceId,
    this.privateIpAddress,
    this.privateIpAddresses,
    this.secondaryPrivateIpAddressCount,
    this.subnetId,
  });
  static LaunchTemplateInstanceNetworkInterfaceSpecification fromJson(
          Map<String, dynamic> json) =>
      LaunchTemplateInstanceNetworkInterfaceSpecification(
        associatePublicIpAddress: json.containsKey('AssociatePublicIpAddress')
            ? json['AssociatePublicIpAddress'] as bool
            : null,
        deleteOnTermination: json.containsKey('DeleteOnTermination')
            ? json['DeleteOnTermination'] as bool
            : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        deviceIndex:
            json.containsKey('DeviceIndex') ? json['DeviceIndex'] as int : null,
        groups: json.containsKey('Groups')
            ? (json['Groups'] as List).map((e) => e as String).toList()
            : null,
        interfaceType: json.containsKey('InterfaceType')
            ? json['InterfaceType'] as String
            : null,
        ipv6AddressCount: json.containsKey('Ipv6AddressCount')
            ? json['Ipv6AddressCount'] as int
            : null,
        ipv6Addresses: json.containsKey('Ipv6Addresses')
            ? (json['Ipv6Addresses'] as List)
                .map((e) => InstanceIpv6Address.fromJson(e))
                .toList()
            : null,
        networkInterfaceId: json.containsKey('NetworkInterfaceId')
            ? json['NetworkInterfaceId'] as String
            : null,
        privateIpAddress: json.containsKey('PrivateIpAddress')
            ? json['PrivateIpAddress'] as String
            : null,
        privateIpAddresses: json.containsKey('PrivateIpAddresses')
            ? (json['PrivateIpAddresses'] as List)
                .map((e) => PrivateIpAddressSpecification.fromJson(e))
                .toList()
            : null,
        secondaryPrivateIpAddressCount:
            json.containsKey('SecondaryPrivateIpAddressCount')
                ? json['SecondaryPrivateIpAddressCount'] as int
                : null,
        subnetId:
            json.containsKey('SubnetId') ? json['SubnetId'] as String : null,
      );
}

/// The parameters for a network interface.
class LaunchTemplateInstanceNetworkInterfaceSpecificationRequest {
  /// Associates a public IPv4 address with eth0 for a new network interface.
  final bool associatePublicIpAddress;

  /// Indicates whether the network interface is deleted when the instance is
  /// terminated.
  final bool deleteOnTermination;

  /// A description for the network interface.
  final String description;

  /// The device index for the network interface attachment.
  final int deviceIndex;

  /// The IDs of one or more security groups.
  final List<String> groups;

  /// The type of network interface. To create an Elastic Fabric Adapter (EFA),
  /// specify `efa`. For more information, see
  /// [Elastic Fabric Adapter](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// If you are not creating an EFA, specify `interface` or omit this
  /// parameter.
  ///
  /// Valid values: `interface` | `efa`
  final String interfaceType;

  /// The number of IPv6 addresses to assign to a network interface. Amazon EC2
  /// automatically selects the IPv6 addresses from the subnet range. You can't
  /// use this option if specifying specific IPv6 addresses.
  final int ipv6AddressCount;

  /// One or more specific IPv6 addresses from the IPv6 CIDR block range of your
  /// subnet. You can't use this option if you're specifying a number of IPv6
  /// addresses.
  final List<InstanceIpv6AddressRequest> ipv6Addresses;

  /// The ID of the network interface.
  final String networkInterfaceId;

  /// The primary private IPv4 address of the network interface.
  final String privateIpAddress;

  /// One or more private IPv4 addresses.
  final List<PrivateIpAddressSpecification> privateIpAddresses;

  /// The number of secondary private IPv4 addresses to assign to a network
  /// interface.
  final int secondaryPrivateIpAddressCount;

  /// The ID of the subnet for the network interface.
  final String subnetId;

  LaunchTemplateInstanceNetworkInterfaceSpecificationRequest({
    this.associatePublicIpAddress,
    this.deleteOnTermination,
    this.description,
    this.deviceIndex,
    this.groups,
    this.interfaceType,
    this.ipv6AddressCount,
    this.ipv6Addresses,
    this.networkInterfaceId,
    this.privateIpAddress,
    this.privateIpAddresses,
    this.secondaryPrivateIpAddressCount,
    this.subnetId,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a license configuration.
class LaunchTemplateLicenseConfiguration {
  /// The Amazon Resource Name (ARN) of the license configuration.
  final String licenseConfigurationArn;

  LaunchTemplateLicenseConfiguration({
    this.licenseConfigurationArn,
  });
  static LaunchTemplateLicenseConfiguration fromJson(
          Map<String, dynamic> json) =>
      LaunchTemplateLicenseConfiguration(
        licenseConfigurationArn: json.containsKey('LicenseConfigurationArn')
            ? json['LicenseConfigurationArn'] as String
            : null,
      );
}

/// Describes a license configuration.
class LaunchTemplateLicenseConfigurationRequest {
  /// The Amazon Resource Name (ARN) of the license configuration.
  final String licenseConfigurationArn;

  LaunchTemplateLicenseConfigurationRequest({
    this.licenseConfigurationArn,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes overrides for a launch template.
class LaunchTemplateOverrides {
  /// The instance type.
  final String instanceType;

  /// The maximum price per unit hour that you are willing to pay for a Spot
  /// Instance.
  final String spotPrice;

  /// The ID of the subnet in which to launch the instances.
  final String subnetId;

  /// The Availability Zone in which to launch the instances.
  final String availabilityZone;

  /// The number of units provided by the specified instance type.
  final double weightedCapacity;

  /// The priority for the launch template override. If
  /// **OnDemandAllocationStrategy** is set to `prioritized`, Spot Fleet uses
  /// priority to determine which launch template override to use first in
  /// fulfilling On-Demand capacity. The highest priority is launched first.
  /// Valid values are whole numbers starting at `0`. The lower the number, the
  /// higher the priority. If no number is set, the launch template override has
  /// the lowest priority.
  final double priority;

  LaunchTemplateOverrides({
    this.instanceType,
    this.spotPrice,
    this.subnetId,
    this.availabilityZone,
    this.weightedCapacity,
    this.priority,
  });
  static LaunchTemplateOverrides fromJson(Map<String, dynamic> json) =>
      LaunchTemplateOverrides(
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        spotPrice:
            json.containsKey('SpotPrice') ? json['SpotPrice'] as String : null,
        subnetId:
            json.containsKey('SubnetId') ? json['SubnetId'] as String : null,
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        weightedCapacity: json.containsKey('WeightedCapacity')
            ? json['WeightedCapacity'] as double
            : null,
        priority:
            json.containsKey('Priority') ? json['Priority'] as double : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the placement of an instance.
class LaunchTemplatePlacement {
  /// The Availability Zone of the instance.
  final String availabilityZone;

  /// The affinity setting for the instance on the Dedicated Host.
  final String affinity;

  /// The name of the placement group for the instance.
  final String groupName;

  /// The ID of the Dedicated Host for the instance.
  final String hostId;

  /// The tenancy of the instance (if the instance is running in a VPC). An
  /// instance with a tenancy of `dedicated` runs on single-tenant hardware.
  final String tenancy;

  /// Reserved for future use.
  final String spreadDomain;

  LaunchTemplatePlacement({
    this.availabilityZone,
    this.affinity,
    this.groupName,
    this.hostId,
    this.tenancy,
    this.spreadDomain,
  });
  static LaunchTemplatePlacement fromJson(Map<String, dynamic> json) =>
      LaunchTemplatePlacement(
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        affinity:
            json.containsKey('Affinity') ? json['Affinity'] as String : null,
        groupName:
            json.containsKey('GroupName') ? json['GroupName'] as String : null,
        hostId: json.containsKey('HostId') ? json['HostId'] as String : null,
        tenancy: json.containsKey('Tenancy') ? json['Tenancy'] as String : null,
        spreadDomain: json.containsKey('SpreadDomain')
            ? json['SpreadDomain'] as String
            : null,
      );
}

/// Describes the placement of an instance.
class LaunchTemplatePlacementRequest {
  /// The Availability Zone for the instance.
  final String availabilityZone;

  /// The affinity setting for an instance on a Dedicated Host.
  final String affinity;

  /// The name of the placement group for the instance.
  final String groupName;

  /// The ID of the Dedicated Host for the instance.
  final String hostId;

  /// The tenancy of the instance (if the instance is running in a VPC). An
  /// instance with a tenancy of dedicated runs on single-tenant hardware.
  final String tenancy;

  /// Reserved for future use.
  final String spreadDomain;

  LaunchTemplatePlacementRequest({
    this.availabilityZone,
    this.affinity,
    this.groupName,
    this.hostId,
    this.tenancy,
    this.spreadDomain,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// The launch template to use. You must specify either the launch template ID
/// or launch template name in the request, but not both.
class LaunchTemplateSpecification {
  /// The ID of the launch template.
  final String launchTemplateId;

  /// The name of the launch template.
  final String launchTemplateName;

  /// The version number of the launch template.
  ///
  /// Default: The default version for the launch template.
  final String version;

  LaunchTemplateSpecification({
    this.launchTemplateId,
    this.launchTemplateName,
    this.version,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// The options for Spot Instances.
class LaunchTemplateSpotMarketOptions {
  /// The maximum hourly price you're willing to pay for the Spot Instances.
  final String maxPrice;

  /// The Spot Instance request type.
  final String spotInstanceType;

  /// The required duration for the Spot Instances (also known as Spot blocks),
  /// in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300,
  /// or 360).
  final int blockDurationMinutes;

  /// The end date of the request. For a one-time request, the request remains
  /// active until all instances launch, the request is canceled, or this date
  /// is reached. If the request is persistent, it remains active until it is
  /// canceled or this date and time is reached.
  final DateTime validUntil;

  /// The behavior when a Spot Instance is interrupted.
  final String instanceInterruptionBehavior;

  LaunchTemplateSpotMarketOptions({
    this.maxPrice,
    this.spotInstanceType,
    this.blockDurationMinutes,
    this.validUntil,
    this.instanceInterruptionBehavior,
  });
  static LaunchTemplateSpotMarketOptions fromJson(Map<String, dynamic> json) =>
      LaunchTemplateSpotMarketOptions(
        maxPrice:
            json.containsKey('MaxPrice') ? json['MaxPrice'] as String : null,
        spotInstanceType: json.containsKey('SpotInstanceType')
            ? json['SpotInstanceType'] as String
            : null,
        blockDurationMinutes: json.containsKey('BlockDurationMinutes')
            ? json['BlockDurationMinutes'] as int
            : null,
        validUntil: json.containsKey('ValidUntil')
            ? DateTime.parse(json['ValidUntil'])
            : null,
        instanceInterruptionBehavior:
            json.containsKey('InstanceInterruptionBehavior')
                ? json['InstanceInterruptionBehavior'] as String
                : null,
      );
}

/// The options for Spot Instances.
class LaunchTemplateSpotMarketOptionsRequest {
  /// The maximum hourly price you're willing to pay for the Spot Instances.
  final String maxPrice;

  /// The Spot Instance request type.
  final String spotInstanceType;

  /// The required duration for the Spot Instances (also known as Spot blocks),
  /// in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300,
  /// or 360).
  final int blockDurationMinutes;

  /// The end date of the request. For a one-time request, the request remains
  /// active until all instances launch, the request is canceled, or this date
  /// is reached. If the request is persistent, it remains active until it is
  /// canceled or this date and time is reached. The default end date is 7 days
  /// from the current date.
  final DateTime validUntil;

  /// The behavior when a Spot Instance is interrupted. The default is
  /// `terminate`.
  final String instanceInterruptionBehavior;

  LaunchTemplateSpotMarketOptionsRequest({
    this.maxPrice,
    this.spotInstanceType,
    this.blockDurationMinutes,
    this.validUntil,
    this.instanceInterruptionBehavior,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// The tag specification for the launch template.
class LaunchTemplateTagSpecification {
  /// The type of resource.
  final String resourceType;

  /// The tags for the resource.
  final List<Tag> tags;

  LaunchTemplateTagSpecification({
    this.resourceType,
    this.tags,
  });
  static LaunchTemplateTagSpecification fromJson(Map<String, dynamic> json) =>
      LaunchTemplateTagSpecification(
        resourceType: json.containsKey('ResourceType')
            ? json['ResourceType'] as String
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// The tags specification for the launch template.
class LaunchTemplateTagSpecificationRequest {
  /// The type of resource to tag. Currently, the resource types that support
  /// tagging on creation are `instance` and `volume`. To tag a resource after
  /// it has been created, see
  /// [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html).
  final String resourceType;

  /// The tags to apply to the resource.
  final List<Tag> tags;

  LaunchTemplateTagSpecificationRequest({
    this.resourceType,
    this.tags,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a launch template version.
class LaunchTemplateVersion {
  /// The ID of the launch template.
  final String launchTemplateId;

  /// The name of the launch template.
  final String launchTemplateName;

  /// The version number.
  final BigInt versionNumber;

  /// The description for the version.
  final String versionDescription;

  /// The time the version was created.
  final DateTime createTime;

  /// The principal that created the version.
  final String createdBy;

  /// Indicates whether the version is the default version.
  final bool defaultVersion;

  /// Information about the launch template.
  final ResponseLaunchTemplateData launchTemplateData;

  LaunchTemplateVersion({
    this.launchTemplateId,
    this.launchTemplateName,
    this.versionNumber,
    this.versionDescription,
    this.createTime,
    this.createdBy,
    this.defaultVersion,
    this.launchTemplateData,
  });
  static LaunchTemplateVersion fromJson(Map<String, dynamic> json) =>
      LaunchTemplateVersion(
        launchTemplateId: json.containsKey('LaunchTemplateId')
            ? json['LaunchTemplateId'] as String
            : null,
        launchTemplateName: json.containsKey('LaunchTemplateName')
            ? json['LaunchTemplateName'] as String
            : null,
        versionNumber: json.containsKey('VersionNumber')
            ? BigInt.from(json['VersionNumber'])
            : null,
        versionDescription: json.containsKey('VersionDescription')
            ? json['VersionDescription'] as String
            : null,
        createTime: json.containsKey('CreateTime')
            ? DateTime.parse(json['CreateTime'])
            : null,
        createdBy:
            json.containsKey('CreatedBy') ? json['CreatedBy'] as String : null,
        defaultVersion: json.containsKey('DefaultVersion')
            ? json['DefaultVersion'] as bool
            : null,
        launchTemplateData: json.containsKey('LaunchTemplateData')
            ? ResponseLaunchTemplateData.fromJson(json['LaunchTemplateData'])
            : null,
      );
}

/// Describes the monitoring for the instance.
class LaunchTemplatesMonitoring {
  /// Indicates whether detailed monitoring is enabled. Otherwise, basic
  /// monitoring is enabled.
  final bool enabled;

  LaunchTemplatesMonitoring({
    this.enabled,
  });
  static LaunchTemplatesMonitoring fromJson(Map<String, dynamic> json) =>
      LaunchTemplatesMonitoring(
        enabled: json.containsKey('Enabled') ? json['Enabled'] as bool : null,
      );
}

/// Describes the monitoring for the instance.
class LaunchTemplatesMonitoringRequest {
  /// Specify `true` to enable detailed monitoring. Otherwise, basic monitoring
  /// is enabled.
  final bool enabled;

  LaunchTemplatesMonitoringRequest({
    this.enabled,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a license configuration.
class LicenseConfiguration {
  /// The Amazon Resource Name (ARN) of the license configuration.
  final String licenseConfigurationArn;

  LicenseConfiguration({
    this.licenseConfigurationArn,
  });
  static LicenseConfiguration fromJson(Map<String, dynamic> json) =>
      LicenseConfiguration(
        licenseConfigurationArn: json.containsKey('LicenseConfigurationArn')
            ? json['LicenseConfigurationArn'] as String
            : null,
      );
}

/// Describes a license configuration.
class LicenseConfigurationRequest {
  /// The Amazon Resource Name (ARN) of the license configuration.
  final String licenseConfigurationArn;

  LicenseConfigurationRequest({
    this.licenseConfigurationArn,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the Classic Load Balancers and target groups to attach to a Spot
/// Fleet request.
class LoadBalancersConfig {
  /// The Classic Load Balancers.
  final ClassicLoadBalancersConfig classicLoadBalancersConfig;

  /// The target groups.
  final TargetGroupsConfig targetGroupsConfig;

  LoadBalancersConfig({
    this.classicLoadBalancersConfig,
    this.targetGroupsConfig,
  });
  static LoadBalancersConfig fromJson(Map<String, dynamic> json) =>
      LoadBalancersConfig(
        classicLoadBalancersConfig:
            json.containsKey('ClassicLoadBalancersConfig')
                ? ClassicLoadBalancersConfig.fromJson(
                    json['ClassicLoadBalancersConfig'])
                : null,
        targetGroupsConfig: json.containsKey('TargetGroupsConfig')
            ? TargetGroupsConfig.fromJson(json['TargetGroupsConfig'])
            : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a load permission.
class LoadPermission {
  /// The AWS account ID.
  final String userId;

  /// The name of the group.
  final String group;

  LoadPermission({
    this.userId,
    this.group,
  });
  static LoadPermission fromJson(Map<String, dynamic> json) => LoadPermission(
        userId: json.containsKey('UserId') ? json['UserId'] as String : null,
        group: json.containsKey('Group') ? json['Group'] as String : null,
      );
}

/// Describes modifications to the load permissions of an Amazon FPGA image
/// (AFI).
class LoadPermissionModifications {
  /// The load permissions to add.
  final List<LoadPermissionRequest> add;

  /// The load permissions to remove.
  final List<LoadPermissionRequest> remove;

  LoadPermissionModifications({
    this.add,
    this.remove,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a load permission.
class LoadPermissionRequest {
  /// The name of the group.
  final String group;

  /// The AWS account ID.
  final String userId;

  LoadPermissionRequest({
    this.group,
    this.userId,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

class ModifyCapacityReservationResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool return$;

  ModifyCapacityReservationResult({
    this.return$,
  });
  static ModifyCapacityReservationResult fromJson(Map<String, dynamic> json) =>
      ModifyCapacityReservationResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class ModifyClientVpnEndpointResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool return$;

  ModifyClientVpnEndpointResult({
    this.return$,
  });
  static ModifyClientVpnEndpointResult fromJson(Map<String, dynamic> json) =>
      ModifyClientVpnEndpointResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class ModifyEbsDefaultKmsKeyIdResult {
  /// The Amazon Resource Name (ARN) of the default CMK for encryption by
  /// default.
  final String kmsKeyId;

  ModifyEbsDefaultKmsKeyIdResult({
    this.kmsKeyId,
  });
  static ModifyEbsDefaultKmsKeyIdResult fromJson(Map<String, dynamic> json) =>
      ModifyEbsDefaultKmsKeyIdResult(
        kmsKeyId:
            json.containsKey('KmsKeyId') ? json['KmsKeyId'] as String : null,
      );
}

class ModifyFleetResult {
  /// Is `true` if the request succeeds, and an error otherwise.
  final bool return$;

  ModifyFleetResult({
    this.return$,
  });
  static ModifyFleetResult fromJson(Map<String, dynamic> json) =>
      ModifyFleetResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class ModifyFpgaImageAttributeResult {
  /// Information about the attribute.
  final FpgaImageAttribute fpgaImageAttribute;

  ModifyFpgaImageAttributeResult({
    this.fpgaImageAttribute,
  });
  static ModifyFpgaImageAttributeResult fromJson(Map<String, dynamic> json) =>
      ModifyFpgaImageAttributeResult(
        fpgaImageAttribute: json.containsKey('FpgaImageAttribute')
            ? FpgaImageAttribute.fromJson(json['FpgaImageAttribute'])
            : null,
      );
}

class ModifyHostsResult {
  /// The IDs of the Dedicated Hosts that were successfully modified.
  final List<String> successful;

  /// The IDs of the Dedicated Hosts that could not be modified. Check whether
  /// the setting you requested can be used.
  final List<UnsuccessfulItem> unsuccessful;

  ModifyHostsResult({
    this.successful,
    this.unsuccessful,
  });
  static ModifyHostsResult fromJson(Map<String, dynamic> json) =>
      ModifyHostsResult(
        successful: json.containsKey('Successful')
            ? (json['Successful'] as List).map((e) => e as String).toList()
            : null,
        unsuccessful: json.containsKey('Unsuccessful')
            ? (json['Unsuccessful'] as List)
                .map((e) => UnsuccessfulItem.fromJson(e))
                .toList()
            : null,
      );
}

class ModifyInstanceCapacityReservationAttributesResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool return$;

  ModifyInstanceCapacityReservationAttributesResult({
    this.return$,
  });
  static ModifyInstanceCapacityReservationAttributesResult fromJson(
          Map<String, dynamic> json) =>
      ModifyInstanceCapacityReservationAttributesResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class ModifyInstanceCreditSpecificationResult {
  /// Information about the instances whose credit option for CPU usage was
  /// successfully modified.
  final List<SuccessfulInstanceCreditSpecificationItem>
      successfulInstanceCreditSpecifications;

  /// Information about the instances whose credit option for CPU usage was not
  /// modified.
  final List<UnsuccessfulInstanceCreditSpecificationItem>
      unsuccessfulInstanceCreditSpecifications;

  ModifyInstanceCreditSpecificationResult({
    this.successfulInstanceCreditSpecifications,
    this.unsuccessfulInstanceCreditSpecifications,
  });
  static ModifyInstanceCreditSpecificationResult fromJson(
          Map<String, dynamic> json) =>
      ModifyInstanceCreditSpecificationResult(
        successfulInstanceCreditSpecifications:
            json.containsKey('SuccessfulInstanceCreditSpecifications')
                ? (json['SuccessfulInstanceCreditSpecifications'] as List)
                    .map((e) =>
                        SuccessfulInstanceCreditSpecificationItem.fromJson(e))
                    .toList()
                : null,
        unsuccessfulInstanceCreditSpecifications:
            json.containsKey('UnsuccessfulInstanceCreditSpecifications')
                ? (json['UnsuccessfulInstanceCreditSpecifications'] as List)
                    .map((e) =>
                        UnsuccessfulInstanceCreditSpecificationItem.fromJson(e))
                    .toList()
                : null,
      );
}

class ModifyInstanceEventStartTimeResult {
  final InstanceStatusEvent event;

  ModifyInstanceEventStartTimeResult({
    this.event,
  });
  static ModifyInstanceEventStartTimeResult fromJson(
          Map<String, dynamic> json) =>
      ModifyInstanceEventStartTimeResult(
        event: json.containsKey('Event')
            ? InstanceStatusEvent.fromJson(json['Event'])
            : null,
      );
}

class ModifyInstancePlacementResult {
  /// Is `true` if the request succeeds, and an error otherwise.
  final bool return$;

  ModifyInstancePlacementResult({
    this.return$,
  });
  static ModifyInstancePlacementResult fromJson(Map<String, dynamic> json) =>
      ModifyInstancePlacementResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class ModifyLaunchTemplateResult {
  /// Information about the launch template.
  final LaunchTemplate launchTemplate;

  ModifyLaunchTemplateResult({
    this.launchTemplate,
  });
  static ModifyLaunchTemplateResult fromJson(Map<String, dynamic> json) =>
      ModifyLaunchTemplateResult(
        launchTemplate: json.containsKey('LaunchTemplate')
            ? LaunchTemplate.fromJson(json['LaunchTemplate'])
            : null,
      );
}

/// Contains the output of ModifyReservedInstances.
class ModifyReservedInstancesResult {
  /// The ID for the modification.
  final String reservedInstancesModificationId;

  ModifyReservedInstancesResult({
    this.reservedInstancesModificationId,
  });
  static ModifyReservedInstancesResult fromJson(Map<String, dynamic> json) =>
      ModifyReservedInstancesResult(
        reservedInstancesModificationId:
            json.containsKey('ReservedInstancesModificationId')
                ? json['ReservedInstancesModificationId'] as String
                : null,
      );
}

/// Contains the output of ModifySpotFleetRequest.
class ModifySpotFleetRequestResponse {
  /// Is `true` if the request succeeds, and an error otherwise.
  final bool return$;

  ModifySpotFleetRequestResponse({
    this.return$,
  });
  static ModifySpotFleetRequestResponse fromJson(Map<String, dynamic> json) =>
      ModifySpotFleetRequestResponse(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class ModifyTrafficMirrorFilterNetworkServicesResult {
  /// The Traffic Mirror filter that the network service is associated with.
  final TrafficMirrorFilter trafficMirrorFilter;

  ModifyTrafficMirrorFilterNetworkServicesResult({
    this.trafficMirrorFilter,
  });
  static ModifyTrafficMirrorFilterNetworkServicesResult fromJson(
          Map<String, dynamic> json) =>
      ModifyTrafficMirrorFilterNetworkServicesResult(
        trafficMirrorFilter: json.containsKey('TrafficMirrorFilter')
            ? TrafficMirrorFilter.fromJson(json['TrafficMirrorFilter'])
            : null,
      );
}

class ModifyTrafficMirrorFilterRuleResult {
  /// Modifies a Traffic Mirror rule.
  final TrafficMirrorFilterRule trafficMirrorFilterRule;

  ModifyTrafficMirrorFilterRuleResult({
    this.trafficMirrorFilterRule,
  });
  static ModifyTrafficMirrorFilterRuleResult fromJson(
          Map<String, dynamic> json) =>
      ModifyTrafficMirrorFilterRuleResult(
        trafficMirrorFilterRule: json.containsKey('TrafficMirrorFilterRule')
            ? TrafficMirrorFilterRule.fromJson(json['TrafficMirrorFilterRule'])
            : null,
      );
}

class ModifyTrafficMirrorSessionResult {
  /// Information about the Traffic Mirror session.
  final TrafficMirrorSession trafficMirrorSession;

  ModifyTrafficMirrorSessionResult({
    this.trafficMirrorSession,
  });
  static ModifyTrafficMirrorSessionResult fromJson(Map<String, dynamic> json) =>
      ModifyTrafficMirrorSessionResult(
        trafficMirrorSession: json.containsKey('TrafficMirrorSession')
            ? TrafficMirrorSession.fromJson(json['TrafficMirrorSession'])
            : null,
      );
}

/// Describes the options for a VPC attachment.
class ModifyTransitGatewayVpcAttachmentRequestOptions {
  /// Enable or disable DNS support. The default is `enable`.
  final String dnsSupport;

  /// Enable or disable IPv6 support. The default is `enable`.
  final String ipv6Support;

  ModifyTransitGatewayVpcAttachmentRequestOptions({
    this.dnsSupport,
    this.ipv6Support,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

class ModifyTransitGatewayVpcAttachmentResult {
  /// Information about the modified attachment.
  final TransitGatewayVpcAttachment transitGatewayVpcAttachment;

  ModifyTransitGatewayVpcAttachmentResult({
    this.transitGatewayVpcAttachment,
  });
  static ModifyTransitGatewayVpcAttachmentResult fromJson(
          Map<String, dynamic> json) =>
      ModifyTransitGatewayVpcAttachmentResult(
        transitGatewayVpcAttachment:
            json.containsKey('TransitGatewayVpcAttachment')
                ? TransitGatewayVpcAttachment.fromJson(
                    json['TransitGatewayVpcAttachment'])
                : null,
      );
}

class ModifyVolumeResult {
  /// Information about the volume modification.
  final VolumeModification volumeModification;

  ModifyVolumeResult({
    this.volumeModification,
  });
  static ModifyVolumeResult fromJson(Map<String, dynamic> json) =>
      ModifyVolumeResult(
        volumeModification: json.containsKey('VolumeModification')
            ? VolumeModification.fromJson(json['VolumeModification'])
            : null,
      );
}

class ModifyVpcEndpointConnectionNotificationResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool returnValue;

  ModifyVpcEndpointConnectionNotificationResult({
    this.returnValue,
  });
  static ModifyVpcEndpointConnectionNotificationResult fromJson(
          Map<String, dynamic> json) =>
      ModifyVpcEndpointConnectionNotificationResult(
        returnValue: json.containsKey('ReturnValue')
            ? json['ReturnValue'] as bool
            : null,
      );
}

class ModifyVpcEndpointResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool return$;

  ModifyVpcEndpointResult({
    this.return$,
  });
  static ModifyVpcEndpointResult fromJson(Map<String, dynamic> json) =>
      ModifyVpcEndpointResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class ModifyVpcEndpointServiceConfigurationResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool return$;

  ModifyVpcEndpointServiceConfigurationResult({
    this.return$,
  });
  static ModifyVpcEndpointServiceConfigurationResult fromJson(
          Map<String, dynamic> json) =>
      ModifyVpcEndpointServiceConfigurationResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class ModifyVpcEndpointServicePermissionsResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool returnValue;

  ModifyVpcEndpointServicePermissionsResult({
    this.returnValue,
  });
  static ModifyVpcEndpointServicePermissionsResult fromJson(
          Map<String, dynamic> json) =>
      ModifyVpcEndpointServicePermissionsResult(
        returnValue: json.containsKey('ReturnValue')
            ? json['ReturnValue'] as bool
            : null,
      );
}

class ModifyVpcPeeringConnectionOptionsResult {
  /// Information about the VPC peering connection options for the accepter VPC.
  final PeeringConnectionOptions accepterPeeringConnectionOptions;

  /// Information about the VPC peering connection options for the requester
  /// VPC.
  final PeeringConnectionOptions requesterPeeringConnectionOptions;

  ModifyVpcPeeringConnectionOptionsResult({
    this.accepterPeeringConnectionOptions,
    this.requesterPeeringConnectionOptions,
  });
  static ModifyVpcPeeringConnectionOptionsResult fromJson(
          Map<String, dynamic> json) =>
      ModifyVpcPeeringConnectionOptionsResult(
        accepterPeeringConnectionOptions:
            json.containsKey('AccepterPeeringConnectionOptions')
                ? PeeringConnectionOptions.fromJson(
                    json['AccepterPeeringConnectionOptions'])
                : null,
        requesterPeeringConnectionOptions:
            json.containsKey('RequesterPeeringConnectionOptions')
                ? PeeringConnectionOptions.fromJson(
                    json['RequesterPeeringConnectionOptions'])
                : null,
      );
}

class ModifyVpcTenancyResult {
  /// Returns `true` if the request succeeds; otherwise, returns an error.
  final bool returnValue;

  ModifyVpcTenancyResult({
    this.returnValue,
  });
  static ModifyVpcTenancyResult fromJson(Map<String, dynamic> json) =>
      ModifyVpcTenancyResult(
        returnValue: json.containsKey('ReturnValue')
            ? json['ReturnValue'] as bool
            : null,
      );
}

class ModifyVpnConnectionResult {
  final VpnConnection vpnConnection;

  ModifyVpnConnectionResult({
    this.vpnConnection,
  });
  static ModifyVpnConnectionResult fromJson(Map<String, dynamic> json) =>
      ModifyVpnConnectionResult(
        vpnConnection: json.containsKey('VpnConnection')
            ? VpnConnection.fromJson(json['VpnConnection'])
            : null,
      );
}

class ModifyVpnTunnelCertificateResult {
  final VpnConnection vpnConnection;

  ModifyVpnTunnelCertificateResult({
    this.vpnConnection,
  });
  static ModifyVpnTunnelCertificateResult fromJson(Map<String, dynamic> json) =>
      ModifyVpnTunnelCertificateResult(
        vpnConnection: json.containsKey('VpnConnection')
            ? VpnConnection.fromJson(json['VpnConnection'])
            : null,
      );
}

class ModifyVpnTunnelOptionsResult {
  final VpnConnection vpnConnection;

  ModifyVpnTunnelOptionsResult({
    this.vpnConnection,
  });
  static ModifyVpnTunnelOptionsResult fromJson(Map<String, dynamic> json) =>
      ModifyVpnTunnelOptionsResult(
        vpnConnection: json.containsKey('VpnConnection')
            ? VpnConnection.fromJson(json['VpnConnection'])
            : null,
      );
}

/// The AWS Site-to-Site VPN tunnel options to modify.
class ModifyVpnTunnelOptionsSpecification {
  /// The range of inside IP addresses for the tunnel. Any specified CIDR blocks
  /// must be unique across all VPN connections that use the same virtual
  /// private gateway.
  ///
  /// Constraints: A size /30 CIDR block from the `169.254.0.0/16` range. The
  /// following CIDR blocks are reserved and cannot be used:
  ///
  /// *    `169.254.0.0/30`
  ///
  /// *    `169.254.1.0/30`
  ///
  /// *    `169.254.2.0/30`
  ///
  /// *    `169.254.3.0/30`
  ///
  /// *    `169.254.4.0/30`
  ///
  /// *    `169.254.5.0/30`
  ///
  /// *    `169.254.169.252/30`
  final String tunnelInsideCidr;

  /// The pre-shared key (PSK) to establish initial authentication between the
  /// virtual private gateway and the customer gateway.
  ///
  /// Constraints: Allowed characters are alphanumeric characters, periods (.),
  /// and underscores (_). Must be between 8 and 64 characters in length and
  /// cannot start with zero (0).
  final String preSharedKey;

  /// The lifetime for phase 1 of the IKE negotiation, in seconds.
  ///
  /// Constraints: A value between 900 and 28,800.
  ///
  /// Default: `28800`
  final int phase1LifetimeSeconds;

  /// The lifetime for phase 2 of the IKE negotiation, in seconds.
  ///
  /// Constraints: A value between 900 and 3,600. The value must be less than
  /// the value for `Phase1LifetimeSeconds`.
  ///
  /// Default: `3600`
  final int phase2LifetimeSeconds;

  /// The margin time, in seconds, before the phase 2 lifetime expires, during
  /// which the AWS side of the VPN connection performs an IKE rekey. The exact
  /// time of the rekey is randomly selected based on the value for
  /// `RekeyFuzzPercentage`.
  ///
  /// Constraints: A value between 60 and half of `Phase2LifetimeSeconds`.
  ///
  /// Default: `540`
  final int rekeyMarginTimeSeconds;

  /// The percentage of the rekey window (determined by
  /// `RekeyMarginTimeSeconds`) during which the rekey time is randomly
  /// selected.
  ///
  /// Constraints: A value between 0 and 100.
  ///
  /// Default: `100`
  final int rekeyFuzzPercentage;

  /// The number of packets in an IKE replay window.
  ///
  /// Constraints: A value between 64 and 2048.
  ///
  /// Default: `1024`
  final int replayWindowSize;

  /// The number of seconds after which a DPD timeout occurs.
  ///
  /// Constraints: A value between 0 and 30.
  ///
  /// Default: `30`
  final int dpdTimeoutSeconds;

  /// One or more encryption algorithms that are permitted for the VPN tunnel
  /// for phase 1 IKE negotiations.
  ///
  /// Valid values: `AES128` | `AES256`
  final List<Phase1EncryptionAlgorithmsRequestListValue>
      phase1EncryptionAlgorithms;

  /// One or more encryption algorithms that are permitted for the VPN tunnel
  /// for phase 2 IKE negotiations.
  ///
  /// Valid values: `AES128` | `AES256`
  final List<Phase2EncryptionAlgorithmsRequestListValue>
      phase2EncryptionAlgorithms;

  /// One or more integrity algorithms that are permitted for the VPN tunnel for
  /// phase 1 IKE negotiations.
  ///
  /// Valid values: `SHA1` | `SHA2-256`
  final List<Phase1IntegrityAlgorithmsRequestListValue>
      phase1IntegrityAlgorithms;

  /// One or more integrity algorithms that are permitted for the VPN tunnel for
  /// phase 2 IKE negotiations.
  ///
  /// Valid values: `SHA1` | `SHA2-256`
  final List<Phase2IntegrityAlgorithmsRequestListValue>
      phase2IntegrityAlgorithms;

  /// One or more Diffie-Hellman group numbers that are permitted for the VPN
  /// tunnel for phase 1 IKE negotiations.
  ///
  /// Valid values: `2` | `14` | `15` | `16` | `17` | `18` | `22` | `23` | `24`
  final List<Phase1dhGroupNumbersRequestListValue> phase1dhGroupNumbers;

  /// One or more Diffie-Hellman group numbers that are permitted for the VPN
  /// tunnel for phase 2 IKE negotiations.
  ///
  /// Valid values: `2` | `5` | `14` | `15` | `16` | `17` | `18` | `22` | `23` |
  /// `24`
  final List<Phase2dhGroupNumbersRequestListValue> phase2dhGroupNumbers;

  /// The IKE versions that are permitted for the VPN tunnel.
  ///
  /// Valid values: `ikev1` | `ikev2`
  final List<IkeVersionsRequestListValue> ikeVersions;

  ModifyVpnTunnelOptionsSpecification({
    this.tunnelInsideCidr,
    this.preSharedKey,
    this.phase1LifetimeSeconds,
    this.phase2LifetimeSeconds,
    this.rekeyMarginTimeSeconds,
    this.rekeyFuzzPercentage,
    this.replayWindowSize,
    this.dpdTimeoutSeconds,
    this.phase1EncryptionAlgorithms,
    this.phase2EncryptionAlgorithms,
    this.phase1IntegrityAlgorithms,
    this.phase2IntegrityAlgorithms,
    this.phase1dhGroupNumbers,
    this.phase2dhGroupNumbers,
    this.ikeVersions,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

class MonitorInstancesResult {
  /// The monitoring information.
  final List<InstanceMonitoring> instanceMonitorings;

  MonitorInstancesResult({
    this.instanceMonitorings,
  });
  static MonitorInstancesResult fromJson(Map<String, dynamic> json) =>
      MonitorInstancesResult(
        instanceMonitorings: json.containsKey('InstanceMonitorings')
            ? (json['InstanceMonitorings'] as List)
                .map((e) => InstanceMonitoring.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes the monitoring of an instance.
class Monitoring {
  /// Indicates whether detailed monitoring is enabled. Otherwise, basic
  /// monitoring is enabled.
  final String state;

  Monitoring({
    this.state,
  });
  static Monitoring fromJson(Map<String, dynamic> json) => Monitoring(
        state: json.containsKey('State') ? json['State'] as String : null,
      );
}

class MoveAddressToVpcResult {
  /// The allocation ID for the Elastic IP address.
  final String allocationId;

  /// The status of the move of the IP address.
  final String status;

  MoveAddressToVpcResult({
    this.allocationId,
    this.status,
  });
  static MoveAddressToVpcResult fromJson(Map<String, dynamic> json) =>
      MoveAddressToVpcResult(
        allocationId: json.containsKey('AllocationId')
            ? json['AllocationId'] as String
            : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
      );
}

/// Describes the status of a moving Elastic IP address.
class MovingAddressStatus {
  /// The status of the Elastic IP address that's being moved to the EC2-VPC
  /// platform, or restored to the EC2-Classic platform.
  final String moveStatus;

  /// The Elastic IP address.
  final String publicIp;

  MovingAddressStatus({
    this.moveStatus,
    this.publicIp,
  });
  static MovingAddressStatus fromJson(Map<String, dynamic> json) =>
      MovingAddressStatus(
        moveStatus: json.containsKey('MoveStatus')
            ? json['MoveStatus'] as String
            : null,
        publicIp:
            json.containsKey('PublicIp') ? json['PublicIp'] as String : null,
      );
}

/// Describes a NAT gateway.
class NatGateway {
  /// The date and time the NAT gateway was created.
  final DateTime createTime;

  /// The date and time the NAT gateway was deleted, if applicable.
  final DateTime deleteTime;

  /// If the NAT gateway could not be created, specifies the error code for the
  /// failure. (`InsufficientFreeAddressesInSubnet` | `Gateway.NotAttached` |
  /// `InvalidAllocationID.NotFound` | `Resource.AlreadyAssociated` |
  /// `InternalError` | `InvalidSubnetID.NotFound`)
  final String failureCode;

  /// If the NAT gateway could not be created, specifies the error message for
  /// the failure, that corresponds to the error code.
  ///
  /// *   For InsufficientFreeAddressesInSubnet: "Subnet has insufficient free
  /// addresses to create this NAT gateway"
  ///
  /// *   For Gateway.NotAttached: "Network vpc-xxxxxxxx has no Internet gateway
  /// attached"
  ///
  /// *   For InvalidAllocationID.NotFound: "Elastic IP address
  /// eipalloc-xxxxxxxx could not be associated with this NAT gateway"
  ///
  /// *   For Resource.AlreadyAssociated: "Elastic IP address eipalloc-xxxxxxxx
  /// is already associated"
  ///
  /// *   For InternalError: "Network interface eni-xxxxxxxx, created and used
  /// internally by this NAT gateway is in an invalid state. Please try again."
  ///
  /// *   For InvalidSubnetID.NotFound: "The specified subnet subnet-xxxxxxxx
  /// does not exist or could not be found."
  final String failureMessage;

  /// Information about the IP addresses and network interface associated with
  /// the NAT gateway.
  final List<NatGatewayAddress> natGatewayAddresses;

  /// The ID of the NAT gateway.
  final String natGatewayId;

  /// Reserved. If you need to sustain traffic greater than the
  /// [documented limits](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html),
  /// contact us through the
  /// [Support Center](https://console.aws.amazon.com/support/home?).
  final ProvisionedBandwidth provisionedBandwidth;

  /// The state of the NAT gateway.
  ///
  /// *    `pending`: The NAT gateway is being created and is not ready to
  /// process traffic.
  ///
  /// *    `failed`: The NAT gateway could not be created. Check the
  /// `failureCode` and `failureMessage` fields for the reason.
  ///
  /// *    `available`: The NAT gateway is able to process traffic. This status
  /// remains until you delete the NAT gateway, and does not indicate the health
  /// of the NAT gateway.
  ///
  /// *    `deleting`: The NAT gateway is in the process of being terminated and
  /// may still be processing traffic.
  ///
  /// *    `deleted`: The NAT gateway has been terminated and is no longer
  /// processing traffic.
  final String state;

  /// The ID of the subnet in which the NAT gateway is located.
  final String subnetId;

  /// The ID of the VPC in which the NAT gateway is located.
  final String vpcId;

  /// The tags for the NAT gateway.
  final List<Tag> tags;

  NatGateway({
    this.createTime,
    this.deleteTime,
    this.failureCode,
    this.failureMessage,
    this.natGatewayAddresses,
    this.natGatewayId,
    this.provisionedBandwidth,
    this.state,
    this.subnetId,
    this.vpcId,
    this.tags,
  });
  static NatGateway fromJson(Map<String, dynamic> json) => NatGateway(
        createTime: json.containsKey('CreateTime')
            ? DateTime.parse(json['CreateTime'])
            : null,
        deleteTime: json.containsKey('DeleteTime')
            ? DateTime.parse(json['DeleteTime'])
            : null,
        failureCode: json.containsKey('FailureCode')
            ? json['FailureCode'] as String
            : null,
        failureMessage: json.containsKey('FailureMessage')
            ? json['FailureMessage'] as String
            : null,
        natGatewayAddresses: json.containsKey('NatGatewayAddresses')
            ? (json['NatGatewayAddresses'] as List)
                .map((e) => NatGatewayAddress.fromJson(e))
                .toList()
            : null,
        natGatewayId: json.containsKey('NatGatewayId')
            ? json['NatGatewayId'] as String
            : null,
        provisionedBandwidth: json.containsKey('ProvisionedBandwidth')
            ? ProvisionedBandwidth.fromJson(json['ProvisionedBandwidth'])
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        subnetId:
            json.containsKey('SubnetId') ? json['SubnetId'] as String : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes the IP addresses and network interface associated with a NAT
/// gateway.
class NatGatewayAddress {
  /// The allocation ID of the Elastic IP address that's associated with the NAT
  /// gateway.
  final String allocationId;

  /// The ID of the network interface associated with the NAT gateway.
  final String networkInterfaceId;

  /// The private IP address associated with the Elastic IP address.
  final String privateIp;

  /// The Elastic IP address associated with the NAT gateway.
  final String publicIp;

  NatGatewayAddress({
    this.allocationId,
    this.networkInterfaceId,
    this.privateIp,
    this.publicIp,
  });
  static NatGatewayAddress fromJson(Map<String, dynamic> json) =>
      NatGatewayAddress(
        allocationId: json.containsKey('AllocationId')
            ? json['AllocationId'] as String
            : null,
        networkInterfaceId: json.containsKey('NetworkInterfaceId')
            ? json['NetworkInterfaceId'] as String
            : null,
        privateIp:
            json.containsKey('PrivateIp') ? json['PrivateIp'] as String : null,
        publicIp:
            json.containsKey('PublicIp') ? json['PublicIp'] as String : null,
      );
}

/// Describes a network ACL.
class NetworkAcl {
  /// Any associations between the network ACL and one or more subnets
  final List<NetworkAclAssociation> associations;

  /// One or more entries (rules) in the network ACL.
  final List<NetworkAclEntry> entries;

  /// Indicates whether this is the default network ACL for the VPC.
  final bool isDefault;

  /// The ID of the network ACL.
  final String networkAclId;

  /// Any tags assigned to the network ACL.
  final List<Tag> tags;

  /// The ID of the VPC for the network ACL.
  final String vpcId;

  /// The ID of the AWS account that owns the network ACL.
  final String ownerId;

  NetworkAcl({
    this.associations,
    this.entries,
    this.isDefault,
    this.networkAclId,
    this.tags,
    this.vpcId,
    this.ownerId,
  });
  static NetworkAcl fromJson(Map<String, dynamic> json) => NetworkAcl(
        associations: json.containsKey('Associations')
            ? (json['Associations'] as List)
                .map((e) => NetworkAclAssociation.fromJson(e))
                .toList()
            : null,
        entries: json.containsKey('Entries')
            ? (json['Entries'] as List)
                .map((e) => NetworkAclEntry.fromJson(e))
                .toList()
            : null,
        isDefault:
            json.containsKey('IsDefault') ? json['IsDefault'] as bool : null,
        networkAclId: json.containsKey('NetworkAclId')
            ? json['NetworkAclId'] as String
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
      );
}

/// Describes an association between a network ACL and a subnet.
class NetworkAclAssociation {
  /// The ID of the association between a network ACL and a subnet.
  final String networkAclAssociationId;

  /// The ID of the network ACL.
  final String networkAclId;

  /// The ID of the subnet.
  final String subnetId;

  NetworkAclAssociation({
    this.networkAclAssociationId,
    this.networkAclId,
    this.subnetId,
  });
  static NetworkAclAssociation fromJson(Map<String, dynamic> json) =>
      NetworkAclAssociation(
        networkAclAssociationId: json.containsKey('NetworkAclAssociationId')
            ? json['NetworkAclAssociationId'] as String
            : null,
        networkAclId: json.containsKey('NetworkAclId')
            ? json['NetworkAclId'] as String
            : null,
        subnetId:
            json.containsKey('SubnetId') ? json['SubnetId'] as String : null,
      );
}

/// Describes an entry in a network ACL.
class NetworkAclEntry {
  /// The IPv4 network range to allow or deny, in CIDR notation.
  final String cidrBlock;

  /// Indicates whether the rule is an egress rule (applied to traffic leaving
  /// the subnet).
  final bool egress;

  /// ICMP protocol: The ICMP type and code.
  final IcmpTypeCode icmpTypeCode;

  /// The IPv6 network range to allow or deny, in CIDR notation.
  final String ipv6CidrBlock;

  /// TCP or UDP protocols: The range of ports the rule applies to.
  final PortRange portRange;

  /// The protocol number. A value of "-1" means all protocols.
  final String protocol;

  /// Indicates whether to allow or deny the traffic that matches the rule.
  final String ruleAction;

  /// The rule number for the entry. ACL entries are processed in ascending
  /// order by rule number.
  final int ruleNumber;

  NetworkAclEntry({
    this.cidrBlock,
    this.egress,
    this.icmpTypeCode,
    this.ipv6CidrBlock,
    this.portRange,
    this.protocol,
    this.ruleAction,
    this.ruleNumber,
  });
  static NetworkAclEntry fromJson(Map<String, dynamic> json) => NetworkAclEntry(
        cidrBlock:
            json.containsKey('CidrBlock') ? json['CidrBlock'] as String : null,
        egress: json.containsKey('Egress') ? json['Egress'] as bool : null,
        icmpTypeCode: json.containsKey('IcmpTypeCode')
            ? IcmpTypeCode.fromJson(json['IcmpTypeCode'])
            : null,
        ipv6CidrBlock: json.containsKey('Ipv6CidrBlock')
            ? json['Ipv6CidrBlock'] as String
            : null,
        portRange: json.containsKey('PortRange')
            ? PortRange.fromJson(json['PortRange'])
            : null,
        protocol:
            json.containsKey('Protocol') ? json['Protocol'] as String : null,
        ruleAction: json.containsKey('RuleAction')
            ? json['RuleAction'] as String
            : null,
        ruleNumber:
            json.containsKey('RuleNumber') ? json['RuleNumber'] as int : null,
      );
}

/// Describes a network interface.
class NetworkInterface {
  /// The association information for an Elastic IP address (IPv4) associated
  /// with the network interface.
  final NetworkInterfaceAssociation association;

  /// The network interface attachment.
  final NetworkInterfaceAttachment attachment;

  /// The Availability Zone.
  final String availabilityZone;

  /// A description.
  final String description;

  /// Any security groups for the network interface.
  final List<GroupIdentifier> groups;

  /// The type of network interface.
  final String interfaceType;

  /// The IPv6 addresses associated with the network interface.
  final List<NetworkInterfaceIpv6Address> ipv6Addresses;

  /// The MAC address.
  final String macAddress;

  /// The ID of the network interface.
  final String networkInterfaceId;

  /// The AWS account ID of the owner of the network interface.
  final String ownerId;

  /// The private DNS name.
  final String privateDnsName;

  /// The IPv4 address of the network interface within the subnet.
  final String privateIpAddress;

  /// The private IPv4 addresses associated with the network interface.
  final List<NetworkInterfacePrivateIpAddress> privateIpAddresses;

  /// The ID of the entity that launched the instance on your behalf (for
  /// example, AWS Management Console or Auto Scaling).
  final String requesterId;

  /// Indicates whether the network interface is being managed by AWS.
  final bool requesterManaged;

  /// Indicates whether traffic to or from the instance is validated.
  final bool sourceDestCheck;

  /// The status of the network interface.
  final String status;

  /// The ID of the subnet.
  final String subnetId;

  /// Any tags assigned to the network interface.
  final List<Tag> tagSet;

  /// The ID of the VPC.
  final String vpcId;

  NetworkInterface({
    this.association,
    this.attachment,
    this.availabilityZone,
    this.description,
    this.groups,
    this.interfaceType,
    this.ipv6Addresses,
    this.macAddress,
    this.networkInterfaceId,
    this.ownerId,
    this.privateDnsName,
    this.privateIpAddress,
    this.privateIpAddresses,
    this.requesterId,
    this.requesterManaged,
    this.sourceDestCheck,
    this.status,
    this.subnetId,
    this.tagSet,
    this.vpcId,
  });
  static NetworkInterface fromJson(Map<String, dynamic> json) =>
      NetworkInterface(
        association: json.containsKey('Association')
            ? NetworkInterfaceAssociation.fromJson(json['Association'])
            : null,
        attachment: json.containsKey('Attachment')
            ? NetworkInterfaceAttachment.fromJson(json['Attachment'])
            : null,
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        groups: json.containsKey('Groups')
            ? (json['Groups'] as List)
                .map((e) => GroupIdentifier.fromJson(e))
                .toList()
            : null,
        interfaceType: json.containsKey('InterfaceType')
            ? json['InterfaceType'] as String
            : null,
        ipv6Addresses: json.containsKey('Ipv6Addresses')
            ? (json['Ipv6Addresses'] as List)
                .map((e) => NetworkInterfaceIpv6Address.fromJson(e))
                .toList()
            : null,
        macAddress: json.containsKey('MacAddress')
            ? json['MacAddress'] as String
            : null,
        networkInterfaceId: json.containsKey('NetworkInterfaceId')
            ? json['NetworkInterfaceId'] as String
            : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        privateDnsName: json.containsKey('PrivateDnsName')
            ? json['PrivateDnsName'] as String
            : null,
        privateIpAddress: json.containsKey('PrivateIpAddress')
            ? json['PrivateIpAddress'] as String
            : null,
        privateIpAddresses: json.containsKey('PrivateIpAddresses')
            ? (json['PrivateIpAddresses'] as List)
                .map((e) => NetworkInterfacePrivateIpAddress.fromJson(e))
                .toList()
            : null,
        requesterId: json.containsKey('RequesterId')
            ? json['RequesterId'] as String
            : null,
        requesterManaged: json.containsKey('RequesterManaged')
            ? json['RequesterManaged'] as bool
            : null,
        sourceDestCheck: json.containsKey('SourceDestCheck')
            ? json['SourceDestCheck'] as bool
            : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
        subnetId:
            json.containsKey('SubnetId') ? json['SubnetId'] as String : null,
        tagSet: json.containsKey('TagSet')
            ? (json['TagSet'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
      );
}

/// Describes association information for an Elastic IP address (IPv4 only).
class NetworkInterfaceAssociation {
  /// The allocation ID.
  final String allocationId;

  /// The association ID.
  final String associationId;

  /// The ID of the Elastic IP address owner.
  final String ipOwnerId;

  /// The public DNS name.
  final String publicDnsName;

  /// The address of the Elastic IP address bound to the network interface.
  final String publicIp;

  NetworkInterfaceAssociation({
    this.allocationId,
    this.associationId,
    this.ipOwnerId,
    this.publicDnsName,
    this.publicIp,
  });
  static NetworkInterfaceAssociation fromJson(Map<String, dynamic> json) =>
      NetworkInterfaceAssociation(
        allocationId: json.containsKey('AllocationId')
            ? json['AllocationId'] as String
            : null,
        associationId: json.containsKey('AssociationId')
            ? json['AssociationId'] as String
            : null,
        ipOwnerId:
            json.containsKey('IpOwnerId') ? json['IpOwnerId'] as String : null,
        publicDnsName: json.containsKey('PublicDnsName')
            ? json['PublicDnsName'] as String
            : null,
        publicIp:
            json.containsKey('PublicIp') ? json['PublicIp'] as String : null,
      );
}

/// Describes a network interface attachment.
class NetworkInterfaceAttachment {
  /// The timestamp indicating when the attachment initiated.
  final DateTime attachTime;

  /// The ID of the network interface attachment.
  final String attachmentId;

  /// Indicates whether the network interface is deleted when the instance is
  /// terminated.
  final bool deleteOnTermination;

  /// The device index of the network interface attachment on the instance.
  final int deviceIndex;

  /// The ID of the instance.
  final String instanceId;

  /// The AWS account ID of the owner of the instance.
  final String instanceOwnerId;

  /// The attachment state.
  final String status;

  NetworkInterfaceAttachment({
    this.attachTime,
    this.attachmentId,
    this.deleteOnTermination,
    this.deviceIndex,
    this.instanceId,
    this.instanceOwnerId,
    this.status,
  });
  static NetworkInterfaceAttachment fromJson(Map<String, dynamic> json) =>
      NetworkInterfaceAttachment(
        attachTime: json.containsKey('AttachTime')
            ? DateTime.parse(json['AttachTime'])
            : null,
        attachmentId: json.containsKey('AttachmentId')
            ? json['AttachmentId'] as String
            : null,
        deleteOnTermination: json.containsKey('DeleteOnTermination')
            ? json['DeleteOnTermination'] as bool
            : null,
        deviceIndex:
            json.containsKey('DeviceIndex') ? json['DeviceIndex'] as int : null,
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        instanceOwnerId: json.containsKey('InstanceOwnerId')
            ? json['InstanceOwnerId'] as String
            : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
      );
}

/// Describes an attachment change.
class NetworkInterfaceAttachmentChanges {
  /// The ID of the network interface attachment.
  final String attachmentId;

  /// Indicates whether the network interface is deleted when the instance is
  /// terminated.
  final bool deleteOnTermination;

  NetworkInterfaceAttachmentChanges({
    this.attachmentId,
    this.deleteOnTermination,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes an IPv6 address associated with a network interface.
class NetworkInterfaceIpv6Address {
  /// The IPv6 address.
  final String ipv6Address;

  NetworkInterfaceIpv6Address({
    this.ipv6Address,
  });
  static NetworkInterfaceIpv6Address fromJson(Map<String, dynamic> json) =>
      NetworkInterfaceIpv6Address(
        ipv6Address: json.containsKey('Ipv6Address')
            ? json['Ipv6Address'] as String
            : null,
      );
}

/// Describes a permission for a network interface.
class NetworkInterfacePermission {
  /// The ID of the network interface permission.
  final String networkInterfacePermissionId;

  /// The ID of the network interface.
  final String networkInterfaceId;

  /// The AWS account ID.
  final String awsAccountId;

  /// The AWS service.
  final String awsService;

  /// The type of permission.
  final String permission;

  /// Information about the state of the permission.
  final NetworkInterfacePermissionState permissionState;

  NetworkInterfacePermission({
    this.networkInterfacePermissionId,
    this.networkInterfaceId,
    this.awsAccountId,
    this.awsService,
    this.permission,
    this.permissionState,
  });
  static NetworkInterfacePermission fromJson(Map<String, dynamic> json) =>
      NetworkInterfacePermission(
        networkInterfacePermissionId:
            json.containsKey('NetworkInterfacePermissionId')
                ? json['NetworkInterfacePermissionId'] as String
                : null,
        networkInterfaceId: json.containsKey('NetworkInterfaceId')
            ? json['NetworkInterfaceId'] as String
            : null,
        awsAccountId: json.containsKey('AwsAccountId')
            ? json['AwsAccountId'] as String
            : null,
        awsService: json.containsKey('AwsService')
            ? json['AwsService'] as String
            : null,
        permission: json.containsKey('Permission')
            ? json['Permission'] as String
            : null,
        permissionState: json.containsKey('PermissionState')
            ? NetworkInterfacePermissionState.fromJson(json['PermissionState'])
            : null,
      );
}

/// Describes the state of a network interface permission.
class NetworkInterfacePermissionState {
  /// The state of the permission.
  final String state;

  /// A status message, if applicable.
  final String statusMessage;

  NetworkInterfacePermissionState({
    this.state,
    this.statusMessage,
  });
  static NetworkInterfacePermissionState fromJson(Map<String, dynamic> json) =>
      NetworkInterfacePermissionState(
        state: json.containsKey('State') ? json['State'] as String : null,
        statusMessage: json.containsKey('StatusMessage')
            ? json['StatusMessage'] as String
            : null,
      );
}

/// Describes the private IPv4 address of a network interface.
class NetworkInterfacePrivateIpAddress {
  /// The association information for an Elastic IP address (IPv4) associated
  /// with the network interface.
  final NetworkInterfaceAssociation association;

  /// Indicates whether this IPv4 address is the primary private IPv4 address of
  /// the network interface.
  final bool primary;

  /// The private DNS name.
  final String privateDnsName;

  /// The private IPv4 address.
  final String privateIpAddress;

  NetworkInterfacePrivateIpAddress({
    this.association,
    this.primary,
    this.privateDnsName,
    this.privateIpAddress,
  });
  static NetworkInterfacePrivateIpAddress fromJson(Map<String, dynamic> json) =>
      NetworkInterfacePrivateIpAddress(
        association: json.containsKey('Association')
            ? NetworkInterfaceAssociation.fromJson(json['Association'])
            : null,
        primary: json.containsKey('Primary') ? json['Primary'] as bool : null,
        privateDnsName: json.containsKey('PrivateDnsName')
            ? json['PrivateDnsName'] as String
            : null,
        privateIpAddress: json.containsKey('PrivateIpAddress')
            ? json['PrivateIpAddress'] as String
            : null,
      );
}

class NewDhcpConfiguration {
  final String key;

  final List<String> values;

  NewDhcpConfiguration({
    this.key,
    this.values,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the configuration of On-Demand Instances in an EC2 Fleet.
class OnDemandOptions {
  /// The order of the launch template overrides to use in fulfilling On-Demand
  /// capacity. If you specify `lowest-price`, EC2 Fleet uses price to determine
  /// the order, launching the lowest price first. If you specify `prioritized`,
  /// EC2 Fleet uses the priority that you assigned to each launch template
  /// override, launching the highest priority first. If you do not specify a
  /// value, EC2 Fleet defaults to `lowest-price`.
  final String allocationStrategy;

  /// Indicates that the fleet uses a single instance type to launch all
  /// On-Demand Instances in the fleet.
  final bool singleInstanceType;

  /// Indicates that the fleet launches all On-Demand Instances into a single
  /// Availability Zone.
  final bool singleAvailabilityZone;

  /// The minimum target capacity for On-Demand Instances in the fleet. If the
  /// minimum target capacity is not reached, the fleet launches no instances.
  final int minTargetCapacity;

  /// The maximum amount per hour for On-Demand Instances that you're willing to
  /// pay.
  final String maxTotalPrice;

  OnDemandOptions({
    this.allocationStrategy,
    this.singleInstanceType,
    this.singleAvailabilityZone,
    this.minTargetCapacity,
    this.maxTotalPrice,
  });
  static OnDemandOptions fromJson(Map<String, dynamic> json) => OnDemandOptions(
        allocationStrategy: json.containsKey('AllocationStrategy')
            ? json['AllocationStrategy'] as String
            : null,
        singleInstanceType: json.containsKey('SingleInstanceType')
            ? json['SingleInstanceType'] as bool
            : null,
        singleAvailabilityZone: json.containsKey('SingleAvailabilityZone')
            ? json['SingleAvailabilityZone'] as bool
            : null,
        minTargetCapacity: json.containsKey('MinTargetCapacity')
            ? json['MinTargetCapacity'] as int
            : null,
        maxTotalPrice: json.containsKey('MaxTotalPrice')
            ? json['MaxTotalPrice'] as String
            : null,
      );
}

/// Describes the configuration of On-Demand Instances in an EC2 Fleet.
class OnDemandOptionsRequest {
  /// The order of the launch template overrides to use in fulfilling On-Demand
  /// capacity. If you specify `lowest-price`, EC2 Fleet uses price to determine
  /// the order, launching the lowest price first. If you specify `prioritized`,
  /// EC2 Fleet uses the priority that you assigned to each launch template
  /// override, launching the highest priority first. If you do not specify a
  /// value, EC2 Fleet defaults to `lowest-price`.
  final String allocationStrategy;

  /// Indicates that the fleet uses a single instance type to launch all
  /// On-Demand Instances in the fleet.
  final bool singleInstanceType;

  /// Indicates that the fleet launches all On-Demand Instances into a single
  /// Availability Zone.
  final bool singleAvailabilityZone;

  /// The minimum target capacity for On-Demand Instances in the fleet. If the
  /// minimum target capacity is not reached, the fleet launches no instances.
  final int minTargetCapacity;

  /// The maximum amount per hour for On-Demand Instances that you're willing to
  /// pay.
  final String maxTotalPrice;

  OnDemandOptionsRequest({
    this.allocationStrategy,
    this.singleInstanceType,
    this.singleAvailabilityZone,
    this.minTargetCapacity,
    this.maxTotalPrice,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the data that identifies an Amazon FPGA image (AFI) on the PCI
/// bus.
class PciId {
  /// The ID of the device.
  final String deviceId;

  /// The ID of the vendor.
  final String vendorId;

  /// The ID of the subsystem.
  final String subsystemId;

  /// The ID of the vendor for the subsystem.
  final String subsystemVendorId;

  PciId({
    this.deviceId,
    this.vendorId,
    this.subsystemId,
    this.subsystemVendorId,
  });
  static PciId fromJson(Map<String, dynamic> json) => PciId(
        deviceId:
            json.containsKey('DeviceId') ? json['DeviceId'] as String : null,
        vendorId:
            json.containsKey('VendorId') ? json['VendorId'] as String : null,
        subsystemId: json.containsKey('SubsystemId')
            ? json['SubsystemId'] as String
            : null,
        subsystemVendorId: json.containsKey('SubsystemVendorId')
            ? json['SubsystemVendorId'] as String
            : null,
      );
}

/// Describes the VPC peering connection options.
class PeeringConnectionOptions {
  /// If true, the public DNS hostnames of instances in the specified VPC
  /// resolve to private IP addresses when queried from instances in the peer
  /// VPC.
  final bool allowDnsResolutionFromRemoteVpc;

  /// If true, enables outbound communication from an EC2-Classic instance
  /// that's linked to a local VPC using ClassicLink to instances in a peer VPC.
  final bool allowEgressFromLocalClassicLinkToRemoteVpc;

  /// If true, enables outbound communication from instances in a local VPC to
  /// an EC2-Classic instance that's linked to a peer VPC using ClassicLink.
  final bool allowEgressFromLocalVpcToRemoteClassicLink;

  PeeringConnectionOptions({
    this.allowDnsResolutionFromRemoteVpc,
    this.allowEgressFromLocalClassicLinkToRemoteVpc,
    this.allowEgressFromLocalVpcToRemoteClassicLink,
  });
  static PeeringConnectionOptions fromJson(Map<String, dynamic> json) =>
      PeeringConnectionOptions(
        allowDnsResolutionFromRemoteVpc:
            json.containsKey('AllowDnsResolutionFromRemoteVpc')
                ? json['AllowDnsResolutionFromRemoteVpc'] as bool
                : null,
        allowEgressFromLocalClassicLinkToRemoteVpc:
            json.containsKey('AllowEgressFromLocalClassicLinkToRemoteVpc')
                ? json['AllowEgressFromLocalClassicLinkToRemoteVpc'] as bool
                : null,
        allowEgressFromLocalVpcToRemoteClassicLink:
            json.containsKey('AllowEgressFromLocalVpcToRemoteClassicLink')
                ? json['AllowEgressFromLocalVpcToRemoteClassicLink'] as bool
                : null,
      );
}

/// The VPC peering connection options.
class PeeringConnectionOptionsRequest {
  /// If true, enables a local VPC to resolve public DNS hostnames to private IP
  /// addresses when queried from instances in the peer VPC.
  final bool allowDnsResolutionFromRemoteVpc;

  /// If true, enables outbound communication from an EC2-Classic instance
  /// that's linked to a local VPC using ClassicLink to instances in a peer VPC.
  final bool allowEgressFromLocalClassicLinkToRemoteVpc;

  /// If true, enables outbound communication from instances in a local VPC to
  /// an EC2-Classic instance that's linked to a peer VPC using ClassicLink.
  final bool allowEgressFromLocalVpcToRemoteClassicLink;

  PeeringConnectionOptionsRequest({
    this.allowDnsResolutionFromRemoteVpc,
    this.allowEgressFromLocalClassicLinkToRemoteVpc,
    this.allowEgressFromLocalVpcToRemoteClassicLink,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// The Diffie-Hellmann group number for phase 1 IKE negotiations.
class Phase1dhGroupNumbersListValue {
  /// The Diffie-Hellmann group number.
  final int value;

  Phase1dhGroupNumbersListValue({
    this.value,
  });
  static Phase1dhGroupNumbersListValue fromJson(Map<String, dynamic> json) =>
      Phase1dhGroupNumbersListValue(
        value: json.containsKey('Value') ? json['Value'] as int : null,
      );
}

/// Specifies a Diffie-Hellman group number for the VPN tunnel for phase 1 IKE
/// negotiations.
class Phase1dhGroupNumbersRequestListValue {
  /// The Diffie-Hellmann group number.
  final int value;

  Phase1dhGroupNumbersRequestListValue({
    this.value,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// The encryption algorithm for phase 1 IKE negotiations.
class Phase1EncryptionAlgorithmsListValue {
  /// The value for the encryption algorithm.
  final String value;

  Phase1EncryptionAlgorithmsListValue({
    this.value,
  });
  static Phase1EncryptionAlgorithmsListValue fromJson(
          Map<String, dynamic> json) =>
      Phase1EncryptionAlgorithmsListValue(
        value: json.containsKey('Value') ? json['Value'] as String : null,
      );
}

/// Specifies the encryption algorithm for the VPN tunnel for phase 1 IKE
/// negotiations.
class Phase1EncryptionAlgorithmsRequestListValue {
  /// The value for the encryption algorithm.
  final String value;

  Phase1EncryptionAlgorithmsRequestListValue({
    this.value,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// The integrity algorithm for phase 1 IKE negotiations.
class Phase1IntegrityAlgorithmsListValue {
  /// The value for the integrity algorithm.
  final String value;

  Phase1IntegrityAlgorithmsListValue({
    this.value,
  });
  static Phase1IntegrityAlgorithmsListValue fromJson(
          Map<String, dynamic> json) =>
      Phase1IntegrityAlgorithmsListValue(
        value: json.containsKey('Value') ? json['Value'] as String : null,
      );
}

/// Specifies the integrity algorithm for the VPN tunnel for phase 1 IKE
/// negotiations.
class Phase1IntegrityAlgorithmsRequestListValue {
  /// The value for the integrity algorithm.
  final String value;

  Phase1IntegrityAlgorithmsRequestListValue({
    this.value,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// The Diffie-Hellmann group number for phase 2 IKE negotiations.
class Phase2dhGroupNumbersListValue {
  /// The Diffie-Hellmann group number.
  final int value;

  Phase2dhGroupNumbersListValue({
    this.value,
  });
  static Phase2dhGroupNumbersListValue fromJson(Map<String, dynamic> json) =>
      Phase2dhGroupNumbersListValue(
        value: json.containsKey('Value') ? json['Value'] as int : null,
      );
}

/// Specifies a Diffie-Hellman group number for the VPN tunnel for phase 2 IKE
/// negotiations.
class Phase2dhGroupNumbersRequestListValue {
  /// The Diffie-Hellmann group number.
  final int value;

  Phase2dhGroupNumbersRequestListValue({
    this.value,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// The encryption algorithm for phase 2 IKE negotiations.
class Phase2EncryptionAlgorithmsListValue {
  /// The encryption algorithm.
  final String value;

  Phase2EncryptionAlgorithmsListValue({
    this.value,
  });
  static Phase2EncryptionAlgorithmsListValue fromJson(
          Map<String, dynamic> json) =>
      Phase2EncryptionAlgorithmsListValue(
        value: json.containsKey('Value') ? json['Value'] as String : null,
      );
}

/// Specifies the encryption algorithm for the VPN tunnel for phase 2 IKE
/// negotiations.
class Phase2EncryptionAlgorithmsRequestListValue {
  /// The encryption algorithm.
  final String value;

  Phase2EncryptionAlgorithmsRequestListValue({
    this.value,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// The integrity algorithm for phase 2 IKE negotiations.
class Phase2IntegrityAlgorithmsListValue {
  /// The integrity algorithm.
  final String value;

  Phase2IntegrityAlgorithmsListValue({
    this.value,
  });
  static Phase2IntegrityAlgorithmsListValue fromJson(
          Map<String, dynamic> json) =>
      Phase2IntegrityAlgorithmsListValue(
        value: json.containsKey('Value') ? json['Value'] as String : null,
      );
}

/// Specifies the integrity algorithm for the VPN tunnel for phase 2 IKE
/// negotiations.
class Phase2IntegrityAlgorithmsRequestListValue {
  /// The integrity algorithm.
  final String value;

  Phase2IntegrityAlgorithmsRequestListValue({
    this.value,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the placement of an instance.
class Placement {
  /// The Availability Zone of the instance.
  ///
  /// If not specified, an Availability Zone will be automatically chosen for
  /// you based on the load balancing criteria for the Region.
  final String availabilityZone;

  /// The affinity setting for the instance on the Dedicated Host. This
  /// parameter is not supported for the ImportInstance command.
  final String affinity;

  /// The name of the placement group the instance is in.
  final String groupName;

  /// The number of the partition the instance is in. Valid only if the
  /// placement group strategy is set to `partition`.
  final int partitionNumber;

  /// The ID of the Dedicated Host on which the instance resides. This parameter
  /// is not supported for the ImportInstance command.
  final String hostId;

  /// The tenancy of the instance (if the instance is running in a VPC). An
  /// instance with a tenancy of `dedicated` runs on single-tenant hardware. The
  /// `host` tenancy is not supported for the ImportInstance command.
  final String tenancy;

  /// Reserved for future use.
  final String spreadDomain;

  Placement({
    this.availabilityZone,
    this.affinity,
    this.groupName,
    this.partitionNumber,
    this.hostId,
    this.tenancy,
    this.spreadDomain,
  });
  static Placement fromJson(Map<String, dynamic> json) => Placement(
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        affinity:
            json.containsKey('Affinity') ? json['Affinity'] as String : null,
        groupName:
            json.containsKey('GroupName') ? json['GroupName'] as String : null,
        partitionNumber: json.containsKey('PartitionNumber')
            ? json['PartitionNumber'] as int
            : null,
        hostId: json.containsKey('HostId') ? json['HostId'] as String : null,
        tenancy: json.containsKey('Tenancy') ? json['Tenancy'] as String : null,
        spreadDomain: json.containsKey('SpreadDomain')
            ? json['SpreadDomain'] as String
            : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a placement group.
class PlacementGroup {
  /// The name of the placement group.
  final String groupName;

  /// The state of the placement group.
  final String state;

  /// The placement strategy.
  final String strategy;

  /// The number of partitions. Valid only if **strategy** is set to
  /// `partition`.
  final int partitionCount;

  PlacementGroup({
    this.groupName,
    this.state,
    this.strategy,
    this.partitionCount,
  });
  static PlacementGroup fromJson(Map<String, dynamic> json) => PlacementGroup(
        groupName:
            json.containsKey('GroupName') ? json['GroupName'] as String : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        strategy:
            json.containsKey('Strategy') ? json['Strategy'] as String : null,
        partitionCount: json.containsKey('PartitionCount')
            ? json['PartitionCount'] as int
            : null,
      );
}

/// Describes the placement of an instance.
class PlacementResponse {
  /// The name of the placement group the instance is in.
  final String groupName;

  PlacementResponse({
    this.groupName,
  });
  static PlacementResponse fromJson(Map<String, dynamic> json) =>
      PlacementResponse(
        groupName:
            json.containsKey('GroupName') ? json['GroupName'] as String : null,
      );
}

/// Describes a range of ports.
class PortRange {
  /// The first port in the range.
  final int from;

  /// The last port in the range.
  final int to;

  PortRange({
    this.from,
    this.to,
  });
  static PortRange fromJson(Map<String, dynamic> json) => PortRange(
        from: json.containsKey('From') ? json['From'] as int : null,
        to: json.containsKey('To') ? json['To'] as int : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes prefixes for AWS services.
class PrefixList {
  /// The IP address range of the AWS service.
  final List<String> cidrs;

  /// The ID of the prefix.
  final String prefixListId;

  /// The name of the prefix.
  final String prefixListName;

  PrefixList({
    this.cidrs,
    this.prefixListId,
    this.prefixListName,
  });
  static PrefixList fromJson(Map<String, dynamic> json) => PrefixList(
        cidrs: json.containsKey('Cidrs')
            ? (json['Cidrs'] as List).map((e) => e as String).toList()
            : null,
        prefixListId: json.containsKey('PrefixListId')
            ? json['PrefixListId'] as String
            : null,
        prefixListName: json.containsKey('PrefixListName')
            ? json['PrefixListName'] as String
            : null,
      );
}

/// Describes a prefix list ID.
class PrefixListId {
  /// A description for the security group rule that references this prefix list
  /// ID.
  ///
  /// Constraints: Up to 255 characters in length. Allowed characters are a-z,
  /// A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
  final String description;

  /// The ID of the prefix.
  final String prefixListId;

  PrefixListId({
    this.description,
    this.prefixListId,
  });
  static PrefixListId fromJson(Map<String, dynamic> json) => PrefixListId(
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        prefixListId: json.containsKey('PrefixListId')
            ? json['PrefixListId'] as String
            : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the price for a Reserved Instance.
class PriceSchedule {
  /// The current price schedule, as determined by the term remaining for the
  /// Reserved Instance in the listing.
  ///
  /// A specific price schedule is always in effect, but only one price schedule
  /// can be active at any time. Take, for example, a Reserved Instance listing
  /// that has five months remaining in its term. When you specify price
  /// schedules for five months and two months, this means that schedule 1,
  /// covering the first three months of the remaining term, will be active
  /// during months 5, 4, and 3. Then schedule 2, covering the last two months
  /// of the term, will be active for months 2 and 1.
  final bool active;

  /// The currency for transacting the Reserved Instance resale. At this time,
  /// the only supported currency is `USD`.
  final String currencyCode;

  /// The fixed price for the term.
  final double price;

  /// The number of months remaining in the reservation. For example, 2 is the
  /// second to the last month before the capacity reservation expires.
  final BigInt term;

  PriceSchedule({
    this.active,
    this.currencyCode,
    this.price,
    this.term,
  });
  static PriceSchedule fromJson(Map<String, dynamic> json) => PriceSchedule(
        active: json.containsKey('Active') ? json['Active'] as bool : null,
        currencyCode: json.containsKey('CurrencyCode')
            ? json['CurrencyCode'] as String
            : null,
        price: json.containsKey('Price') ? json['Price'] as double : null,
        term: json.containsKey('Term') ? BigInt.from(json['Term']) : null,
      );
}

/// Describes the price for a Reserved Instance.
class PriceScheduleSpecification {
  /// The currency for transacting the Reserved Instance resale. At this time,
  /// the only supported currency is `USD`.
  final String currencyCode;

  /// The fixed price for the term.
  final double price;

  /// The number of months remaining in the reservation. For example, 2 is the
  /// second to the last month before the capacity reservation expires.
  final BigInt term;

  PriceScheduleSpecification({
    this.currencyCode,
    this.price,
    this.term,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a Reserved Instance offering.
class PricingDetail {
  /// The number of reservations available for the price.
  final int count;

  /// The price per instance.
  final double price;

  PricingDetail({
    this.count,
    this.price,
  });
  static PricingDetail fromJson(Map<String, dynamic> json) => PricingDetail(
        count: json.containsKey('Count') ? json['Count'] as int : null,
        price: json.containsKey('Price') ? json['Price'] as double : null,
      );
}

/// PrincipalIdFormat description
class PrincipalIdFormat {
  /// PrincipalIdFormatARN description
  final String arn;

  /// PrincipalIdFormatStatuses description
  final List<IdFormat> statuses;

  PrincipalIdFormat({
    this.arn,
    this.statuses,
  });
  static PrincipalIdFormat fromJson(Map<String, dynamic> json) =>
      PrincipalIdFormat(
        arn: json.containsKey('Arn') ? json['Arn'] as String : null,
        statuses: json.containsKey('Statuses')
            ? (json['Statuses'] as List)
                .map((e) => IdFormat.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes a secondary private IPv4 address for a network interface.
class PrivateIpAddressSpecification {
  /// Indicates whether the private IPv4 address is the primary private IPv4
  /// address. Only one IPv4 address can be designated as primary.
  final bool primary;

  /// The private IPv4 addresses.
  final String privateIpAddress;

  PrivateIpAddressSpecification({
    this.primary,
    this.privateIpAddress,
  });
  static PrivateIpAddressSpecification fromJson(Map<String, dynamic> json) =>
      PrivateIpAddressSpecification(
        primary: json.containsKey('Primary') ? json['Primary'] as bool : null,
        privateIpAddress: json.containsKey('PrivateIpAddress')
            ? json['PrivateIpAddress'] as String
            : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a product code.
class ProductCode {
  /// The product code.
  final String productCodeId;

  /// The type of product code.
  final String productCodeType;

  ProductCode({
    this.productCodeId,
    this.productCodeType,
  });
  static ProductCode fromJson(Map<String, dynamic> json) => ProductCode(
        productCodeId: json.containsKey('ProductCodeId')
            ? json['ProductCodeId'] as String
            : null,
        productCodeType: json.containsKey('ProductCodeType')
            ? json['ProductCodeType'] as String
            : null,
      );
}

/// Describes a virtual private gateway propagating route.
class PropagatingVgw {
  /// The ID of the virtual private gateway.
  final String gatewayId;

  PropagatingVgw({
    this.gatewayId,
  });
  static PropagatingVgw fromJson(Map<String, dynamic> json) => PropagatingVgw(
        gatewayId:
            json.containsKey('GatewayId') ? json['GatewayId'] as String : null,
      );
}

class ProvisionByoipCidrResult {
  /// Information about the address pool.
  final ByoipCidr byoipCidr;

  ProvisionByoipCidrResult({
    this.byoipCidr,
  });
  static ProvisionByoipCidrResult fromJson(Map<String, dynamic> json) =>
      ProvisionByoipCidrResult(
        byoipCidr: json.containsKey('ByoipCidr')
            ? ByoipCidr.fromJson(json['ByoipCidr'])
            : null,
      );
}

/// Reserved. If you need to sustain traffic greater than the
/// [documented limits](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html),
/// contact us through the
/// [Support Center](https://console.aws.amazon.com/support/home?).
class ProvisionedBandwidth {
  /// Reserved. If you need to sustain traffic greater than the
  /// [documented limits](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html),
  /// contact us through the
  /// [Support Center](https://console.aws.amazon.com/support/home?).
  final DateTime provisionTime;

  /// Reserved. If you need to sustain traffic greater than the
  /// [documented limits](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html),
  /// contact us through the
  /// [Support Center](https://console.aws.amazon.com/support/home?).
  final String provisioned;

  /// Reserved. If you need to sustain traffic greater than the
  /// [documented limits](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html),
  /// contact us through the
  /// [Support Center](https://console.aws.amazon.com/support/home?).
  final DateTime requestTime;

  /// Reserved. If you need to sustain traffic greater than the
  /// [documented limits](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html),
  /// contact us through the
  /// [Support Center](https://console.aws.amazon.com/support/home?).
  final String requested;

  /// Reserved. If you need to sustain traffic greater than the
  /// [documented limits](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html),
  /// contact us through the
  /// [Support Center](https://console.aws.amazon.com/support/home?).
  final String status;

  ProvisionedBandwidth({
    this.provisionTime,
    this.provisioned,
    this.requestTime,
    this.requested,
    this.status,
  });
  static ProvisionedBandwidth fromJson(Map<String, dynamic> json) =>
      ProvisionedBandwidth(
        provisionTime: json.containsKey('ProvisionTime')
            ? DateTime.parse(json['ProvisionTime'])
            : null,
        provisioned: json.containsKey('Provisioned')
            ? json['Provisioned'] as String
            : null,
        requestTime: json.containsKey('RequestTime')
            ? DateTime.parse(json['RequestTime'])
            : null,
        requested:
            json.containsKey('Requested') ? json['Requested'] as String : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
      );
}

/// Describes an address pool.
class PublicIpv4Pool {
  /// The ID of the IPv4 address pool.
  final String poolId;

  /// A description of the address pool.
  final String description;

  /// The address ranges.
  final List<PublicIpv4PoolRange> poolAddressRanges;

  /// The total number of addresses.
  final int totalAddressCount;

  /// The total number of available addresses.
  final int totalAvailableAddressCount;

  PublicIpv4Pool({
    this.poolId,
    this.description,
    this.poolAddressRanges,
    this.totalAddressCount,
    this.totalAvailableAddressCount,
  });
  static PublicIpv4Pool fromJson(Map<String, dynamic> json) => PublicIpv4Pool(
        poolId: json.containsKey('PoolId') ? json['PoolId'] as String : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        poolAddressRanges: json.containsKey('PoolAddressRanges')
            ? (json['PoolAddressRanges'] as List)
                .map((e) => PublicIpv4PoolRange.fromJson(e))
                .toList()
            : null,
        totalAddressCount: json.containsKey('TotalAddressCount')
            ? json['TotalAddressCount'] as int
            : null,
        totalAvailableAddressCount:
            json.containsKey('TotalAvailableAddressCount')
                ? json['TotalAvailableAddressCount'] as int
                : null,
      );
}

/// Describes an address range of an IPv4 address pool.
class PublicIpv4PoolRange {
  /// The first IP address in the range.
  final String firstAddress;

  /// The last IP address in the range.
  final String lastAddress;

  /// The number of addresses in the range.
  final int addressCount;

  /// The number of available addresses in the range.
  final int availableAddressCount;

  PublicIpv4PoolRange({
    this.firstAddress,
    this.lastAddress,
    this.addressCount,
    this.availableAddressCount,
  });
  static PublicIpv4PoolRange fromJson(Map<String, dynamic> json) =>
      PublicIpv4PoolRange(
        firstAddress: json.containsKey('FirstAddress')
            ? json['FirstAddress'] as String
            : null,
        lastAddress: json.containsKey('LastAddress')
            ? json['LastAddress'] as String
            : null,
        addressCount: json.containsKey('AddressCount')
            ? json['AddressCount'] as int
            : null,
        availableAddressCount: json.containsKey('AvailableAddressCount')
            ? json['AvailableAddressCount'] as int
            : null,
      );
}

/// Describes the result of the purchase.
class Purchase {
  /// The currency in which the `UpfrontPrice` and `HourlyPrice` amounts are
  /// specified. At this time, the only supported currency is `USD`.
  final String currencyCode;

  /// The duration of the reservation's term in seconds.
  final int duration;

  /// The IDs of the Dedicated Hosts associated with the reservation.
  final List<String> hostIdSet;

  /// The ID of the reservation.
  final String hostReservationId;

  /// The hourly price of the reservation per hour.
  final String hourlyPrice;

  /// The instance family on the Dedicated Host that the reservation can be
  /// associated with.
  final String instanceFamily;

  /// The payment option for the reservation.
  final String paymentOption;

  /// The upfront price of the reservation.
  final String upfrontPrice;

  Purchase({
    this.currencyCode,
    this.duration,
    this.hostIdSet,
    this.hostReservationId,
    this.hourlyPrice,
    this.instanceFamily,
    this.paymentOption,
    this.upfrontPrice,
  });
  static Purchase fromJson(Map<String, dynamic> json) => Purchase(
        currencyCode: json.containsKey('CurrencyCode')
            ? json['CurrencyCode'] as String
            : null,
        duration: json.containsKey('Duration') ? json['Duration'] as int : null,
        hostIdSet: json.containsKey('HostIdSet')
            ? (json['HostIdSet'] as List).map((e) => e as String).toList()
            : null,
        hostReservationId: json.containsKey('HostReservationId')
            ? json['HostReservationId'] as String
            : null,
        hourlyPrice: json.containsKey('HourlyPrice')
            ? json['HourlyPrice'] as String
            : null,
        instanceFamily: json.containsKey('InstanceFamily')
            ? json['InstanceFamily'] as String
            : null,
        paymentOption: json.containsKey('PaymentOption')
            ? json['PaymentOption'] as String
            : null,
        upfrontPrice: json.containsKey('UpfrontPrice')
            ? json['UpfrontPrice'] as String
            : null,
      );
}

class PurchaseHostReservationResult {
  /// Unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. For more information, see
  /// [How to Ensure Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  final String clientToken;

  /// The currency in which the `totalUpfrontPrice` and `totalHourlyPrice`
  /// amounts are specified. At this time, the only supported currency is `USD`.
  final String currencyCode;

  /// Describes the details of the purchase.
  final List<Purchase> purchase;

  /// The total hourly price of the reservation calculated per hour.
  final String totalHourlyPrice;

  /// The total amount charged to your account when you purchase the
  /// reservation.
  final String totalUpfrontPrice;

  PurchaseHostReservationResult({
    this.clientToken,
    this.currencyCode,
    this.purchase,
    this.totalHourlyPrice,
    this.totalUpfrontPrice,
  });
  static PurchaseHostReservationResult fromJson(Map<String, dynamic> json) =>
      PurchaseHostReservationResult(
        clientToken: json.containsKey('ClientToken')
            ? json['ClientToken'] as String
            : null,
        currencyCode: json.containsKey('CurrencyCode')
            ? json['CurrencyCode'] as String
            : null,
        purchase: json.containsKey('Purchase')
            ? (json['Purchase'] as List)
                .map((e) => Purchase.fromJson(e))
                .toList()
            : null,
        totalHourlyPrice: json.containsKey('TotalHourlyPrice')
            ? json['TotalHourlyPrice'] as String
            : null,
        totalUpfrontPrice: json.containsKey('TotalUpfrontPrice')
            ? json['TotalUpfrontPrice'] as String
            : null,
      );
}

/// Describes a request to purchase Scheduled Instances.
class PurchaseRequest {
  /// The number of instances.
  final int instanceCount;

  /// The purchase token.
  final String purchaseToken;

  PurchaseRequest({
    @required this.instanceCount,
    @required this.purchaseToken,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Contains the output of PurchaseReservedInstancesOffering.
class PurchaseReservedInstancesOfferingResult {
  /// The IDs of the purchased Reserved Instances.
  final String reservedInstancesId;

  PurchaseReservedInstancesOfferingResult({
    this.reservedInstancesId,
  });
  static PurchaseReservedInstancesOfferingResult fromJson(
          Map<String, dynamic> json) =>
      PurchaseReservedInstancesOfferingResult(
        reservedInstancesId: json.containsKey('ReservedInstancesId')
            ? json['ReservedInstancesId'] as String
            : null,
      );
}

/// Contains the output of PurchaseScheduledInstances.
class PurchaseScheduledInstancesResult {
  /// Information about the Scheduled Instances.
  final List<ScheduledInstance> scheduledInstanceSet;

  PurchaseScheduledInstancesResult({
    this.scheduledInstanceSet,
  });
  static PurchaseScheduledInstancesResult fromJson(Map<String, dynamic> json) =>
      PurchaseScheduledInstancesResult(
        scheduledInstanceSet: json.containsKey('ScheduledInstanceSet')
            ? (json['ScheduledInstanceSet'] as List)
                .map((e) => ScheduledInstance.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes a recurring charge.
class RecurringCharge {
  /// The amount of the recurring charge.
  final double amount;

  /// The frequency of the recurring charge.
  final String frequency;

  RecurringCharge({
    this.amount,
    this.frequency,
  });
  static RecurringCharge fromJson(Map<String, dynamic> json) => RecurringCharge(
        amount: json.containsKey('Amount') ? json['Amount'] as double : null,
        frequency:
            json.containsKey('Frequency') ? json['Frequency'] as String : null,
      );
}

/// Describes a Region.
class Region {
  /// The Region service endpoint.
  final String endpoint;

  /// The name of the Region.
  final String regionName;

  /// The Region opt-in status. The possible values are `opt-in-not-required`,
  /// `opted-in`, and `not-opted-in`.
  final String optInStatus;

  Region({
    this.endpoint,
    this.regionName,
    this.optInStatus,
  });
  static Region fromJson(Map<String, dynamic> json) => Region(
        endpoint:
            json.containsKey('Endpoint') ? json['Endpoint'] as String : null,
        regionName: json.containsKey('RegionName')
            ? json['RegionName'] as String
            : null,
        optInStatus: json.containsKey('OptInStatus')
            ? json['OptInStatus'] as String
            : null,
      );
}

/// Contains the output of RegisterImage.
class RegisterImageResult {
  /// The ID of the newly registered AMI.
  final String imageId;

  RegisterImageResult({
    this.imageId,
  });
  static RegisterImageResult fromJson(Map<String, dynamic> json) =>
      RegisterImageResult(
        imageId: json.containsKey('ImageId') ? json['ImageId'] as String : null,
      );
}

class RejectTransitGatewayVpcAttachmentResult {
  /// Information about the attachment.
  final TransitGatewayVpcAttachment transitGatewayVpcAttachment;

  RejectTransitGatewayVpcAttachmentResult({
    this.transitGatewayVpcAttachment,
  });
  static RejectTransitGatewayVpcAttachmentResult fromJson(
          Map<String, dynamic> json) =>
      RejectTransitGatewayVpcAttachmentResult(
        transitGatewayVpcAttachment:
            json.containsKey('TransitGatewayVpcAttachment')
                ? TransitGatewayVpcAttachment.fromJson(
                    json['TransitGatewayVpcAttachment'])
                : null,
      );
}

class RejectVpcEndpointConnectionsResult {
  /// Information about the endpoints that were not rejected, if applicable.
  final List<UnsuccessfulItem> unsuccessful;

  RejectVpcEndpointConnectionsResult({
    this.unsuccessful,
  });
  static RejectVpcEndpointConnectionsResult fromJson(
          Map<String, dynamic> json) =>
      RejectVpcEndpointConnectionsResult(
        unsuccessful: json.containsKey('Unsuccessful')
            ? (json['Unsuccessful'] as List)
                .map((e) => UnsuccessfulItem.fromJson(e))
                .toList()
            : null,
      );
}

class RejectVpcPeeringConnectionResult {
  /// Returns `true` if the request succeeds; otherwise, it returns an error.
  final bool return$;

  RejectVpcPeeringConnectionResult({
    this.return$,
  });
  static RejectVpcPeeringConnectionResult fromJson(Map<String, dynamic> json) =>
      RejectVpcPeeringConnectionResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class ReleaseHostsResult {
  /// The IDs of the Dedicated Hosts that were successfully released.
  final List<String> successful;

  /// The IDs of the Dedicated Hosts that could not be released, including an
  /// error message.
  final List<UnsuccessfulItem> unsuccessful;

  ReleaseHostsResult({
    this.successful,
    this.unsuccessful,
  });
  static ReleaseHostsResult fromJson(Map<String, dynamic> json) =>
      ReleaseHostsResult(
        successful: json.containsKey('Successful')
            ? (json['Successful'] as List).map((e) => e as String).toList()
            : null,
        unsuccessful: json.containsKey('Unsuccessful')
            ? (json['Unsuccessful'] as List)
                .map((e) => UnsuccessfulItem.fromJson(e))
                .toList()
            : null,
      );
}

class ReplaceIamInstanceProfileAssociationResult {
  /// Information about the IAM instance profile association.
  final IamInstanceProfileAssociation iamInstanceProfileAssociation;

  ReplaceIamInstanceProfileAssociationResult({
    this.iamInstanceProfileAssociation,
  });
  static ReplaceIamInstanceProfileAssociationResult fromJson(
          Map<String, dynamic> json) =>
      ReplaceIamInstanceProfileAssociationResult(
        iamInstanceProfileAssociation:
            json.containsKey('IamInstanceProfileAssociation')
                ? IamInstanceProfileAssociation.fromJson(
                    json['IamInstanceProfileAssociation'])
                : null,
      );
}

class ReplaceNetworkAclAssociationResult {
  /// The ID of the new association.
  final String newAssociationId;

  ReplaceNetworkAclAssociationResult({
    this.newAssociationId,
  });
  static ReplaceNetworkAclAssociationResult fromJson(
          Map<String, dynamic> json) =>
      ReplaceNetworkAclAssociationResult(
        newAssociationId: json.containsKey('NewAssociationId')
            ? json['NewAssociationId'] as String
            : null,
      );
}

class ReplaceRouteTableAssociationResult {
  /// The ID of the new association.
  final String newAssociationId;

  ReplaceRouteTableAssociationResult({
    this.newAssociationId,
  });
  static ReplaceRouteTableAssociationResult fromJson(
          Map<String, dynamic> json) =>
      ReplaceRouteTableAssociationResult(
        newAssociationId: json.containsKey('NewAssociationId')
            ? json['NewAssociationId'] as String
            : null,
      );
}

class ReplaceTransitGatewayRouteResult {
  /// Information about the modified route.
  final TransitGatewayRoute route;

  ReplaceTransitGatewayRouteResult({
    this.route,
  });
  static ReplaceTransitGatewayRouteResult fromJson(Map<String, dynamic> json) =>
      ReplaceTransitGatewayRouteResult(
        route: json.containsKey('Route')
            ? TransitGatewayRoute.fromJson(json['Route'])
            : null,
      );
}

/// The information to include in the launch template.
class RequestLaunchTemplateData {
  /// The ID of the kernel.
  ///
  ///
  ///
  /// We recommend that you use PV-GRUB instead of kernels and RAM disks. For
  /// more information, see
  /// [User Provided Kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  final String kernelId;

  /// Indicates whether the instance is optimized for Amazon EBS I/O. This
  /// optimization provides dedicated throughput to Amazon EBS and an optimized
  /// configuration stack to provide optimal Amazon EBS I/O performance. This
  /// optimization isn't available with all instance types. Additional usage
  /// charges apply when using an EBS-optimized instance.
  final bool ebsOptimized;

  /// The IAM instance profile.
  final LaunchTemplateIamInstanceProfileSpecificationRequest iamInstanceProfile;

  /// The block device mapping.
  ///
  ///
  ///
  /// Supplying both a snapshot ID and an encryption value as arguments for
  /// block-device mapping results in an error. This is because only blank
  /// volumes can be encrypted on start, and these are not created from a
  /// snapshot. If a snapshot is the basis for the volume, it contains data by
  /// definition and its encryption status cannot be changed using this action.
  final List<LaunchTemplateBlockDeviceMappingRequest> blockDeviceMappings;

  /// One or more network interfaces. If you specify a network interface, you
  /// must specify any security groups and subnets as part of the network
  /// interface.
  final List<LaunchTemplateInstanceNetworkInterfaceSpecificationRequest>
      networkInterfaces;

  /// The ID of the AMI.
  final String imageId;

  /// The instance type. For more information, see
  /// [Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  final String instanceType;

  /// The name of the key pair. You can create a key pair using
  /// [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html)
  /// or
  /// [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html).
  ///
  ///
  ///
  /// If you do not specify a key pair, you can't connect to the instance unless
  /// you choose an AMI that is configured to allow users another way to log in.
  final String keyName;

  /// The monitoring for the instance.
  final LaunchTemplatesMonitoringRequest monitoring;

  /// The placement for the instance.
  final LaunchTemplatePlacementRequest placement;

  /// The ID of the RAM disk.
  ///
  ///
  ///
  /// We recommend that you use PV-GRUB instead of kernels and RAM disks. For
  /// more information, see
  /// [User Provided Kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  final String ramDiskId;

  /// If you set this parameter to `true`, you can't terminate the instance
  /// using the Amazon EC2 console, CLI, or API; otherwise, you can. To change
  /// this attribute after launch, use
  /// [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html).
  /// Alternatively, if you set `InstanceInitiatedShutdownBehavior` to
  /// `terminate`, you can terminate the instance by running the shutdown
  /// command from the instance.
  final bool disableApiTermination;

  /// Indicates whether an instance stops or terminates when you initiate
  /// shutdown from the instance (using the operating system command for system
  /// shutdown).
  ///
  /// Default: `stop`
  final String instanceInitiatedShutdownBehavior;

  /// The Base64-encoded user data to make available to the instance. For more
  /// information, see
  /// [Running Commands on Your Linux Instance at Launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html)
  /// (Linux) and
  /// [Adding User Data](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-metadata.html#instancedata-add-user-data)
  /// (Windows).
  final String userData;

  /// The tags to apply to the resources during launch. You can only tag
  /// instances and volumes on launch. The specified tags are applied to all
  /// instances or volumes that are created during launch. To tag a resource
  /// after it has been created, see
  /// [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html).
  final List<LaunchTemplateTagSpecificationRequest> tagSpecifications;

  /// An elastic GPU to associate with the instance.
  final List<ElasticGpuSpecification> elasticGpuSpecifications;

  ///  The elastic inference accelerator for the instance.
  final List<LaunchTemplateElasticInferenceAccelerator>
      elasticInferenceAccelerators;

  /// One or more security group IDs. You can create a security group using
  /// [CreateSecurityGroup](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateSecurityGroup.html).
  /// You cannot specify both a security group ID and security name in the same
  /// request.
  final List<String> securityGroupIds;

  /// [EC2-Classic, default VPC] One or more security group names. For a
  /// nondefault VPC, you must use security group IDs instead. You cannot
  /// specify both a security group ID and security name in the same request.
  final List<String> securityGroups;

  /// The market (purchasing) option for the instances.
  final LaunchTemplateInstanceMarketOptionsRequest instanceMarketOptions;

  /// The credit option for CPU usage of the instance. Valid for T2 or T3
  /// instances only.
  final CreditSpecificationRequest creditSpecification;

  /// The CPU options for the instance. For more information, see
  /// [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  final LaunchTemplateCpuOptionsRequest cpuOptions;

  /// The Capacity Reservation targeting option. If you do not specify this
  /// parameter, the instance's Capacity Reservation preference defaults to
  /// `open`, which enables it to run in any open Capacity Reservation that has
  /// matching attributes (instance type, platform, Availability Zone).
  final LaunchTemplateCapacityReservationSpecificationRequest
      capacityReservationSpecification;

  /// The license configurations.
  final List<LaunchTemplateLicenseConfigurationRequest> licenseSpecifications;

  /// Indicates whether an instance is enabled for hibernation. This parameter
  /// is valid only if the instance meets the
  /// [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites).
  /// Hibernation is currently supported only for Amazon Linux. For more
  /// information, see
  /// [Hibernate Your Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  final LaunchTemplateHibernationOptionsRequest hibernationOptions;

  RequestLaunchTemplateData({
    this.kernelId,
    this.ebsOptimized,
    this.iamInstanceProfile,
    this.blockDeviceMappings,
    this.networkInterfaces,
    this.imageId,
    this.instanceType,
    this.keyName,
    this.monitoring,
    this.placement,
    this.ramDiskId,
    this.disableApiTermination,
    this.instanceInitiatedShutdownBehavior,
    this.userData,
    this.tagSpecifications,
    this.elasticGpuSpecifications,
    this.elasticInferenceAccelerators,
    this.securityGroupIds,
    this.securityGroups,
    this.instanceMarketOptions,
    this.creditSpecification,
    this.cpuOptions,
    this.capacityReservationSpecification,
    this.licenseSpecifications,
    this.hibernationOptions,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Contains the output of RequestSpotFleet.
class RequestSpotFleetResponse {
  /// The ID of the Spot Fleet request.
  final String spotFleetRequestId;

  RequestSpotFleetResponse({
    this.spotFleetRequestId,
  });
  static RequestSpotFleetResponse fromJson(Map<String, dynamic> json) =>
      RequestSpotFleetResponse(
        spotFleetRequestId: json.containsKey('SpotFleetRequestId')
            ? json['SpotFleetRequestId'] as String
            : null,
      );
}

/// Contains the output of RequestSpotInstances.
class RequestSpotInstancesResult {
  /// One or more Spot Instance requests.
  final List<SpotInstanceRequest> spotInstanceRequests;

  RequestSpotInstancesResult({
    this.spotInstanceRequests,
  });
  static RequestSpotInstancesResult fromJson(Map<String, dynamic> json) =>
      RequestSpotInstancesResult(
        spotInstanceRequests: json.containsKey('SpotInstanceRequests')
            ? (json['SpotInstanceRequests'] as List)
                .map((e) => SpotInstanceRequest.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes the launch specification for an instance.
class RequestSpotLaunchSpecification {
  /// One or more security group IDs.
  final List<String> securityGroupIds;

  /// One or more security groups. When requesting instances in a VPC, you must
  /// specify the IDs of the security groups. When requesting instances in
  /// EC2-Classic, you can specify the names or the IDs of the security groups.
  final List<String> securityGroups;

  /// Deprecated.
  final String addressingType;

  /// One or more block device mapping entries. You can't specify both a
  /// snapshot ID and an encryption value. This is because only blank volumes
  /// can be encrypted on creation. If a snapshot is the basis for a volume, it
  /// is not blank and its encryption status is used for the volume encryption
  /// status.
  final List<BlockDeviceMapping> blockDeviceMappings;

  /// Indicates whether the instance is optimized for EBS I/O. This optimization
  /// provides dedicated throughput to Amazon EBS and an optimized configuration
  /// stack to provide optimal EBS I/O performance. This optimization isn't
  /// available with all instance types. Additional usage charges apply when
  /// using an EBS Optimized instance.
  ///
  /// Default: `false`
  final bool ebsOptimized;

  /// The IAM instance profile.
  final IamInstanceProfileSpecification iamInstanceProfile;

  /// The ID of the AMI.
  final String imageId;

  /// The instance type.
  final String instanceType;

  /// The ID of the kernel.
  final String kernelId;

  /// The name of the key pair.
  final String keyName;

  /// Indicates whether basic or detailed monitoring is enabled for the
  /// instance.
  ///
  /// Default: Disabled
  final RunInstancesMonitoringEnabled monitoring;

  /// One or more network interfaces. If you specify a network interface, you
  /// must specify subnet IDs and security group IDs using the network
  /// interface.
  final List<InstanceNetworkInterfaceSpecification> networkInterfaces;

  /// The placement information for the instance.
  final SpotPlacement placement;

  /// The ID of the RAM disk.
  final String ramdiskId;

  /// The IDs of the subnets in which to launch the instance. To specify
  /// multiple subnets, separate them using commas; for example,
  /// "subnet-1234abcdeexample1, subnet-0987cdef6example2".
  final String subnetId;

  /// The Base64-encoded user data for the instance. User data is limited to 16
  /// KB.
  final String userData;

  RequestSpotLaunchSpecification({
    this.securityGroupIds,
    this.securityGroups,
    this.addressingType,
    this.blockDeviceMappings,
    this.ebsOptimized,
    this.iamInstanceProfile,
    this.imageId,
    this.instanceType,
    this.kernelId,
    this.keyName,
    this.monitoring,
    this.networkInterfaces,
    this.placement,
    this.ramdiskId,
    this.subnetId,
    this.userData,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a reservation.
class Reservation {
  /// [EC2-Classic only] The security groups.
  final List<GroupIdentifier> groups;

  /// The instances.
  final List<Instance> instances;

  /// The ID of the AWS account that owns the reservation.
  final String ownerId;

  /// The ID of the requester that launched the instances on your behalf (for
  /// example, AWS Management Console or Auto Scaling).
  final String requesterId;

  /// The ID of the reservation.
  final String reservationId;

  Reservation({
    this.groups,
    this.instances,
    this.ownerId,
    this.requesterId,
    this.reservationId,
  });
  static Reservation fromJson(Map<String, dynamic> json) => Reservation(
        groups: json.containsKey('Groups')
            ? (json['Groups'] as List)
                .map((e) => GroupIdentifier.fromJson(e))
                .toList()
            : null,
        instances: json.containsKey('Instances')
            ? (json['Instances'] as List)
                .map((e) => Instance.fromJson(e))
                .toList()
            : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        requesterId: json.containsKey('RequesterId')
            ? json['RequesterId'] as String
            : null,
        reservationId: json.containsKey('ReservationId')
            ? json['ReservationId'] as String
            : null,
      );
}

/// The cost associated with the Reserved Instance.
class ReservationValue {
  /// The hourly rate of the reservation.
  final String hourlyPrice;

  /// The balance of the total value (the sum of remainingUpfrontValue +
  /// hourlyPrice * number of hours remaining).
  final String remainingTotalValue;

  /// The remaining upfront cost of the reservation.
  final String remainingUpfrontValue;

  ReservationValue({
    this.hourlyPrice,
    this.remainingTotalValue,
    this.remainingUpfrontValue,
  });
  static ReservationValue fromJson(Map<String, dynamic> json) =>
      ReservationValue(
        hourlyPrice: json.containsKey('HourlyPrice')
            ? json['HourlyPrice'] as String
            : null,
        remainingTotalValue: json.containsKey('RemainingTotalValue')
            ? json['RemainingTotalValue'] as String
            : null,
        remainingUpfrontValue: json.containsKey('RemainingUpfrontValue')
            ? json['RemainingUpfrontValue'] as String
            : null,
      );
}

/// Describes the limit price of a Reserved Instance offering.
class ReservedInstanceLimitPrice {
  /// Used for Reserved Instance Marketplace offerings. Specifies the limit
  /// price on the total order (instanceCount * price).
  final double amount;

  /// The currency in which the `limitPrice` amount is specified. At this time,
  /// the only supported currency is `USD`.
  final String currencyCode;

  ReservedInstanceLimitPrice({
    this.amount,
    this.currencyCode,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// The total value of the Convertible Reserved Instance.
class ReservedInstanceReservationValue {
  /// The total value of the Convertible Reserved Instance that you are
  /// exchanging.
  final ReservationValue reservationValue;

  /// The ID of the Convertible Reserved Instance that you are exchanging.
  final String reservedInstanceId;

  ReservedInstanceReservationValue({
    this.reservationValue,
    this.reservedInstanceId,
  });
  static ReservedInstanceReservationValue fromJson(Map<String, dynamic> json) =>
      ReservedInstanceReservationValue(
        reservationValue: json.containsKey('ReservationValue')
            ? ReservationValue.fromJson(json['ReservationValue'])
            : null,
        reservedInstanceId: json.containsKey('ReservedInstanceId')
            ? json['ReservedInstanceId'] as String
            : null,
      );
}

/// Describes a Reserved Instance.
class ReservedInstances {
  /// The Availability Zone in which the Reserved Instance can be used.
  final String availabilityZone;

  /// The duration of the Reserved Instance, in seconds.
  final BigInt duration;

  /// The time when the Reserved Instance expires.
  final DateTime end;

  /// The purchase price of the Reserved Instance.
  final double fixedPrice;

  /// The number of reservations purchased.
  final int instanceCount;

  /// The instance type on which the Reserved Instance can be used.
  final String instanceType;

  /// The Reserved Instance product platform description.
  final String productDescription;

  /// The ID of the Reserved Instance.
  final String reservedInstancesId;

  /// The date and time the Reserved Instance started.
  final DateTime start;

  /// The state of the Reserved Instance purchase.
  final String state;

  /// The usage price of the Reserved Instance, per hour.
  final double usagePrice;

  /// The currency of the Reserved Instance. It's specified using ISO 4217
  /// standard currency codes. At this time, the only supported currency is
  /// `USD`.
  final String currencyCode;

  /// The tenancy of the instance.
  final String instanceTenancy;

  /// The offering class of the Reserved Instance.
  final String offeringClass;

  /// The Reserved Instance offering type.
  final String offeringType;

  /// The recurring charge tag assigned to the resource.
  final List<RecurringCharge> recurringCharges;

  /// The scope of the Reserved Instance.
  final String scope;

  /// Any tags assigned to the resource.
  final List<Tag> tags;

  ReservedInstances({
    this.availabilityZone,
    this.duration,
    this.end,
    this.fixedPrice,
    this.instanceCount,
    this.instanceType,
    this.productDescription,
    this.reservedInstancesId,
    this.start,
    this.state,
    this.usagePrice,
    this.currencyCode,
    this.instanceTenancy,
    this.offeringClass,
    this.offeringType,
    this.recurringCharges,
    this.scope,
    this.tags,
  });
  static ReservedInstances fromJson(Map<String, dynamic> json) =>
      ReservedInstances(
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        duration:
            json.containsKey('Duration') ? BigInt.from(json['Duration']) : null,
        end: json.containsKey('End') ? DateTime.parse(json['End']) : null,
        fixedPrice: json.containsKey('FixedPrice')
            ? json['FixedPrice'] as double
            : null,
        instanceCount: json.containsKey('InstanceCount')
            ? json['InstanceCount'] as int
            : null,
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        productDescription: json.containsKey('ProductDescription')
            ? json['ProductDescription'] as String
            : null,
        reservedInstancesId: json.containsKey('ReservedInstancesId')
            ? json['ReservedInstancesId'] as String
            : null,
        start: json.containsKey('Start') ? DateTime.parse(json['Start']) : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        usagePrice: json.containsKey('UsagePrice')
            ? json['UsagePrice'] as double
            : null,
        currencyCode: json.containsKey('CurrencyCode')
            ? json['CurrencyCode'] as String
            : null,
        instanceTenancy: json.containsKey('InstanceTenancy')
            ? json['InstanceTenancy'] as String
            : null,
        offeringClass: json.containsKey('OfferingClass')
            ? json['OfferingClass'] as String
            : null,
        offeringType: json.containsKey('OfferingType')
            ? json['OfferingType'] as String
            : null,
        recurringCharges: json.containsKey('RecurringCharges')
            ? (json['RecurringCharges'] as List)
                .map((e) => RecurringCharge.fromJson(e))
                .toList()
            : null,
        scope: json.containsKey('Scope') ? json['Scope'] as String : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes the configuration settings for the modified Reserved Instances.
class ReservedInstancesConfiguration {
  /// The Availability Zone for the modified Reserved Instances.
  final String availabilityZone;

  /// The number of modified Reserved Instances.
  ///
  ///
  ///
  /// This is a required field for a request.
  final int instanceCount;

  /// The instance type for the modified Reserved Instances.
  final String instanceType;

  /// The network platform of the modified Reserved Instances, which is either
  /// EC2-Classic or EC2-VPC.
  final String platform;

  /// Whether the Reserved Instance is applied to instances in a Region or
  /// instances in a specific Availability Zone.
  final String scope;

  ReservedInstancesConfiguration({
    this.availabilityZone,
    this.instanceCount,
    this.instanceType,
    this.platform,
    this.scope,
  });
  static ReservedInstancesConfiguration fromJson(Map<String, dynamic> json) =>
      ReservedInstancesConfiguration(
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        instanceCount: json.containsKey('InstanceCount')
            ? json['InstanceCount'] as int
            : null,
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        platform:
            json.containsKey('Platform') ? json['Platform'] as String : null,
        scope: json.containsKey('Scope') ? json['Scope'] as String : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the ID of a Reserved Instance.
class ReservedInstancesId {
  /// The ID of the Reserved Instance.
  final String reservedInstancesId;

  ReservedInstancesId({
    this.reservedInstancesId,
  });
  static ReservedInstancesId fromJson(Map<String, dynamic> json) =>
      ReservedInstancesId(
        reservedInstancesId: json.containsKey('ReservedInstancesId')
            ? json['ReservedInstancesId'] as String
            : null,
      );
}

/// Describes a Reserved Instance listing.
class ReservedInstancesListing {
  /// A unique, case-sensitive key supplied by the client to ensure that the
  /// request is idempotent. For more information, see
  /// [Ensuring Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  final String clientToken;

  /// The time the listing was created.
  final DateTime createDate;

  /// The number of instances in this state.
  final List<InstanceCount> instanceCounts;

  /// The price of the Reserved Instance listing.
  final List<PriceSchedule> priceSchedules;

  /// The ID of the Reserved Instance.
  final String reservedInstancesId;

  /// The ID of the Reserved Instance listing.
  final String reservedInstancesListingId;

  /// The status of the Reserved Instance listing.
  final String status;

  /// The reason for the current status of the Reserved Instance listing. The
  /// response can be blank.
  final String statusMessage;

  /// Any tags assigned to the resource.
  final List<Tag> tags;

  /// The last modified timestamp of the listing.
  final DateTime updateDate;

  ReservedInstancesListing({
    this.clientToken,
    this.createDate,
    this.instanceCounts,
    this.priceSchedules,
    this.reservedInstancesId,
    this.reservedInstancesListingId,
    this.status,
    this.statusMessage,
    this.tags,
    this.updateDate,
  });
  static ReservedInstancesListing fromJson(Map<String, dynamic> json) =>
      ReservedInstancesListing(
        clientToken: json.containsKey('ClientToken')
            ? json['ClientToken'] as String
            : null,
        createDate: json.containsKey('CreateDate')
            ? DateTime.parse(json['CreateDate'])
            : null,
        instanceCounts: json.containsKey('InstanceCounts')
            ? (json['InstanceCounts'] as List)
                .map((e) => InstanceCount.fromJson(e))
                .toList()
            : null,
        priceSchedules: json.containsKey('PriceSchedules')
            ? (json['PriceSchedules'] as List)
                .map((e) => PriceSchedule.fromJson(e))
                .toList()
            : null,
        reservedInstancesId: json.containsKey('ReservedInstancesId')
            ? json['ReservedInstancesId'] as String
            : null,
        reservedInstancesListingId:
            json.containsKey('ReservedInstancesListingId')
                ? json['ReservedInstancesListingId'] as String
                : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
        statusMessage: json.containsKey('StatusMessage')
            ? json['StatusMessage'] as String
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        updateDate: json.containsKey('UpdateDate')
            ? DateTime.parse(json['UpdateDate'])
            : null,
      );
}

/// Describes a Reserved Instance modification.
class ReservedInstancesModification {
  /// A unique, case-sensitive key supplied by the client to ensure that the
  /// request is idempotent. For more information, see
  /// [Ensuring Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  final String clientToken;

  /// The time when the modification request was created.
  final DateTime createDate;

  /// The time for the modification to become effective.
  final DateTime effectiveDate;

  /// Contains target configurations along with their corresponding new Reserved
  /// Instance IDs.
  final List<ReservedInstancesModificationResult> modificationResults;

  /// The IDs of one or more Reserved Instances.
  final List<ReservedInstancesId> reservedInstancesIds;

  /// A unique ID for the Reserved Instance modification.
  final String reservedInstancesModificationId;

  /// The status of the Reserved Instances modification request.
  final String status;

  /// The reason for the status.
  final String statusMessage;

  /// The time when the modification request was last updated.
  final DateTime updateDate;

  ReservedInstancesModification({
    this.clientToken,
    this.createDate,
    this.effectiveDate,
    this.modificationResults,
    this.reservedInstancesIds,
    this.reservedInstancesModificationId,
    this.status,
    this.statusMessage,
    this.updateDate,
  });
  static ReservedInstancesModification fromJson(Map<String, dynamic> json) =>
      ReservedInstancesModification(
        clientToken: json.containsKey('ClientToken')
            ? json['ClientToken'] as String
            : null,
        createDate: json.containsKey('CreateDate')
            ? DateTime.parse(json['CreateDate'])
            : null,
        effectiveDate: json.containsKey('EffectiveDate')
            ? DateTime.parse(json['EffectiveDate'])
            : null,
        modificationResults: json.containsKey('ModificationResults')
            ? (json['ModificationResults'] as List)
                .map((e) => ReservedInstancesModificationResult.fromJson(e))
                .toList()
            : null,
        reservedInstancesIds: json.containsKey('ReservedInstancesIds')
            ? (json['ReservedInstancesIds'] as List)
                .map((e) => ReservedInstancesId.fromJson(e))
                .toList()
            : null,
        reservedInstancesModificationId:
            json.containsKey('ReservedInstancesModificationId')
                ? json['ReservedInstancesModificationId'] as String
                : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
        statusMessage: json.containsKey('StatusMessage')
            ? json['StatusMessage'] as String
            : null,
        updateDate: json.containsKey('UpdateDate')
            ? DateTime.parse(json['UpdateDate'])
            : null,
      );
}

/// Describes the modification request/s.
class ReservedInstancesModificationResult {
  /// The ID for the Reserved Instances that were created as part of the
  /// modification request. This field is only available when the modification
  /// is fulfilled.
  final String reservedInstancesId;

  /// The target Reserved Instances configurations supplied as part of the
  /// modification request.
  final ReservedInstancesConfiguration targetConfiguration;

  ReservedInstancesModificationResult({
    this.reservedInstancesId,
    this.targetConfiguration,
  });
  static ReservedInstancesModificationResult fromJson(
          Map<String, dynamic> json) =>
      ReservedInstancesModificationResult(
        reservedInstancesId: json.containsKey('ReservedInstancesId')
            ? json['ReservedInstancesId'] as String
            : null,
        targetConfiguration: json.containsKey('TargetConfiguration')
            ? ReservedInstancesConfiguration.fromJson(
                json['TargetConfiguration'])
            : null,
      );
}

/// Describes a Reserved Instance offering.
class ReservedInstancesOffering {
  /// The Availability Zone in which the Reserved Instance can be used.
  final String availabilityZone;

  /// The duration of the Reserved Instance, in seconds.
  final BigInt duration;

  /// The purchase price of the Reserved Instance.
  final double fixedPrice;

  /// The instance type on which the Reserved Instance can be used.
  final String instanceType;

  /// The Reserved Instance product platform description.
  final String productDescription;

  /// The ID of the Reserved Instance offering. This is the offering ID used in
  /// GetReservedInstancesExchangeQuote to confirm that an exchange can be made.
  final String reservedInstancesOfferingId;

  /// The usage price of the Reserved Instance, per hour.
  final double usagePrice;

  /// The currency of the Reserved Instance offering you are purchasing. It's
  /// specified using ISO 4217 standard currency codes. At this time, the only
  /// supported currency is `USD`.
  final String currencyCode;

  /// The tenancy of the instance.
  final String instanceTenancy;

  /// Indicates whether the offering is available through the Reserved Instance
  /// Marketplace (resale) or AWS. If it's a Reserved Instance Marketplace
  /// offering, this is `true`.
  final bool marketplace;

  /// If `convertible` it can be exchanged for Reserved Instances of the same or
  /// higher monetary value, with different configurations. If `standard`, it is
  /// not possible to perform an exchange.
  final String offeringClass;

  /// The Reserved Instance offering type.
  final String offeringType;

  /// The pricing details of the Reserved Instance offering.
  final List<PricingDetail> pricingDetails;

  /// The recurring charge tag assigned to the resource.
  final List<RecurringCharge> recurringCharges;

  /// Whether the Reserved Instance is applied to instances in a Region or an
  /// Availability Zone.
  final String scope;

  ReservedInstancesOffering({
    this.availabilityZone,
    this.duration,
    this.fixedPrice,
    this.instanceType,
    this.productDescription,
    this.reservedInstancesOfferingId,
    this.usagePrice,
    this.currencyCode,
    this.instanceTenancy,
    this.marketplace,
    this.offeringClass,
    this.offeringType,
    this.pricingDetails,
    this.recurringCharges,
    this.scope,
  });
  static ReservedInstancesOffering fromJson(Map<String, dynamic> json) =>
      ReservedInstancesOffering(
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        duration:
            json.containsKey('Duration') ? BigInt.from(json['Duration']) : null,
        fixedPrice: json.containsKey('FixedPrice')
            ? json['FixedPrice'] as double
            : null,
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        productDescription: json.containsKey('ProductDescription')
            ? json['ProductDescription'] as String
            : null,
        reservedInstancesOfferingId:
            json.containsKey('ReservedInstancesOfferingId')
                ? json['ReservedInstancesOfferingId'] as String
                : null,
        usagePrice: json.containsKey('UsagePrice')
            ? json['UsagePrice'] as double
            : null,
        currencyCode: json.containsKey('CurrencyCode')
            ? json['CurrencyCode'] as String
            : null,
        instanceTenancy: json.containsKey('InstanceTenancy')
            ? json['InstanceTenancy'] as String
            : null,
        marketplace: json.containsKey('Marketplace')
            ? json['Marketplace'] as bool
            : null,
        offeringClass: json.containsKey('OfferingClass')
            ? json['OfferingClass'] as String
            : null,
        offeringType: json.containsKey('OfferingType')
            ? json['OfferingType'] as String
            : null,
        pricingDetails: json.containsKey('PricingDetails')
            ? (json['PricingDetails'] as List)
                .map((e) => PricingDetail.fromJson(e))
                .toList()
            : null,
        recurringCharges: json.containsKey('RecurringCharges')
            ? (json['RecurringCharges'] as List)
                .map((e) => RecurringCharge.fromJson(e))
                .toList()
            : null,
        scope: json.containsKey('Scope') ? json['Scope'] as String : null,
      );
}

class ResetEbsDefaultKmsKeyIdResult {
  /// The Amazon Resource Name (ARN) of the default CMK for EBS encryption by
  /// default.
  final String kmsKeyId;

  ResetEbsDefaultKmsKeyIdResult({
    this.kmsKeyId,
  });
  static ResetEbsDefaultKmsKeyIdResult fromJson(Map<String, dynamic> json) =>
      ResetEbsDefaultKmsKeyIdResult(
        kmsKeyId:
            json.containsKey('KmsKeyId') ? json['KmsKeyId'] as String : null,
      );
}

class ResetFpgaImageAttributeResult {
  /// Is `true` if the request succeeds, and an error otherwise.
  final bool return$;

  ResetFpgaImageAttributeResult({
    this.return$,
  });
  static ResetFpgaImageAttributeResult fromJson(Map<String, dynamic> json) =>
      ResetFpgaImageAttributeResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

/// Describes the error that's returned when you cannot delete a launch template
/// version.
class ResponseError {
  /// The error code.
  final String code;

  /// The error message, if applicable.
  final String message;

  ResponseError({
    this.code,
    this.message,
  });
  static ResponseError fromJson(Map<String, dynamic> json) => ResponseError(
        code: json.containsKey('Code') ? json['Code'] as String : null,
        message: json.containsKey('Message') ? json['Message'] as String : null,
      );
}

/// The information for a launch template.
class ResponseLaunchTemplateData {
  /// The ID of the kernel, if applicable.
  final String kernelId;

  /// Indicates whether the instance is optimized for Amazon EBS I/O.
  final bool ebsOptimized;

  /// The IAM instance profile.
  final LaunchTemplateIamInstanceProfileSpecification iamInstanceProfile;

  /// The block device mappings.
  final List<LaunchTemplateBlockDeviceMapping> blockDeviceMappings;

  /// The network interfaces.
  final List<LaunchTemplateInstanceNetworkInterfaceSpecification>
      networkInterfaces;

  /// The ID of the AMI that was used to launch the instance.
  final String imageId;

  /// The instance type.
  final String instanceType;

  /// The name of the key pair.
  final String keyName;

  /// The monitoring for the instance.
  final LaunchTemplatesMonitoring monitoring;

  /// The placement of the instance.
  final LaunchTemplatePlacement placement;

  /// The ID of the RAM disk, if applicable.
  final String ramDiskId;

  /// If set to `true`, indicates that the instance cannot be terminated using
  /// the Amazon EC2 console, command line tool, or API.
  final bool disableApiTermination;

  /// Indicates whether an instance stops or terminates when you initiate
  /// shutdown from the instance (using the operating system command for system
  /// shutdown).
  final String instanceInitiatedShutdownBehavior;

  /// The user data for the instance.
  final String userData;

  /// The tags.
  final List<LaunchTemplateTagSpecification> tagSpecifications;

  /// The elastic GPU specification.
  final List<ElasticGpuSpecificationResponse> elasticGpuSpecifications;

  ///  The elastic inference accelerator for the instance.
  final List<LaunchTemplateElasticInferenceAcceleratorResponse>
      elasticInferenceAccelerators;

  /// The security group IDs.
  final List<String> securityGroupIds;

  /// The security group names.
  final List<String> securityGroups;

  /// The market (purchasing) option for the instances.
  final LaunchTemplateInstanceMarketOptions instanceMarketOptions;

  /// The credit option for CPU usage of the instance.
  final CreditSpecification creditSpecification;

  /// The CPU options for the instance. For more information, see
  /// [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  final LaunchTemplateCpuOptions cpuOptions;

  /// Information about the Capacity Reservation targeting option.
  final LaunchTemplateCapacityReservationSpecificationResponse
      capacityReservationSpecification;

  /// The license configurations.
  final List<LaunchTemplateLicenseConfiguration> licenseSpecifications;

  /// Indicates whether an instance is configured for hibernation. For more
  /// information, see
  /// [Hibernate Your Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  final LaunchTemplateHibernationOptions hibernationOptions;

  ResponseLaunchTemplateData({
    this.kernelId,
    this.ebsOptimized,
    this.iamInstanceProfile,
    this.blockDeviceMappings,
    this.networkInterfaces,
    this.imageId,
    this.instanceType,
    this.keyName,
    this.monitoring,
    this.placement,
    this.ramDiskId,
    this.disableApiTermination,
    this.instanceInitiatedShutdownBehavior,
    this.userData,
    this.tagSpecifications,
    this.elasticGpuSpecifications,
    this.elasticInferenceAccelerators,
    this.securityGroupIds,
    this.securityGroups,
    this.instanceMarketOptions,
    this.creditSpecification,
    this.cpuOptions,
    this.capacityReservationSpecification,
    this.licenseSpecifications,
    this.hibernationOptions,
  });
  static ResponseLaunchTemplateData fromJson(Map<String, dynamic> json) =>
      ResponseLaunchTemplateData(
        kernelId:
            json.containsKey('KernelId') ? json['KernelId'] as String : null,
        ebsOptimized: json.containsKey('EbsOptimized')
            ? json['EbsOptimized'] as bool
            : null,
        iamInstanceProfile: json.containsKey('IamInstanceProfile')
            ? LaunchTemplateIamInstanceProfileSpecification.fromJson(
                json['IamInstanceProfile'])
            : null,
        blockDeviceMappings: json.containsKey('BlockDeviceMappings')
            ? (json['BlockDeviceMappings'] as List)
                .map((e) => LaunchTemplateBlockDeviceMapping.fromJson(e))
                .toList()
            : null,
        networkInterfaces: json.containsKey('NetworkInterfaces')
            ? (json['NetworkInterfaces'] as List)
                .map((e) => LaunchTemplateInstanceNetworkInterfaceSpecification
                    .fromJson(e))
                .toList()
            : null,
        imageId: json.containsKey('ImageId') ? json['ImageId'] as String : null,
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        keyName: json.containsKey('KeyName') ? json['KeyName'] as String : null,
        monitoring: json.containsKey('Monitoring')
            ? LaunchTemplatesMonitoring.fromJson(json['Monitoring'])
            : null,
        placement: json.containsKey('Placement')
            ? LaunchTemplatePlacement.fromJson(json['Placement'])
            : null,
        ramDiskId:
            json.containsKey('RamDiskId') ? json['RamDiskId'] as String : null,
        disableApiTermination: json.containsKey('DisableApiTermination')
            ? json['DisableApiTermination'] as bool
            : null,
        instanceInitiatedShutdownBehavior:
            json.containsKey('InstanceInitiatedShutdownBehavior')
                ? json['InstanceInitiatedShutdownBehavior'] as String
                : null,
        userData:
            json.containsKey('UserData') ? json['UserData'] as String : null,
        tagSpecifications: json.containsKey('TagSpecifications')
            ? (json['TagSpecifications'] as List)
                .map((e) => LaunchTemplateTagSpecification.fromJson(e))
                .toList()
            : null,
        elasticGpuSpecifications: json.containsKey('ElasticGpuSpecifications')
            ? (json['ElasticGpuSpecifications'] as List)
                .map((e) => ElasticGpuSpecificationResponse.fromJson(e))
                .toList()
            : null,
        elasticInferenceAccelerators: json
                .containsKey('ElasticInferenceAccelerators')
            ? (json['ElasticInferenceAccelerators'] as List)
                .map((e) =>
                    LaunchTemplateElasticInferenceAcceleratorResponse.fromJson(
                        e))
                .toList()
            : null,
        securityGroupIds: json.containsKey('SecurityGroupIds')
            ? (json['SecurityGroupIds'] as List)
                .map((e) => e as String)
                .toList()
            : null,
        securityGroups: json.containsKey('SecurityGroups')
            ? (json['SecurityGroups'] as List).map((e) => e as String).toList()
            : null,
        instanceMarketOptions: json.containsKey('InstanceMarketOptions')
            ? LaunchTemplateInstanceMarketOptions.fromJson(
                json['InstanceMarketOptions'])
            : null,
        creditSpecification: json.containsKey('CreditSpecification')
            ? CreditSpecification.fromJson(json['CreditSpecification'])
            : null,
        cpuOptions: json.containsKey('CpuOptions')
            ? LaunchTemplateCpuOptions.fromJson(json['CpuOptions'])
            : null,
        capacityReservationSpecification: json
                .containsKey('CapacityReservationSpecification')
            ? LaunchTemplateCapacityReservationSpecificationResponse.fromJson(
                json['CapacityReservationSpecification'])
            : null,
        licenseSpecifications: json.containsKey('LicenseSpecifications')
            ? (json['LicenseSpecifications'] as List)
                .map((e) => LaunchTemplateLicenseConfiguration.fromJson(e))
                .toList()
            : null,
        hibernationOptions: json.containsKey('HibernationOptions')
            ? LaunchTemplateHibernationOptions.fromJson(
                json['HibernationOptions'])
            : null,
      );
}

class RestoreAddressToClassicResult {
  /// The Elastic IP address.
  final String publicIp;

  /// The move status for the IP address.
  final String status;

  RestoreAddressToClassicResult({
    this.publicIp,
    this.status,
  });
  static RestoreAddressToClassicResult fromJson(Map<String, dynamic> json) =>
      RestoreAddressToClassicResult(
        publicIp:
            json.containsKey('PublicIp') ? json['PublicIp'] as String : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
      );
}

class RevokeClientVpnIngressResult {
  /// The current state of the authorization rule.
  final ClientVpnAuthorizationRuleStatus status;

  RevokeClientVpnIngressResult({
    this.status,
  });
  static RevokeClientVpnIngressResult fromJson(Map<String, dynamic> json) =>
      RevokeClientVpnIngressResult(
        status: json.containsKey('Status')
            ? ClientVpnAuthorizationRuleStatus.fromJson(json['Status'])
            : null,
      );
}

/// Describes a route in a route table.
class Route {
  /// The IPv4 CIDR block used for the destination match.
  final String destinationCidrBlock;

  /// The IPv6 CIDR block used for the destination match.
  final String destinationIpv6CidrBlock;

  /// The prefix of the AWS service.
  final String destinationPrefixListId;

  /// The ID of the egress-only internet gateway.
  final String egressOnlyInternetGatewayId;

  /// The ID of a gateway attached to your VPC.
  final String gatewayId;

  /// The ID of a NAT instance in your VPC.
  final String instanceId;

  /// The AWS account ID of the owner of the instance.
  final String instanceOwnerId;

  /// The ID of a NAT gateway.
  final String natGatewayId;

  /// The ID of a transit gateway.
  final String transitGatewayId;

  /// The ID of the network interface.
  final String networkInterfaceId;

  /// Describes how the route was created.
  ///
  /// *    `CreateRouteTable` - The route was automatically created when the
  /// route table was created.
  ///
  /// *    `CreateRoute` - The route was manually added to the route table.
  ///
  /// *    `EnableVgwRoutePropagation` - The route was propagated by route
  /// propagation.
  final String origin;

  /// The state of the route. The `blackhole` state indicates that the route's
  /// target isn't available (for example, the specified gateway isn't attached
  /// to the VPC, or the specified NAT instance has been terminated).
  final String state;

  /// The ID of a VPC peering connection.
  final String vpcPeeringConnectionId;

  Route({
    this.destinationCidrBlock,
    this.destinationIpv6CidrBlock,
    this.destinationPrefixListId,
    this.egressOnlyInternetGatewayId,
    this.gatewayId,
    this.instanceId,
    this.instanceOwnerId,
    this.natGatewayId,
    this.transitGatewayId,
    this.networkInterfaceId,
    this.origin,
    this.state,
    this.vpcPeeringConnectionId,
  });
  static Route fromJson(Map<String, dynamic> json) => Route(
        destinationCidrBlock: json.containsKey('DestinationCidrBlock')
            ? json['DestinationCidrBlock'] as String
            : null,
        destinationIpv6CidrBlock: json.containsKey('DestinationIpv6CidrBlock')
            ? json['DestinationIpv6CidrBlock'] as String
            : null,
        destinationPrefixListId: json.containsKey('DestinationPrefixListId')
            ? json['DestinationPrefixListId'] as String
            : null,
        egressOnlyInternetGatewayId:
            json.containsKey('EgressOnlyInternetGatewayId')
                ? json['EgressOnlyInternetGatewayId'] as String
                : null,
        gatewayId:
            json.containsKey('GatewayId') ? json['GatewayId'] as String : null,
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        instanceOwnerId: json.containsKey('InstanceOwnerId')
            ? json['InstanceOwnerId'] as String
            : null,
        natGatewayId: json.containsKey('NatGatewayId')
            ? json['NatGatewayId'] as String
            : null,
        transitGatewayId: json.containsKey('TransitGatewayId')
            ? json['TransitGatewayId'] as String
            : null,
        networkInterfaceId: json.containsKey('NetworkInterfaceId')
            ? json['NetworkInterfaceId'] as String
            : null,
        origin: json.containsKey('Origin') ? json['Origin'] as String : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        vpcPeeringConnectionId: json.containsKey('VpcPeeringConnectionId')
            ? json['VpcPeeringConnectionId'] as String
            : null,
      );
}

/// Describes a route table.
class RouteTable {
  /// The associations between the route table and one or more subnets.
  final List<RouteTableAssociation> associations;

  /// Any virtual private gateway (VGW) propagating routes.
  final List<PropagatingVgw> propagatingVgws;

  /// The ID of the route table.
  final String routeTableId;

  /// The routes in the route table.
  final List<Route> routes;

  /// Any tags assigned to the route table.
  final List<Tag> tags;

  /// The ID of the VPC.
  final String vpcId;

  /// The ID of the AWS account that owns the route table.
  final String ownerId;

  RouteTable({
    this.associations,
    this.propagatingVgws,
    this.routeTableId,
    this.routes,
    this.tags,
    this.vpcId,
    this.ownerId,
  });
  static RouteTable fromJson(Map<String, dynamic> json) => RouteTable(
        associations: json.containsKey('Associations')
            ? (json['Associations'] as List)
                .map((e) => RouteTableAssociation.fromJson(e))
                .toList()
            : null,
        propagatingVgws: json.containsKey('PropagatingVgws')
            ? (json['PropagatingVgws'] as List)
                .map((e) => PropagatingVgw.fromJson(e))
                .toList()
            : null,
        routeTableId: json.containsKey('RouteTableId')
            ? json['RouteTableId'] as String
            : null,
        routes: json.containsKey('Routes')
            ? (json['Routes'] as List).map((e) => Route.fromJson(e)).toList()
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
      );
}

/// Describes an association between a route table and a subnet.
class RouteTableAssociation {
  /// Indicates whether this is the main route table.
  final bool main;

  /// The ID of the association between a route table and a subnet.
  final String routeTableAssociationId;

  /// The ID of the route table.
  final String routeTableId;

  /// The ID of the subnet. A subnet ID is not returned for an implicit
  /// association.
  final String subnetId;

  RouteTableAssociation({
    this.main,
    this.routeTableAssociationId,
    this.routeTableId,
    this.subnetId,
  });
  static RouteTableAssociation fromJson(Map<String, dynamic> json) =>
      RouteTableAssociation(
        main: json.containsKey('Main') ? json['Main'] as bool : null,
        routeTableAssociationId: json.containsKey('RouteTableAssociationId')
            ? json['RouteTableAssociationId'] as String
            : null,
        routeTableId: json.containsKey('RouteTableId')
            ? json['RouteTableId'] as String
            : null,
        subnetId:
            json.containsKey('SubnetId') ? json['SubnetId'] as String : null,
      );
}

/// Describes the monitoring of an instance.
class RunInstancesMonitoringEnabled {
  /// Indicates whether detailed monitoring is enabled. Otherwise, basic
  /// monitoring is enabled.
  final bool enabled;

  RunInstancesMonitoringEnabled({
    @required this.enabled,
  });
  static RunInstancesMonitoringEnabled fromJson(Map<String, dynamic> json) =>
      RunInstancesMonitoringEnabled(
        enabled: json['Enabled'] as bool,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Contains the output of RunScheduledInstances.
class RunScheduledInstancesResult {
  /// The IDs of the newly launched instances.
  final List<String> instanceIdSet;

  RunScheduledInstancesResult({
    this.instanceIdSet,
  });
  static RunScheduledInstancesResult fromJson(Map<String, dynamic> json) =>
      RunScheduledInstancesResult(
        instanceIdSet: json.containsKey('InstanceIdSet')
            ? (json['InstanceIdSet'] as List).map((e) => e as String).toList()
            : null,
      );
}

/// Describes the storage parameters for S3 and S3 buckets for an instance
/// store-backed AMI.
class S3Storage {
  /// The access key ID of the owner of the bucket. Before you specify a value
  /// for your access key ID, review and follow the guidance in
  /// [Best Practices for Managing AWS Access Keys](https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html).
  final String awsAccessKeyId;

  /// The bucket in which to store the AMI. You can specify a bucket that you
  /// already own or a new bucket that Amazon EC2 creates on your behalf. If you
  /// specify a bucket that belongs to someone else, Amazon EC2 returns an
  /// error.
  final String bucket;

  /// The beginning of the file name of the AMI.
  final String prefix;

  /// An Amazon S3 upload policy that gives Amazon EC2 permission to upload
  /// items into Amazon S3 on your behalf.
  final Uint8List uploadPolicy;

  /// The signature of the JSON document.
  final String uploadPolicySignature;

  S3Storage({
    this.awsAccessKeyId,
    this.bucket,
    this.prefix,
    this.uploadPolicy,
    this.uploadPolicySignature,
  });
  static S3Storage fromJson(Map<String, dynamic> json) => S3Storage(
        awsAccessKeyId: json.containsKey('AWSAccessKeyId')
            ? json['AWSAccessKeyId'] as String
            : null,
        bucket: json.containsKey('Bucket') ? json['Bucket'] as String : null,
        prefix: json.containsKey('Prefix') ? json['Prefix'] as String : null,
        uploadPolicy: json.containsKey('UploadPolicy')
            ? Uint8List(json['UploadPolicy'])
            : null,
        uploadPolicySignature: json.containsKey('UploadPolicySignature')
            ? json['UploadPolicySignature'] as String
            : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a Scheduled Instance.
class ScheduledInstance {
  /// The Availability Zone.
  final String availabilityZone;

  /// The date when the Scheduled Instance was purchased.
  final DateTime createDate;

  /// The hourly price for a single instance.
  final String hourlyPrice;

  /// The number of instances.
  final int instanceCount;

  /// The instance type.
  final String instanceType;

  /// The network platform (`EC2-Classic` or `EC2-VPC`).
  final String networkPlatform;

  /// The time for the next schedule to start.
  final DateTime nextSlotStartTime;

  /// The platform (`Linux/UNIX` or `Windows`).
  final String platform;

  /// The time that the previous schedule ended or will end.
  final DateTime previousSlotEndTime;

  /// The schedule recurrence.
  final ScheduledInstanceRecurrence recurrence;

  /// The Scheduled Instance ID.
  final String scheduledInstanceId;

  /// The number of hours in the schedule.
  final int slotDurationInHours;

  /// The end date for the Scheduled Instance.
  final DateTime termEndDate;

  /// The start date for the Scheduled Instance.
  final DateTime termStartDate;

  /// The total number of hours for a single instance for the entire term.
  final int totalScheduledInstanceHours;

  ScheduledInstance({
    this.availabilityZone,
    this.createDate,
    this.hourlyPrice,
    this.instanceCount,
    this.instanceType,
    this.networkPlatform,
    this.nextSlotStartTime,
    this.platform,
    this.previousSlotEndTime,
    this.recurrence,
    this.scheduledInstanceId,
    this.slotDurationInHours,
    this.termEndDate,
    this.termStartDate,
    this.totalScheduledInstanceHours,
  });
  static ScheduledInstance fromJson(Map<String, dynamic> json) =>
      ScheduledInstance(
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        createDate: json.containsKey('CreateDate')
            ? DateTime.parse(json['CreateDate'])
            : null,
        hourlyPrice: json.containsKey('HourlyPrice')
            ? json['HourlyPrice'] as String
            : null,
        instanceCount: json.containsKey('InstanceCount')
            ? json['InstanceCount'] as int
            : null,
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        networkPlatform: json.containsKey('NetworkPlatform')
            ? json['NetworkPlatform'] as String
            : null,
        nextSlotStartTime: json.containsKey('NextSlotStartTime')
            ? DateTime.parse(json['NextSlotStartTime'])
            : null,
        platform:
            json.containsKey('Platform') ? json['Platform'] as String : null,
        previousSlotEndTime: json.containsKey('PreviousSlotEndTime')
            ? DateTime.parse(json['PreviousSlotEndTime'])
            : null,
        recurrence: json.containsKey('Recurrence')
            ? ScheduledInstanceRecurrence.fromJson(json['Recurrence'])
            : null,
        scheduledInstanceId: json.containsKey('ScheduledInstanceId')
            ? json['ScheduledInstanceId'] as String
            : null,
        slotDurationInHours: json.containsKey('SlotDurationInHours')
            ? json['SlotDurationInHours'] as int
            : null,
        termEndDate: json.containsKey('TermEndDate')
            ? DateTime.parse(json['TermEndDate'])
            : null,
        termStartDate: json.containsKey('TermStartDate')
            ? DateTime.parse(json['TermStartDate'])
            : null,
        totalScheduledInstanceHours:
            json.containsKey('TotalScheduledInstanceHours')
                ? json['TotalScheduledInstanceHours'] as int
                : null,
      );
}

/// Describes a schedule that is available for your Scheduled Instances.
class ScheduledInstanceAvailability {
  /// The Availability Zone.
  final String availabilityZone;

  /// The number of available instances.
  final int availableInstanceCount;

  /// The time period for the first schedule to start.
  final DateTime firstSlotStartTime;

  /// The hourly price for a single instance.
  final String hourlyPrice;

  /// The instance type. You can specify one of the C3, C4, M4, or R3 instance
  /// types.
  final String instanceType;

  /// The maximum term. The only possible value is 365 days.
  final int maxTermDurationInDays;

  /// The minimum term. The only possible value is 365 days.
  final int minTermDurationInDays;

  /// The network platform (`EC2-Classic` or `EC2-VPC`).
  final String networkPlatform;

  /// The platform (`Linux/UNIX` or `Windows`).
  final String platform;

  /// The purchase token. This token expires in two hours.
  final String purchaseToken;

  /// The schedule recurrence.
  final ScheduledInstanceRecurrence recurrence;

  /// The number of hours in the schedule.
  final int slotDurationInHours;

  /// The total number of hours for a single instance for the entire term.
  final int totalScheduledInstanceHours;

  ScheduledInstanceAvailability({
    this.availabilityZone,
    this.availableInstanceCount,
    this.firstSlotStartTime,
    this.hourlyPrice,
    this.instanceType,
    this.maxTermDurationInDays,
    this.minTermDurationInDays,
    this.networkPlatform,
    this.platform,
    this.purchaseToken,
    this.recurrence,
    this.slotDurationInHours,
    this.totalScheduledInstanceHours,
  });
  static ScheduledInstanceAvailability fromJson(Map<String, dynamic> json) =>
      ScheduledInstanceAvailability(
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        availableInstanceCount: json.containsKey('AvailableInstanceCount')
            ? json['AvailableInstanceCount'] as int
            : null,
        firstSlotStartTime: json.containsKey('FirstSlotStartTime')
            ? DateTime.parse(json['FirstSlotStartTime'])
            : null,
        hourlyPrice: json.containsKey('HourlyPrice')
            ? json['HourlyPrice'] as String
            : null,
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        maxTermDurationInDays: json.containsKey('MaxTermDurationInDays')
            ? json['MaxTermDurationInDays'] as int
            : null,
        minTermDurationInDays: json.containsKey('MinTermDurationInDays')
            ? json['MinTermDurationInDays'] as int
            : null,
        networkPlatform: json.containsKey('NetworkPlatform')
            ? json['NetworkPlatform'] as String
            : null,
        platform:
            json.containsKey('Platform') ? json['Platform'] as String : null,
        purchaseToken: json.containsKey('PurchaseToken')
            ? json['PurchaseToken'] as String
            : null,
        recurrence: json.containsKey('Recurrence')
            ? ScheduledInstanceRecurrence.fromJson(json['Recurrence'])
            : null,
        slotDurationInHours: json.containsKey('SlotDurationInHours')
            ? json['SlotDurationInHours'] as int
            : null,
        totalScheduledInstanceHours:
            json.containsKey('TotalScheduledInstanceHours')
                ? json['TotalScheduledInstanceHours'] as int
                : null,
      );
}

/// Describes the recurring schedule for a Scheduled Instance.
class ScheduledInstanceRecurrence {
  /// The frequency (`Daily`, `Weekly`, or `Monthly`).
  final String frequency;

  /// The interval quantity. The interval unit depends on the value of
  /// `frequency`. For example, every 2 weeks or every 2 months.
  final int interval;

  /// The days. For a monthly schedule, this is one or more days of the month
  /// (1-31). For a weekly schedule, this is one or more days of the week (1-7,
  /// where 1 is Sunday).
  final List<int> occurrenceDaySet;

  /// Indicates whether the occurrence is relative to the end of the specified
  /// week or month.
  final bool occurrenceRelativeToEnd;

  /// The unit for `occurrenceDaySet` (`DayOfWeek` or `DayOfMonth`).
  final String occurrenceUnit;

  ScheduledInstanceRecurrence({
    this.frequency,
    this.interval,
    this.occurrenceDaySet,
    this.occurrenceRelativeToEnd,
    this.occurrenceUnit,
  });
  static ScheduledInstanceRecurrence fromJson(Map<String, dynamic> json) =>
      ScheduledInstanceRecurrence(
        frequency:
            json.containsKey('Frequency') ? json['Frequency'] as String : null,
        interval: json.containsKey('Interval') ? json['Interval'] as int : null,
        occurrenceDaySet: json.containsKey('OccurrenceDaySet')
            ? (json['OccurrenceDaySet'] as List).map((e) => e as int).toList()
            : null,
        occurrenceRelativeToEnd: json.containsKey('OccurrenceRelativeToEnd')
            ? json['OccurrenceRelativeToEnd'] as bool
            : null,
        occurrenceUnit: json.containsKey('OccurrenceUnit')
            ? json['OccurrenceUnit'] as String
            : null,
      );
}

/// Describes the recurring schedule for a Scheduled Instance.
class ScheduledInstanceRecurrenceRequest {
  /// The frequency (`Daily`, `Weekly`, or `Monthly`).
  final String frequency;

  /// The interval quantity. The interval unit depends on the value of
  /// `Frequency`. For example, every 2 weeks or every 2 months.
  final int interval;

  /// The days. For a monthly schedule, this is one or more days of the month
  /// (1-31). For a weekly schedule, this is one or more days of the week (1-7,
  /// where 1 is Sunday). You can't specify this value with a daily schedule. If
  /// the occurrence is relative to the end of the month, you can specify only a
  /// single day.
  final List<int> occurrenceDays;

  /// Indicates whether the occurrence is relative to the end of the specified
  /// week or month. You can't specify this value with a daily schedule.
  final bool occurrenceRelativeToEnd;

  /// The unit for `OccurrenceDays` (`DayOfWeek` or `DayOfMonth`). This value is
  /// required for a monthly schedule. You can't specify `DayOfWeek` with a
  /// weekly schedule. You can't specify this value with a daily schedule.
  final String occurrenceUnit;

  ScheduledInstanceRecurrenceRequest({
    this.frequency,
    this.interval,
    this.occurrenceDays,
    this.occurrenceRelativeToEnd,
    this.occurrenceUnit,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a block device mapping for a Scheduled Instance.
class ScheduledInstancesBlockDeviceMapping {
  /// The device name (for example, `/dev/sdh` or `xvdh`).
  final String deviceName;

  /// Parameters used to set up EBS volumes automatically when the instance is
  /// launched.
  final ScheduledInstancesEbs ebs;

  /// Suppresses the specified device included in the block device mapping of
  /// the AMI.
  final String noDevice;

  /// The virtual device name (`ephemeral`N). Instance store volumes are
  /// numbered starting from 0. An instance type with two available instance
  /// store volumes can specify mappings for `ephemeral0` and `ephemeral1`. The
  /// number of available instance store volumes depends on the instance type.
  /// After you connect to the instance, you must mount the volume.
  ///
  /// Constraints: For M3 instances, you must specify instance store volumes in
  /// the block device mapping for the instance. When you launch an M3 instance,
  /// we ignore any instance store volumes specified in the block device mapping
  /// for the AMI.
  final String virtualName;

  ScheduledInstancesBlockDeviceMapping({
    this.deviceName,
    this.ebs,
    this.noDevice,
    this.virtualName,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes an EBS volume for a Scheduled Instance.
class ScheduledInstancesEbs {
  /// Indicates whether the volume is deleted on instance termination.
  final bool deleteOnTermination;

  /// Indicates whether the volume is encrypted. You can attached encrypted
  /// volumes only to instances that support them.
  final bool encrypted;

  /// The number of I/O operations per second (IOPS) that the volume supports.
  /// For io1 volumes, this represents the number of IOPS that are provisioned
  /// for the volume. For `gp2` volumes, this represents the baseline
  /// performance of the volume and the rate at which the volume accumulates I/O
  /// credits for bursting. For more information about `gp2` baseline
  /// performance, I/O credits, and bursting, see
  /// [Amazon EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// Constraint: Range is 100-20000 IOPS for `io1` volumes and 100-10000 IOPS
  /// for `gp2` volumes.
  ///
  /// Condition: This parameter is required for requests to create `io1`volumes;
  /// it is not used in requests to create `gp2`, `st1`, `sc1`, or `standard`
  /// volumes.
  final int iops;

  /// The ID of the snapshot.
  final String snapshotId;

  /// The size of the volume, in GiB.
  ///
  /// Default: If you're creating the volume from a snapshot and don't specify a
  /// volume size, the default is the snapshot size.
  final int volumeSize;

  /// The volume type. `gp2` for General Purpose SSD, `io1` for Provisioned IOPS
  /// SSD, Throughput Optimized HDD for `st1`, Cold HDD for `sc1`, or `standard`
  /// for Magnetic.
  ///
  /// Default: `gp2`
  final String volumeType;

  ScheduledInstancesEbs({
    this.deleteOnTermination,
    this.encrypted,
    this.iops,
    this.snapshotId,
    this.volumeSize,
    this.volumeType,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes an IAM instance profile for a Scheduled Instance.
class ScheduledInstancesIamInstanceProfile {
  /// The Amazon Resource Name (ARN).
  final String arn;

  /// The name.
  final String name;

  ScheduledInstancesIamInstanceProfile({
    this.arn,
    this.name,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes an IPv6 address.
class ScheduledInstancesIpv6Address {
  /// The IPv6 address.
  final String ipv6Address;

  ScheduledInstancesIpv6Address({
    this.ipv6Address,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the launch specification for a Scheduled Instance.
///
/// If you are launching the Scheduled Instance in EC2-VPC, you must specify the
/// ID of the subnet. You can specify the subnet using either `SubnetId` or
/// `NetworkInterface`.
class ScheduledInstancesLaunchSpecification {
  /// The block device mapping entries.
  final List<ScheduledInstancesBlockDeviceMapping> blockDeviceMappings;

  /// Indicates whether the instances are optimized for EBS I/O. This
  /// optimization provides dedicated throughput to Amazon EBS and an optimized
  /// configuration stack to provide optimal EBS I/O performance. This
  /// optimization isn't available with all instance types. Additional usage
  /// charges apply when using an EBS-optimized instance.
  ///
  /// Default: `false`
  final bool ebsOptimized;

  /// The IAM instance profile.
  final ScheduledInstancesIamInstanceProfile iamInstanceProfile;

  /// The ID of the Amazon Machine Image (AMI).
  final String imageId;

  /// The instance type.
  final String instanceType;

  /// The ID of the kernel.
  final String kernelId;

  /// The name of the key pair.
  final String keyName;

  /// Enable or disable monitoring for the instances.
  final ScheduledInstancesMonitoring monitoring;

  /// The network interfaces.
  final List<ScheduledInstancesNetworkInterface> networkInterfaces;

  /// The placement information.
  final ScheduledInstancesPlacement placement;

  /// The ID of the RAM disk.
  final String ramdiskId;

  /// The IDs of the security groups.
  final List<String> securityGroupIds;

  /// The ID of the subnet in which to launch the instances.
  final String subnetId;

  /// The base64-encoded MIME user data.
  final String userData;

  ScheduledInstancesLaunchSpecification({
    this.blockDeviceMappings,
    this.ebsOptimized,
    this.iamInstanceProfile,
    @required this.imageId,
    this.instanceType,
    this.kernelId,
    this.keyName,
    this.monitoring,
    this.networkInterfaces,
    this.placement,
    this.ramdiskId,
    this.securityGroupIds,
    this.subnetId,
    this.userData,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes whether monitoring is enabled for a Scheduled Instance.
class ScheduledInstancesMonitoring {
  /// Indicates whether monitoring is enabled.
  final bool enabled;

  ScheduledInstancesMonitoring({
    this.enabled,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a network interface for a Scheduled Instance.
class ScheduledInstancesNetworkInterface {
  /// Indicates whether to assign a public IPv4 address to instances launched in
  /// a VPC. The public IPv4 address can only be assigned to a network interface
  /// for eth0, and can only be assigned to a new network interface, not an
  /// existing one. You cannot specify more than one network interface in the
  /// request. If launching into a default subnet, the default value is `true`.
  final bool associatePublicIpAddress;

  /// Indicates whether to delete the interface when the instance is terminated.
  final bool deleteOnTermination;

  /// The description.
  final String description;

  /// The index of the device for the network interface attachment.
  final int deviceIndex;

  /// The IDs of the security groups.
  final List<String> groups;

  /// The number of IPv6 addresses to assign to the network interface. The IPv6
  /// addresses are automatically selected from the subnet range.
  final int ipv6AddressCount;

  /// The specific IPv6 addresses from the subnet range.
  final List<ScheduledInstancesIpv6Address> ipv6Addresses;

  /// The ID of the network interface.
  final String networkInterfaceId;

  /// The IPv4 address of the network interface within the subnet.
  final String privateIpAddress;

  /// The private IPv4 addresses.
  final List<ScheduledInstancesPrivateIpAddressConfig> privateIpAddressConfigs;

  /// The number of secondary private IPv4 addresses.
  final int secondaryPrivateIpAddressCount;

  /// The ID of the subnet.
  final String subnetId;

  ScheduledInstancesNetworkInterface({
    this.associatePublicIpAddress,
    this.deleteOnTermination,
    this.description,
    this.deviceIndex,
    this.groups,
    this.ipv6AddressCount,
    this.ipv6Addresses,
    this.networkInterfaceId,
    this.privateIpAddress,
    this.privateIpAddressConfigs,
    this.secondaryPrivateIpAddressCount,
    this.subnetId,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the placement for a Scheduled Instance.
class ScheduledInstancesPlacement {
  /// The Availability Zone.
  final String availabilityZone;

  /// The name of the placement group.
  final String groupName;

  ScheduledInstancesPlacement({
    this.availabilityZone,
    this.groupName,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a private IPv4 address for a Scheduled Instance.
class ScheduledInstancesPrivateIpAddressConfig {
  /// Indicates whether this is a primary IPv4 address. Otherwise, this is a
  /// secondary IPv4 address.
  final bool primary;

  /// The IPv4 address.
  final String privateIpAddress;

  ScheduledInstancesPrivateIpAddressConfig({
    this.primary,
    this.privateIpAddress,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

class SearchTransitGatewayRoutesResult {
  /// Information about the routes.
  final List<TransitGatewayRoute> routes;

  /// Indicates whether there are additional routes available.
  final bool additionalRoutesAvailable;

  SearchTransitGatewayRoutesResult({
    this.routes,
    this.additionalRoutesAvailable,
  });
  static SearchTransitGatewayRoutesResult fromJson(Map<String, dynamic> json) =>
      SearchTransitGatewayRoutesResult(
        routes: json.containsKey('Routes')
            ? (json['Routes'] as List)
                .map((e) => TransitGatewayRoute.fromJson(e))
                .toList()
            : null,
        additionalRoutesAvailable: json.containsKey('AdditionalRoutesAvailable')
            ? json['AdditionalRoutesAvailable'] as bool
            : null,
      );
}

/// Describes a security group
class SecurityGroup {
  /// A description of the security group.
  final String description;

  /// The name of the security group.
  final String groupName;

  /// The inbound rules associated with the security group.
  final List<IpPermission> ipPermissions;

  /// The AWS account ID of the owner of the security group.
  final String ownerId;

  /// The ID of the security group.
  final String groupId;

  /// [VPC only] The outbound rules associated with the security group.
  final List<IpPermission> ipPermissionsEgress;

  /// Any tags assigned to the security group.
  final List<Tag> tags;

  /// [VPC only] The ID of the VPC for the security group.
  final String vpcId;

  SecurityGroup({
    this.description,
    this.groupName,
    this.ipPermissions,
    this.ownerId,
    this.groupId,
    this.ipPermissionsEgress,
    this.tags,
    this.vpcId,
  });
  static SecurityGroup fromJson(Map<String, dynamic> json) => SecurityGroup(
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        groupName:
            json.containsKey('GroupName') ? json['GroupName'] as String : null,
        ipPermissions: json.containsKey('IpPermissions')
            ? (json['IpPermissions'] as List)
                .map((e) => IpPermission.fromJson(e))
                .toList()
            : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        groupId: json.containsKey('GroupId') ? json['GroupId'] as String : null,
        ipPermissionsEgress: json.containsKey('IpPermissionsEgress')
            ? (json['IpPermissionsEgress'] as List)
                .map((e) => IpPermission.fromJson(e))
                .toList()
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
      );
}

/// Describes a security group.
class SecurityGroupIdentifier {
  /// The ID of the security group.
  final String groupId;

  /// The name of the security group.
  final String groupName;

  SecurityGroupIdentifier({
    this.groupId,
    this.groupName,
  });
  static SecurityGroupIdentifier fromJson(Map<String, dynamic> json) =>
      SecurityGroupIdentifier(
        groupId: json.containsKey('GroupId') ? json['GroupId'] as String : null,
        groupName:
            json.containsKey('GroupName') ? json['GroupName'] as String : null,
      );
}

/// Describes a VPC with a security group that references your security group.
class SecurityGroupReference {
  /// The ID of your security group.
  final String groupId;

  /// The ID of the VPC with the referencing security group.
  final String referencingVpcId;

  /// The ID of the VPC peering connection.
  final String vpcPeeringConnectionId;

  SecurityGroupReference({
    this.groupId,
    this.referencingVpcId,
    this.vpcPeeringConnectionId,
  });
  static SecurityGroupReference fromJson(Map<String, dynamic> json) =>
      SecurityGroupReference(
        groupId: json.containsKey('GroupId') ? json['GroupId'] as String : null,
        referencingVpcId: json.containsKey('ReferencingVpcId')
            ? json['ReferencingVpcId'] as String
            : null,
        vpcPeeringConnectionId: json.containsKey('VpcPeeringConnectionId')
            ? json['VpcPeeringConnectionId'] as String
            : null,
      );
}

/// Describes a service configuration for a VPC endpoint service.
class ServiceConfiguration {
  /// The type of service.
  final List<ServiceTypeDetail> serviceType;

  /// The ID of the service.
  final String serviceId;

  /// The name of the service.
  final String serviceName;

  /// The service state.
  final String serviceState;

  /// In the Availability Zones in which the service is available.
  final List<String> availabilityZones;

  /// Indicates whether requests from other AWS accounts to create an endpoint
  /// to the service must first be accepted.
  final bool acceptanceRequired;

  /// Indicates whether the service manages it's VPC endpoints. Management of
  /// the service VPC endpoints using the VPC endpoint API is restricted.
  final bool managesVpcEndpoints;

  /// The Amazon Resource Names (ARNs) of the Network Load Balancers for the
  /// service.
  final List<String> networkLoadBalancerArns;

  /// The DNS names for the service.
  final List<String> baseEndpointDnsNames;

  /// The private DNS name for the service.
  final String privateDnsName;

  /// Any tags assigned to the service.
  final List<Tag> tags;

  ServiceConfiguration({
    this.serviceType,
    this.serviceId,
    this.serviceName,
    this.serviceState,
    this.availabilityZones,
    this.acceptanceRequired,
    this.managesVpcEndpoints,
    this.networkLoadBalancerArns,
    this.baseEndpointDnsNames,
    this.privateDnsName,
    this.tags,
  });
  static ServiceConfiguration fromJson(Map<String, dynamic> json) =>
      ServiceConfiguration(
        serviceType: json.containsKey('ServiceType')
            ? (json['ServiceType'] as List)
                .map((e) => ServiceTypeDetail.fromJson(e))
                .toList()
            : null,
        serviceId:
            json.containsKey('ServiceId') ? json['ServiceId'] as String : null,
        serviceName: json.containsKey('ServiceName')
            ? json['ServiceName'] as String
            : null,
        serviceState: json.containsKey('ServiceState')
            ? json['ServiceState'] as String
            : null,
        availabilityZones: json.containsKey('AvailabilityZones')
            ? (json['AvailabilityZones'] as List)
                .map((e) => e as String)
                .toList()
            : null,
        acceptanceRequired: json.containsKey('AcceptanceRequired')
            ? json['AcceptanceRequired'] as bool
            : null,
        managesVpcEndpoints: json.containsKey('ManagesVpcEndpoints')
            ? json['ManagesVpcEndpoints'] as bool
            : null,
        networkLoadBalancerArns: json.containsKey('NetworkLoadBalancerArns')
            ? (json['NetworkLoadBalancerArns'] as List)
                .map((e) => e as String)
                .toList()
            : null,
        baseEndpointDnsNames: json.containsKey('BaseEndpointDnsNames')
            ? (json['BaseEndpointDnsNames'] as List)
                .map((e) => e as String)
                .toList()
            : null,
        privateDnsName: json.containsKey('PrivateDnsName')
            ? json['PrivateDnsName'] as String
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes a VPC endpoint service.
class ServiceDetail {
  /// The Amazon Resource Name (ARN) of the service.
  final String serviceName;

  /// The ID of the endpoint service.
  final String serviceId;

  /// The type of service.
  final List<ServiceTypeDetail> serviceType;

  /// The Availability Zones in which the service is available.
  final List<String> availabilityZones;

  /// The AWS account ID of the service owner.
  final String owner;

  /// The DNS names for the service.
  final List<String> baseEndpointDnsNames;

  /// The private DNS name for the service.
  final String privateDnsName;

  /// Indicates whether the service supports endpoint policies.
  final bool vpcEndpointPolicySupported;

  /// Indicates whether VPC endpoint connection requests to the service must be
  /// accepted by the service owner.
  final bool acceptanceRequired;

  /// Indicates whether the service manages it's VPC endpoints. Management of
  /// the service VPC endpoints using the VPC endpoint API is restricted.
  final bool managesVpcEndpoints;

  /// Any tags assigned to the service.
  final List<Tag> tags;

  ServiceDetail({
    this.serviceName,
    this.serviceId,
    this.serviceType,
    this.availabilityZones,
    this.owner,
    this.baseEndpointDnsNames,
    this.privateDnsName,
    this.vpcEndpointPolicySupported,
    this.acceptanceRequired,
    this.managesVpcEndpoints,
    this.tags,
  });
  static ServiceDetail fromJson(Map<String, dynamic> json) => ServiceDetail(
        serviceName: json.containsKey('ServiceName')
            ? json['ServiceName'] as String
            : null,
        serviceId:
            json.containsKey('ServiceId') ? json['ServiceId'] as String : null,
        serviceType: json.containsKey('ServiceType')
            ? (json['ServiceType'] as List)
                .map((e) => ServiceTypeDetail.fromJson(e))
                .toList()
            : null,
        availabilityZones: json.containsKey('AvailabilityZones')
            ? (json['AvailabilityZones'] as List)
                .map((e) => e as String)
                .toList()
            : null,
        owner: json.containsKey('Owner') ? json['Owner'] as String : null,
        baseEndpointDnsNames: json.containsKey('BaseEndpointDnsNames')
            ? (json['BaseEndpointDnsNames'] as List)
                .map((e) => e as String)
                .toList()
            : null,
        privateDnsName: json.containsKey('PrivateDnsName')
            ? json['PrivateDnsName'] as String
            : null,
        vpcEndpointPolicySupported:
            json.containsKey('VpcEndpointPolicySupported')
                ? json['VpcEndpointPolicySupported'] as bool
                : null,
        acceptanceRequired: json.containsKey('AcceptanceRequired')
            ? json['AcceptanceRequired'] as bool
            : null,
        managesVpcEndpoints: json.containsKey('ManagesVpcEndpoints')
            ? json['ManagesVpcEndpoints'] as bool
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes the type of service for a VPC endpoint.
class ServiceTypeDetail {
  /// The type of service.
  final String serviceType;

  ServiceTypeDetail({
    this.serviceType,
  });
  static ServiceTypeDetail fromJson(Map<String, dynamic> json) =>
      ServiceTypeDetail(
        serviceType: json.containsKey('ServiceType')
            ? json['ServiceType'] as String
            : null,
      );
}

/// Describes the time period for a Scheduled Instance to start its first
/// schedule. The time period must span less than one day.
class SlotDateTimeRangeRequest {
  /// The earliest date and time, in UTC, for the Scheduled Instance to start.
  final DateTime earliestTime;

  /// The latest date and time, in UTC, for the Scheduled Instance to start.
  /// This value must be later than or equal to the earliest date and at most
  /// three months in the future.
  final DateTime latestTime;

  SlotDateTimeRangeRequest({
    @required this.earliestTime,
    @required this.latestTime,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the time period for a Scheduled Instance to start its first
/// schedule.
class SlotStartTimeRangeRequest {
  /// The earliest date and time, in UTC, for the Scheduled Instance to start.
  final DateTime earliestTime;

  /// The latest date and time, in UTC, for the Scheduled Instance to start.
  final DateTime latestTime;

  SlotStartTimeRangeRequest({
    this.earliestTime,
    this.latestTime,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a snapshot.
class Snapshot {
  /// The data encryption key identifier for the snapshot. This value is a
  /// unique identifier that corresponds to the data encryption key that was
  /// used to encrypt the original volume or snapshot copy. Because data
  /// encryption keys are inherited by volumes created from snapshots, and vice
  /// versa, if snapshots share the same data encryption key identifier, then
  /// they belong to the same volume/snapshot lineage. This parameter is only
  /// returned by DescribeSnapshots.
  final String dataEncryptionKeyId;

  /// The description for the snapshot.
  final String description;

  /// Indicates whether the snapshot is encrypted.
  final bool encrypted;

  /// The Amazon Resource Name (ARN) of the AWS Key Management Service (AWS KMS)
  /// customer master key (CMK) that was used to protect the volume encryption
  /// key for the parent volume.
  final String kmsKeyId;

  /// The AWS account ID of the EBS snapshot owner.
  final String ownerId;

  /// The progress of the snapshot, as a percentage.
  final String progress;

  /// The ID of the snapshot. Each snapshot receives a unique identifier when it
  /// is created.
  final String snapshotId;

  /// The time stamp when the snapshot was initiated.
  final DateTime startTime;

  /// The snapshot state.
  final String state;

  /// Encrypted Amazon EBS snapshots are copied asynchronously. If a snapshot
  /// copy operation fails (for example, if the proper AWS Key Management
  /// Service (AWS KMS) permissions are not obtained) this field displays error
  /// state details to help you diagnose why the error occurred. This parameter
  /// is only returned by DescribeSnapshots.
  final String stateMessage;

  /// The ID of the volume that was used to create the snapshot. Snapshots
  /// created by the CopySnapshot action have an arbitrary volume ID that should
  /// not be used for any purpose.
  final String volumeId;

  /// The size of the volume, in GiB.
  final int volumeSize;

  ///  Value from an Amazon-maintained list (`amazon` | `self` | `all` |
  /// `aws-marketplace` | `microsoft`) of snapshot owners. Not to be confused
  /// with the user-configured AWS account alias, which is set from the IAM
  /// console.
  final String ownerAlias;

  /// Any tags assigned to the snapshot.
  final List<Tag> tags;

  Snapshot({
    this.dataEncryptionKeyId,
    this.description,
    this.encrypted,
    this.kmsKeyId,
    this.ownerId,
    this.progress,
    this.snapshotId,
    this.startTime,
    this.state,
    this.stateMessage,
    this.volumeId,
    this.volumeSize,
    this.ownerAlias,
    this.tags,
  });
  static Snapshot fromJson(Map<String, dynamic> json) => Snapshot(
        dataEncryptionKeyId: json.containsKey('DataEncryptionKeyId')
            ? json['DataEncryptionKeyId'] as String
            : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        encrypted:
            json.containsKey('Encrypted') ? json['Encrypted'] as bool : null,
        kmsKeyId:
            json.containsKey('KmsKeyId') ? json['KmsKeyId'] as String : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        progress:
            json.containsKey('Progress') ? json['Progress'] as String : null,
        snapshotId: json.containsKey('SnapshotId')
            ? json['SnapshotId'] as String
            : null,
        startTime: json.containsKey('StartTime')
            ? DateTime.parse(json['StartTime'])
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        stateMessage: json.containsKey('StateMessage')
            ? json['StateMessage'] as String
            : null,
        volumeId:
            json.containsKey('VolumeId') ? json['VolumeId'] as String : null,
        volumeSize:
            json.containsKey('VolumeSize') ? json['VolumeSize'] as int : null,
        ownerAlias: json.containsKey('OwnerAlias')
            ? json['OwnerAlias'] as String
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes the snapshot created from the imported disk.
class SnapshotDetail {
  /// A description for the snapshot.
  final String description;

  /// The block device mapping for the snapshot.
  final String deviceName;

  /// The size of the disk in the snapshot, in GiB.
  final double diskImageSize;

  /// The format of the disk image from which the snapshot is created.
  final String format;

  /// The percentage of progress for the task.
  final String progress;

  /// The snapshot ID of the disk being imported.
  final String snapshotId;

  /// A brief status of the snapshot creation.
  final String status;

  /// A detailed status message for the snapshot creation.
  final String statusMessage;

  /// The URL used to access the disk image.
  final String url;

  /// The S3 bucket for the disk image.
  final UserBucketDetails userBucket;

  SnapshotDetail({
    this.description,
    this.deviceName,
    this.diskImageSize,
    this.format,
    this.progress,
    this.snapshotId,
    this.status,
    this.statusMessage,
    this.url,
    this.userBucket,
  });
  static SnapshotDetail fromJson(Map<String, dynamic> json) => SnapshotDetail(
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        deviceName: json.containsKey('DeviceName')
            ? json['DeviceName'] as String
            : null,
        diskImageSize: json.containsKey('DiskImageSize')
            ? json['DiskImageSize'] as double
            : null,
        format: json.containsKey('Format') ? json['Format'] as String : null,
        progress:
            json.containsKey('Progress') ? json['Progress'] as String : null,
        snapshotId: json.containsKey('SnapshotId')
            ? json['SnapshotId'] as String
            : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
        statusMessage: json.containsKey('StatusMessage')
            ? json['StatusMessage'] as String
            : null,
        url: json.containsKey('Url') ? json['Url'] as String : null,
        userBucket: json.containsKey('UserBucket')
            ? UserBucketDetails.fromJson(json['UserBucket'])
            : null,
      );
}

/// The disk container object for the import snapshot request.
class SnapshotDiskContainer {
  /// The description of the disk image being imported.
  final String description;

  /// The format of the disk image being imported.
  ///
  /// Valid values: `VHD` | `VMDK`
  final String format;

  /// The URL to the Amazon S3-based disk image being imported. It can either be
  /// a https URL (https://..) or an Amazon S3 URL (s3://..).
  final String url;

  /// The S3 bucket for the disk image.
  final UserBucket userBucket;

  SnapshotDiskContainer({
    this.description,
    this.format,
    this.url,
    this.userBucket,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Information about a snapshot.
class SnapshotInfo {
  /// Description specified by the CreateSnapshotRequest that has been applied
  /// to all snapshots.
  final String description;

  /// Tags associated with this snapshot.
  final List<Tag> tags;

  /// Indicates whether the snapshot is encrypted.
  final bool encrypted;

  /// Source volume from which this snapshot was created.
  final String volumeId;

  /// Current state of the snapshot.
  final String state;

  /// Size of the volume from which this snapshot was created.
  final int volumeSize;

  /// Time this snapshot was started. This is the same for all snapshots
  /// initiated by the same request.
  final DateTime startTime;

  /// Progress this snapshot has made towards completing.
  final String progress;

  /// Account id used when creating this snapshot.
  final String ownerId;

  /// Snapshot id that can be used to describe this snapshot.
  final String snapshotId;

  SnapshotInfo({
    this.description,
    this.tags,
    this.encrypted,
    this.volumeId,
    this.state,
    this.volumeSize,
    this.startTime,
    this.progress,
    this.ownerId,
    this.snapshotId,
  });
  static SnapshotInfo fromJson(Map<String, dynamic> json) => SnapshotInfo(
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        encrypted:
            json.containsKey('Encrypted') ? json['Encrypted'] as bool : null,
        volumeId:
            json.containsKey('VolumeId') ? json['VolumeId'] as String : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        volumeSize:
            json.containsKey('VolumeSize') ? json['VolumeSize'] as int : null,
        startTime: json.containsKey('StartTime')
            ? DateTime.parse(json['StartTime'])
            : null,
        progress:
            json.containsKey('Progress') ? json['Progress'] as String : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        snapshotId: json.containsKey('SnapshotId')
            ? json['SnapshotId'] as String
            : null,
      );
}

/// Details about the import snapshot task.
class SnapshotTaskDetail {
  /// The description of the snapshot.
  final String description;

  /// The size of the disk in the snapshot, in GiB.
  final double diskImageSize;

  /// Indicates whether the snapshot is encrypted.
  final bool encrypted;

  /// The format of the disk image from which the snapshot is created.
  final String format;

  /// The identifier for the AWS Key Management Service (AWS KMS) customer
  /// master key (CMK) that was used to create the encrypted snapshot.
  final String kmsKeyId;

  /// The percentage of completion for the import snapshot task.
  final String progress;

  /// The snapshot ID of the disk being imported.
  final String snapshotId;

  /// A brief status for the import snapshot task.
  final String status;

  /// A detailed status message for the import snapshot task.
  final String statusMessage;

  /// The URL of the disk image from which the snapshot is created.
  final String url;

  /// The S3 bucket for the disk image.
  final UserBucketDetails userBucket;

  SnapshotTaskDetail({
    this.description,
    this.diskImageSize,
    this.encrypted,
    this.format,
    this.kmsKeyId,
    this.progress,
    this.snapshotId,
    this.status,
    this.statusMessage,
    this.url,
    this.userBucket,
  });
  static SnapshotTaskDetail fromJson(Map<String, dynamic> json) =>
      SnapshotTaskDetail(
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        diskImageSize: json.containsKey('DiskImageSize')
            ? json['DiskImageSize'] as double
            : null,
        encrypted:
            json.containsKey('Encrypted') ? json['Encrypted'] as bool : null,
        format: json.containsKey('Format') ? json['Format'] as String : null,
        kmsKeyId:
            json.containsKey('KmsKeyId') ? json['KmsKeyId'] as String : null,
        progress:
            json.containsKey('Progress') ? json['Progress'] as String : null,
        snapshotId: json.containsKey('SnapshotId')
            ? json['SnapshotId'] as String
            : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
        statusMessage: json.containsKey('StatusMessage')
            ? json['StatusMessage'] as String
            : null,
        url: json.containsKey('Url') ? json['Url'] as String : null,
        userBucket: json.containsKey('UserBucket')
            ? UserBucketDetails.fromJson(json['UserBucket'])
            : null,
      );
}

/// Describes the data feed for a Spot Instance.
class SpotDatafeedSubscription {
  /// The Amazon S3 bucket where the Spot Instance data feed is located.
  final String bucket;

  /// The fault codes for the Spot Instance request, if any.
  final SpotInstanceStateFault fault;

  /// The AWS account ID of the account.
  final String ownerId;

  /// The prefix that is prepended to data feed files.
  final String prefix;

  /// The state of the Spot Instance data feed subscription.
  final String state;

  SpotDatafeedSubscription({
    this.bucket,
    this.fault,
    this.ownerId,
    this.prefix,
    this.state,
  });
  static SpotDatafeedSubscription fromJson(Map<String, dynamic> json) =>
      SpotDatafeedSubscription(
        bucket: json.containsKey('Bucket') ? json['Bucket'] as String : null,
        fault: json.containsKey('Fault')
            ? SpotInstanceStateFault.fromJson(json['Fault'])
            : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        prefix: json.containsKey('Prefix') ? json['Prefix'] as String : null,
        state: json.containsKey('State') ? json['State'] as String : null,
      );
}

/// Describes the launch specification for one or more Spot Instances. If you
/// include On-Demand capacity in your fleet request, you can't use
/// `SpotFleetLaunchSpecification`; you must use
/// [LaunchTemplateConfig](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_LaunchTemplateConfig.html).
class SpotFleetLaunchSpecification {
  /// One or more security groups. When requesting instances in a VPC, you must
  /// specify the IDs of the security groups. When requesting instances in
  /// EC2-Classic, you can specify the names or the IDs of the security groups.
  final List<GroupIdentifier> securityGroups;

  /// Deprecated.
  final String addressingType;

  /// One or more block devices that are mapped to the Spot Instances. You can't
  /// specify both a snapshot ID and an encryption value. This is because only
  /// blank volumes can be encrypted on creation. If a snapshot is the basis for
  /// a volume, it is not blank and its encryption status is used for the volume
  /// encryption status.
  final List<BlockDeviceMapping> blockDeviceMappings;

  /// Indicates whether the instances are optimized for EBS I/O. This
  /// optimization provides dedicated throughput to Amazon EBS and an optimized
  /// configuration stack to provide optimal EBS I/O performance. This
  /// optimization isn't available with all instance types. Additional usage
  /// charges apply when using an EBS Optimized instance.
  ///
  /// Default: `false`
  final bool ebsOptimized;

  /// The IAM instance profile.
  final IamInstanceProfileSpecification iamInstanceProfile;

  /// The ID of the AMI.
  final String imageId;

  /// The instance type.
  final String instanceType;

  /// The ID of the kernel.
  final String kernelId;

  /// The name of the key pair.
  final String keyName;

  /// Enable or disable monitoring for the instances.
  final SpotFleetMonitoring monitoring;

  /// One or more network interfaces. If you specify a network interface, you
  /// must specify subnet IDs and security group IDs using the network
  /// interface.
  final List<InstanceNetworkInterfaceSpecification> networkInterfaces;

  /// The placement information.
  final SpotPlacement placement;

  /// The ID of the RAM disk. Some kernels require additional drivers at launch.
  /// Check the kernel requirements for information about whether you need to
  /// specify a RAM disk. To find kernel requirements, refer to the AWS Resource
  /// Center and search for the kernel ID.
  final String ramdiskId;

  /// The maximum price per unit hour that you are willing to pay for a Spot
  /// Instance. If this value is not specified, the default is the Spot price
  /// specified for the fleet. To determine the Spot price per unit hour, divide
  /// the Spot price by the value of `WeightedCapacity`.
  final String spotPrice;

  /// The IDs of the subnets in which to launch the instances. To specify
  /// multiple subnets, separate them using commas; for example,
  /// "subnet-1234abcdeexample1, subnet-0987cdef6example2".
  final String subnetId;

  /// The Base64-encoded user data that instances use when starting up.
  final String userData;

  /// The number of units provided by the specified instance type. These are the
  /// same units that you chose to set the target capacity in terms of
  /// instances, or a performance characteristic such as vCPUs, memory, or I/O.
  ///
  /// If the target capacity divided by this value is not a whole number, Amazon
  /// EC2 rounds the number of instances to the next whole number. If this value
  /// is not specified, the default is 1.
  final double weightedCapacity;

  /// The tags to apply during creation.
  final List<SpotFleetTagSpecification> tagSpecifications;

  SpotFleetLaunchSpecification({
    this.securityGroups,
    this.addressingType,
    this.blockDeviceMappings,
    this.ebsOptimized,
    this.iamInstanceProfile,
    this.imageId,
    this.instanceType,
    this.kernelId,
    this.keyName,
    this.monitoring,
    this.networkInterfaces,
    this.placement,
    this.ramdiskId,
    this.spotPrice,
    this.subnetId,
    this.userData,
    this.weightedCapacity,
    this.tagSpecifications,
  });
  static SpotFleetLaunchSpecification fromJson(Map<String, dynamic> json) =>
      SpotFleetLaunchSpecification(
        securityGroups: json.containsKey('SecurityGroups')
            ? (json['SecurityGroups'] as List)
                .map((e) => GroupIdentifier.fromJson(e))
                .toList()
            : null,
        addressingType: json.containsKey('AddressingType')
            ? json['AddressingType'] as String
            : null,
        blockDeviceMappings: json.containsKey('BlockDeviceMappings')
            ? (json['BlockDeviceMappings'] as List)
                .map((e) => BlockDeviceMapping.fromJson(e))
                .toList()
            : null,
        ebsOptimized: json.containsKey('EbsOptimized')
            ? json['EbsOptimized'] as bool
            : null,
        iamInstanceProfile: json.containsKey('IamInstanceProfile')
            ? IamInstanceProfileSpecification.fromJson(
                json['IamInstanceProfile'])
            : null,
        imageId: json.containsKey('ImageId') ? json['ImageId'] as String : null,
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        kernelId:
            json.containsKey('KernelId') ? json['KernelId'] as String : null,
        keyName: json.containsKey('KeyName') ? json['KeyName'] as String : null,
        monitoring: json.containsKey('Monitoring')
            ? SpotFleetMonitoring.fromJson(json['Monitoring'])
            : null,
        networkInterfaces: json.containsKey('NetworkInterfaces')
            ? (json['NetworkInterfaces'] as List)
                .map((e) => InstanceNetworkInterfaceSpecification.fromJson(e))
                .toList()
            : null,
        placement: json.containsKey('Placement')
            ? SpotPlacement.fromJson(json['Placement'])
            : null,
        ramdiskId:
            json.containsKey('RamdiskId') ? json['RamdiskId'] as String : null,
        spotPrice:
            json.containsKey('SpotPrice') ? json['SpotPrice'] as String : null,
        subnetId:
            json.containsKey('SubnetId') ? json['SubnetId'] as String : null,
        userData:
            json.containsKey('UserData') ? json['UserData'] as String : null,
        weightedCapacity: json.containsKey('WeightedCapacity')
            ? json['WeightedCapacity'] as double
            : null,
        tagSpecifications: json.containsKey('TagSpecifications')
            ? (json['TagSpecifications'] as List)
                .map((e) => SpotFleetTagSpecification.fromJson(e))
                .toList()
            : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes whether monitoring is enabled.
class SpotFleetMonitoring {
  /// Enables monitoring for the instance.
  ///
  /// Default: `false`
  final bool enabled;

  SpotFleetMonitoring({
    this.enabled,
  });
  static SpotFleetMonitoring fromJson(Map<String, dynamic> json) =>
      SpotFleetMonitoring(
        enabled: json.containsKey('Enabled') ? json['Enabled'] as bool : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a Spot Fleet request.
class SpotFleetRequestConfig {
  /// The progress of the Spot Fleet request. If there is an error, the status
  /// is `error`. After all requests are placed, the status is
  /// `pending_fulfillment`. If the size of the fleet is equal to or greater
  /// than its target capacity, the status is `fulfilled`. If the size of the
  /// fleet is decreased, the status is `pending_termination` while Spot
  /// Instances are terminating.
  final String activityStatus;

  /// The creation date and time of the request.
  final DateTime createTime;

  /// The configuration of the Spot Fleet request.
  final SpotFleetRequestConfigData spotFleetRequestConfig;

  /// The ID of the Spot Fleet request.
  final String spotFleetRequestId;

  /// The state of the Spot Fleet request.
  final String spotFleetRequestState;

  SpotFleetRequestConfig({
    this.activityStatus,
    this.createTime,
    this.spotFleetRequestConfig,
    this.spotFleetRequestId,
    this.spotFleetRequestState,
  });
  static SpotFleetRequestConfig fromJson(Map<String, dynamic> json) =>
      SpotFleetRequestConfig(
        activityStatus: json.containsKey('ActivityStatus')
            ? json['ActivityStatus'] as String
            : null,
        createTime: json.containsKey('CreateTime')
            ? DateTime.parse(json['CreateTime'])
            : null,
        spotFleetRequestConfig: json.containsKey('SpotFleetRequestConfig')
            ? SpotFleetRequestConfigData.fromJson(
                json['SpotFleetRequestConfig'])
            : null,
        spotFleetRequestId: json.containsKey('SpotFleetRequestId')
            ? json['SpotFleetRequestId'] as String
            : null,
        spotFleetRequestState: json.containsKey('SpotFleetRequestState')
            ? json['SpotFleetRequestState'] as String
            : null,
      );
}

/// Describes the configuration of a Spot Fleet request.
class SpotFleetRequestConfigData {
  /// Indicates how to allocate the target Spot Instance capacity across the
  /// Spot Instance pools specified by the Spot Fleet request.
  ///
  /// If the allocation strategy is `lowestPrice`, Spot Fleet launches instances
  /// from the Spot Instance pools with the lowest price. This is the default
  /// allocation strategy.
  ///
  /// If the allocation strategy is `diversified`, Spot Fleet launches instances
  /// from all the Spot Instance pools that you specify.
  ///
  /// If the allocation strategy is `capacityOptimized`, Spot Fleet launches
  /// instances from Spot Instance pools with optimal capacity for the number of
  /// instances that are launching.
  final String allocationStrategy;

  /// The order of the launch template overrides to use in fulfilling On-Demand
  /// capacity. If you specify `lowestPrice`, Spot Fleet uses price to determine
  /// the order, launching the lowest price first. If you specify `prioritized`,
  /// Spot Fleet uses the priority that you assign to each Spot Fleet launch
  /// template override, launching the highest priority first. If you do not
  /// specify a value, Spot Fleet defaults to `lowestPrice`.
  final String onDemandAllocationStrategy;

  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of your listings. This helps to avoid duplicate listings. For
  /// more information, see
  /// [Ensuring Idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
  final String clientToken;

  /// Indicates whether running Spot Instances should be terminated if you
  /// decrease the target capacity of the Spot Fleet request below the current
  /// size of the Spot Fleet.
  final String excessCapacityTerminationPolicy;

  /// The number of units fulfilled by this request compared to the set target
  /// capacity. You cannot set this value.
  final double fulfilledCapacity;

  /// The number of On-Demand units fulfilled by this request compared to the
  /// set target On-Demand capacity.
  final double onDemandFulfilledCapacity;

  /// The Amazon Resource Name (ARN) of an AWS Identity and Access Management
  /// (IAM) role that grants the Spot Fleet the permission to request, launch,
  /// terminate, and tag instances on your behalf. For more information, see
  /// [Spot Fleet Prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html#spot-fleet-prerequisites)
  /// in the _Amazon EC2 User Guide for Linux Instances_. Spot Fleet can
  /// terminate Spot Instances on your behalf when you cancel its Spot Fleet
  /// request using CancelSpotFleetRequests or when the Spot Fleet request
  /// expires, if you set `TerminateInstancesWithExpiration`.
  final String iamFleetRole;

  /// The launch specifications for the Spot Fleet request. If you specify
  /// `LaunchSpecifications`, you can't specify `LaunchTemplateConfigs`. If you
  /// include On-Demand capacity in your request, you must use
  /// `LaunchTemplateConfigs`.
  final List<SpotFleetLaunchSpecification> launchSpecifications;

  /// The launch template and overrides. If you specify `LaunchTemplateConfigs`,
  /// you can't specify `LaunchSpecifications`. If you include On-Demand
  /// capacity in your request, you must use `LaunchTemplateConfigs`.
  final List<LaunchTemplateConfig> launchTemplateConfigs;

  /// The maximum price per unit hour that you are willing to pay for a Spot
  /// Instance. The default is the On-Demand price.
  final String spotPrice;

  /// The number of units to request for the Spot Fleet. You can choose to set
  /// the target capacity in terms of instances or a performance characteristic
  /// that is important to your application workload, such as vCPUs, memory, or
  /// I/O. If the request type is `maintain`, you can specify a target capacity
  /// of 0 and add capacity later.
  final int targetCapacity;

  /// The number of On-Demand units to request. You can choose to set the target
  /// capacity in terms of instances or a performance characteristic that is
  /// important to your application workload, such as vCPUs, memory, or I/O. If
  /// the request type is `maintain`, you can specify a target capacity of 0 and
  /// add capacity later.
  final int onDemandTargetCapacity;

  /// The maximum amount per hour for On-Demand Instances that you're willing to
  /// pay. You can use the `onDemandMaxTotalPrice` parameter, the
  /// `spotMaxTotalPrice` parameter, or both parameters to ensure that your
  /// fleet cost does not exceed your budget. If you set a maximum price per
  /// hour for the On-Demand Instances and Spot Instances in your request, Spot
  /// Fleet will launch instances until it reaches the maximum amount you're
  /// willing to pay. When the maximum amount you're willing to pay is reached,
  /// the fleet stops launching instances even if it hasnt met the target
  /// capacity.
  final String onDemandMaxTotalPrice;

  /// The maximum amount per hour for Spot Instances that you're willing to pay.
  /// You can use the `spotdMaxTotalPrice` parameter, the
  /// `onDemandMaxTotalPrice` parameter, or both parameters to ensure that your
  /// fleet cost does not exceed your budget. If you set a maximum price per
  /// hour for the On-Demand Instances and Spot Instances in your request, Spot
  /// Fleet will launch instances until it reaches the maximum amount you're
  /// willing to pay. When the maximum amount you're willing to pay is reached,
  /// the fleet stops launching instances even if it hasnt met the target
  /// capacity.
  final String spotMaxTotalPrice;

  /// Indicates whether running Spot Instances are terminated when the Spot
  /// Fleet request expires.
  final bool terminateInstancesWithExpiration;

  /// The type of request. Indicates whether the Spot Fleet only requests the
  /// target capacity or also attempts to maintain it. When this value is
  /// `request`, the Spot Fleet only places the required requests. It does not
  /// attempt to replenish Spot Instances if capacity is diminished, nor does it
  /// submit requests in alternative Spot pools if capacity is not available.
  /// When this value is `maintain`, the Spot Fleet maintains the target
  /// capacity. The Spot Fleet places the required requests to meet capacity and
  /// automatically replenishes any interrupted instances. Default: `maintain`.
  /// `instant` is listed but is not used by Spot Fleet.
  final String type;

  /// The start date and time of the request, in UTC format
  /// (_YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z). By default, Amazon EC2 starts
  /// fulfilling the request immediately.
  final DateTime validFrom;

  /// The end date and time of the request, in UTC format
  /// (_YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z). After the end date and time, no new
  /// Spot Instance requests are placed or able to fulfill the request. If no
  /// value is specified, the Spot Fleet request remains until you cancel it.
  final DateTime validUntil;

  /// Indicates whether Spot Fleet should replace unhealthy instances.
  final bool replaceUnhealthyInstances;

  /// The behavior when a Spot Instance is interrupted. The default is
  /// `terminate`.
  final String instanceInterruptionBehavior;

  /// One or more Classic Load Balancers and target groups to attach to the Spot
  /// Fleet request. Spot Fleet registers the running Spot Instances with the
  /// specified Classic Load Balancers and target groups.
  ///
  /// With Network Load Balancers, Spot Fleet cannot register instances that
  /// have the following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1,
  /// G2, HI1, HS1, M1, M2, M3, and T1.
  final LoadBalancersConfig loadBalancersConfig;

  /// The number of Spot pools across which to allocate your target Spot
  /// capacity. Valid only when Spot **AllocationStrategy** is set to
  /// `lowest-price`. Spot Fleet selects the cheapest Spot pools and evenly
  /// allocates your target Spot capacity across the number of Spot pools that
  /// you specify.
  final int instancePoolsToUseCount;

  SpotFleetRequestConfigData({
    this.allocationStrategy,
    this.onDemandAllocationStrategy,
    this.clientToken,
    this.excessCapacityTerminationPolicy,
    this.fulfilledCapacity,
    this.onDemandFulfilledCapacity,
    @required this.iamFleetRole,
    this.launchSpecifications,
    this.launchTemplateConfigs,
    this.spotPrice,
    @required this.targetCapacity,
    this.onDemandTargetCapacity,
    this.onDemandMaxTotalPrice,
    this.spotMaxTotalPrice,
    this.terminateInstancesWithExpiration,
    this.type,
    this.validFrom,
    this.validUntil,
    this.replaceUnhealthyInstances,
    this.instanceInterruptionBehavior,
    this.loadBalancersConfig,
    this.instancePoolsToUseCount,
  });
  static SpotFleetRequestConfigData fromJson(Map<String, dynamic> json) =>
      SpotFleetRequestConfigData(
        allocationStrategy: json.containsKey('AllocationStrategy')
            ? json['AllocationStrategy'] as String
            : null,
        onDemandAllocationStrategy:
            json.containsKey('OnDemandAllocationStrategy')
                ? json['OnDemandAllocationStrategy'] as String
                : null,
        clientToken: json.containsKey('ClientToken')
            ? json['ClientToken'] as String
            : null,
        excessCapacityTerminationPolicy:
            json.containsKey('ExcessCapacityTerminationPolicy')
                ? json['ExcessCapacityTerminationPolicy'] as String
                : null,
        fulfilledCapacity: json.containsKey('FulfilledCapacity')
            ? json['FulfilledCapacity'] as double
            : null,
        onDemandFulfilledCapacity: json.containsKey('OnDemandFulfilledCapacity')
            ? json['OnDemandFulfilledCapacity'] as double
            : null,
        iamFleetRole: json['IamFleetRole'] as String,
        launchSpecifications: json.containsKey('LaunchSpecifications')
            ? (json['LaunchSpecifications'] as List)
                .map((e) => SpotFleetLaunchSpecification.fromJson(e))
                .toList()
            : null,
        launchTemplateConfigs: json.containsKey('LaunchTemplateConfigs')
            ? (json['LaunchTemplateConfigs'] as List)
                .map((e) => LaunchTemplateConfig.fromJson(e))
                .toList()
            : null,
        spotPrice:
            json.containsKey('SpotPrice') ? json['SpotPrice'] as String : null,
        targetCapacity: json['TargetCapacity'] as int,
        onDemandTargetCapacity: json.containsKey('OnDemandTargetCapacity')
            ? json['OnDemandTargetCapacity'] as int
            : null,
        onDemandMaxTotalPrice: json.containsKey('OnDemandMaxTotalPrice')
            ? json['OnDemandMaxTotalPrice'] as String
            : null,
        spotMaxTotalPrice: json.containsKey('SpotMaxTotalPrice')
            ? json['SpotMaxTotalPrice'] as String
            : null,
        terminateInstancesWithExpiration:
            json.containsKey('TerminateInstancesWithExpiration')
                ? json['TerminateInstancesWithExpiration'] as bool
                : null,
        type: json.containsKey('Type') ? json['Type'] as String : null,
        validFrom: json.containsKey('ValidFrom')
            ? DateTime.parse(json['ValidFrom'])
            : null,
        validUntil: json.containsKey('ValidUntil')
            ? DateTime.parse(json['ValidUntil'])
            : null,
        replaceUnhealthyInstances: json.containsKey('ReplaceUnhealthyInstances')
            ? json['ReplaceUnhealthyInstances'] as bool
            : null,
        instanceInterruptionBehavior:
            json.containsKey('InstanceInterruptionBehavior')
                ? json['InstanceInterruptionBehavior'] as String
                : null,
        loadBalancersConfig: json.containsKey('LoadBalancersConfig')
            ? LoadBalancersConfig.fromJson(json['LoadBalancersConfig'])
            : null,
        instancePoolsToUseCount: json.containsKey('InstancePoolsToUseCount')
            ? json['InstancePoolsToUseCount'] as int
            : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// The tags for a Spot Fleet resource.
class SpotFleetTagSpecification {
  /// The type of resource. Currently, the only resource type that is supported
  /// is `instance`.
  final String resourceType;

  /// The tags.
  final List<Tag> tags;

  SpotFleetTagSpecification({
    this.resourceType,
    this.tags,
  });
  static SpotFleetTagSpecification fromJson(Map<String, dynamic> json) =>
      SpotFleetTagSpecification(
        resourceType: json.containsKey('ResourceType')
            ? json['ResourceType'] as String
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a Spot Instance request.
class SpotInstanceRequest {
  /// If you specified a duration and your Spot Instance request was fulfilled,
  /// this is the fixed hourly price in effect for the Spot Instance while it
  /// runs.
  final String actualBlockHourlyPrice;

  /// The Availability Zone group. If you specify the same Availability Zone
  /// group for all Spot Instance requests, all Spot Instances are launched in
  /// the same Availability Zone.
  final String availabilityZoneGroup;

  /// The duration for the Spot Instance, in minutes.
  final int blockDurationMinutes;

  /// The date and time when the Spot Instance request was created, in UTC
  /// format (for example, _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z).
  final DateTime createTime;

  /// The fault codes for the Spot Instance request, if any.
  final SpotInstanceStateFault fault;

  /// The instance ID, if an instance has been launched to fulfill the Spot
  /// Instance request.
  final String instanceId;

  /// The instance launch group. Launch groups are Spot Instances that launch
  /// together and terminate together.
  final String launchGroup;

  /// Additional information for launching instances.
  final LaunchSpecification launchSpecification;

  /// The Availability Zone in which the request is launched.
  final String launchedAvailabilityZone;

  /// The product description associated with the Spot Instance.
  final String productDescription;

  /// The ID of the Spot Instance request.
  final String spotInstanceRequestId;

  /// The maximum price per hour that you are willing to pay for a Spot
  /// Instance.
  final String spotPrice;

  /// The state of the Spot Instance request. Spot status information helps
  /// track your Spot Instance requests. For more information, see
  /// [Spot Status](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html)
  /// in the _Amazon EC2 User Guide for Linux Instances_.
  final String state;

  /// The status code and status message describing the Spot Instance request.
  final SpotInstanceStatus status;

  /// Any tags assigned to the resource.
  final List<Tag> tags;

  /// The Spot Instance request type.
  final String type;

  /// The start date of the request, in UTC format (for example,
  /// _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z). The request becomes active at this date
  /// and time.
  final DateTime validFrom;

  /// The end date of the request, in UTC format (for example,
  /// _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z). If this is a one-time request, it
  /// remains active until all instances launch, the request is canceled, or
  /// this date is reached. If the request is persistent, it remains active
  /// until it is canceled or this date is reached. The default end date is 7
  /// days from the current date.
  final DateTime validUntil;

  /// The behavior when a Spot Instance is interrupted.
  final String instanceInterruptionBehavior;

  SpotInstanceRequest({
    this.actualBlockHourlyPrice,
    this.availabilityZoneGroup,
    this.blockDurationMinutes,
    this.createTime,
    this.fault,
    this.instanceId,
    this.launchGroup,
    this.launchSpecification,
    this.launchedAvailabilityZone,
    this.productDescription,
    this.spotInstanceRequestId,
    this.spotPrice,
    this.state,
    this.status,
    this.tags,
    this.type,
    this.validFrom,
    this.validUntil,
    this.instanceInterruptionBehavior,
  });
  static SpotInstanceRequest fromJson(Map<String, dynamic> json) =>
      SpotInstanceRequest(
        actualBlockHourlyPrice: json.containsKey('ActualBlockHourlyPrice')
            ? json['ActualBlockHourlyPrice'] as String
            : null,
        availabilityZoneGroup: json.containsKey('AvailabilityZoneGroup')
            ? json['AvailabilityZoneGroup'] as String
            : null,
        blockDurationMinutes: json.containsKey('BlockDurationMinutes')
            ? json['BlockDurationMinutes'] as int
            : null,
        createTime: json.containsKey('CreateTime')
            ? DateTime.parse(json['CreateTime'])
            : null,
        fault: json.containsKey('Fault')
            ? SpotInstanceStateFault.fromJson(json['Fault'])
            : null,
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        launchGroup: json.containsKey('LaunchGroup')
            ? json['LaunchGroup'] as String
            : null,
        launchSpecification: json.containsKey('LaunchSpecification')
            ? LaunchSpecification.fromJson(json['LaunchSpecification'])
            : null,
        launchedAvailabilityZone: json.containsKey('LaunchedAvailabilityZone')
            ? json['LaunchedAvailabilityZone'] as String
            : null,
        productDescription: json.containsKey('ProductDescription')
            ? json['ProductDescription'] as String
            : null,
        spotInstanceRequestId: json.containsKey('SpotInstanceRequestId')
            ? json['SpotInstanceRequestId'] as String
            : null,
        spotPrice:
            json.containsKey('SpotPrice') ? json['SpotPrice'] as String : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        status: json.containsKey('Status')
            ? SpotInstanceStatus.fromJson(json['Status'])
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        type: json.containsKey('Type') ? json['Type'] as String : null,
        validFrom: json.containsKey('ValidFrom')
            ? DateTime.parse(json['ValidFrom'])
            : null,
        validUntil: json.containsKey('ValidUntil')
            ? DateTime.parse(json['ValidUntil'])
            : null,
        instanceInterruptionBehavior:
            json.containsKey('InstanceInterruptionBehavior')
                ? json['InstanceInterruptionBehavior'] as String
                : null,
      );
}

/// Describes a Spot Instance state change.
class SpotInstanceStateFault {
  /// The reason code for the Spot Instance state change.
  final String code;

  /// The message for the Spot Instance state change.
  final String message;

  SpotInstanceStateFault({
    this.code,
    this.message,
  });
  static SpotInstanceStateFault fromJson(Map<String, dynamic> json) =>
      SpotInstanceStateFault(
        code: json.containsKey('Code') ? json['Code'] as String : null,
        message: json.containsKey('Message') ? json['Message'] as String : null,
      );
}

/// Describes the status of a Spot Instance request.
class SpotInstanceStatus {
  /// The status code. For a list of status codes, see
  /// [Spot Status Codes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html#spot-instance-bid-status-understand)
  /// in the _Amazon EC2 User Guide for Linux Instances_.
  final String code;

  /// The description for the status code.
  final String message;

  /// The date and time of the most recent status update, in UTC format (for
  /// example, _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z).
  final DateTime updateTime;

  SpotInstanceStatus({
    this.code,
    this.message,
    this.updateTime,
  });
  static SpotInstanceStatus fromJson(Map<String, dynamic> json) =>
      SpotInstanceStatus(
        code: json.containsKey('Code') ? json['Code'] as String : null,
        message: json.containsKey('Message') ? json['Message'] as String : null,
        updateTime: json.containsKey('UpdateTime')
            ? DateTime.parse(json['UpdateTime'])
            : null,
      );
}

/// The options for Spot Instances.
class SpotMarketOptions {
  /// The maximum hourly price you're willing to pay for the Spot Instances. The
  /// default is the On-Demand price.
  final String maxPrice;

  /// The Spot Instance request type. For RunInstances, persistent Spot Instance
  /// requests are only supported when **InstanceInterruptionBehavior** is set
  /// to either `hibernate` or `stop`.
  final String spotInstanceType;

  /// The required duration for the Spot Instances (also known as Spot blocks),
  /// in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300,
  /// or 360).
  final int blockDurationMinutes;

  /// The end date of the request. For a one-time request, the request remains
  /// active until all instances launch, the request is canceled, or this date
  /// is reached. If the request is persistent, it remains active until it is
  /// canceled or this date and time is reached. The default end date is 7 days
  /// from the current date.
  final DateTime validUntil;

  /// The behavior when a Spot Instance is interrupted. The default is
  /// `terminate`.
  final String instanceInterruptionBehavior;

  SpotMarketOptions({
    this.maxPrice,
    this.spotInstanceType,
    this.blockDurationMinutes,
    this.validUntil,
    this.instanceInterruptionBehavior,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the configuration of Spot Instances in an EC2 Fleet.
class SpotOptions {
  /// Indicates how to allocate the target Spot Instance capacity across the
  /// Spot Instance pools specified by the EC2 Fleet.
  ///
  /// If the allocation strategy is `lowestPrice`, EC2 Fleet launches instances
  /// from the Spot Instance pools with the lowest price. This is the default
  /// allocation strategy.
  ///
  /// If the allocation strategy is `diversified`, EC2 Fleet launches instances
  /// from all the Spot Instance pools that you specify.
  ///
  /// If the allocation strategy is `capacityOptimized`, EC2 Fleet launches
  /// instances from Spot Instance pools with optimal capacity for the number of
  /// instances that are launching.
  final String allocationStrategy;

  /// The behavior when a Spot Instance is interrupted. The default is
  /// `terminate`.
  final String instanceInterruptionBehavior;

  /// The number of Spot pools across which to allocate your target Spot
  /// capacity. Valid only when **AllocationStrategy** is set to `lowestPrice`.
  /// EC2 Fleet selects the cheapest Spot pools and evenly allocates your target
  /// Spot capacity across the number of Spot pools that you specify.
  final int instancePoolsToUseCount;

  /// Indicates that the fleet uses a single instance type to launch all Spot
  /// Instances in the fleet.
  final bool singleInstanceType;

  /// Indicates that the fleet launches all Spot Instances into a single
  /// Availability Zone.
  final bool singleAvailabilityZone;

  /// The minimum target capacity for Spot Instances in the fleet. If the
  /// minimum target capacity is not reached, the fleet launches no instances.
  final int minTargetCapacity;

  /// The maximum amount per hour for Spot Instances that you're willing to pay.
  final String maxTotalPrice;

  SpotOptions({
    this.allocationStrategy,
    this.instanceInterruptionBehavior,
    this.instancePoolsToUseCount,
    this.singleInstanceType,
    this.singleAvailabilityZone,
    this.minTargetCapacity,
    this.maxTotalPrice,
  });
  static SpotOptions fromJson(Map<String, dynamic> json) => SpotOptions(
        allocationStrategy: json.containsKey('AllocationStrategy')
            ? json['AllocationStrategy'] as String
            : null,
        instanceInterruptionBehavior:
            json.containsKey('InstanceInterruptionBehavior')
                ? json['InstanceInterruptionBehavior'] as String
                : null,
        instancePoolsToUseCount: json.containsKey('InstancePoolsToUseCount')
            ? json['InstancePoolsToUseCount'] as int
            : null,
        singleInstanceType: json.containsKey('SingleInstanceType')
            ? json['SingleInstanceType'] as bool
            : null,
        singleAvailabilityZone: json.containsKey('SingleAvailabilityZone')
            ? json['SingleAvailabilityZone'] as bool
            : null,
        minTargetCapacity: json.containsKey('MinTargetCapacity')
            ? json['MinTargetCapacity'] as int
            : null,
        maxTotalPrice: json.containsKey('MaxTotalPrice')
            ? json['MaxTotalPrice'] as String
            : null,
      );
}

/// Describes the configuration of Spot Instances in an EC2 Fleet request.
class SpotOptionsRequest {
  /// Indicates how to allocate the target Spot Instance capacity across the
  /// Spot Instance pools specified by the EC2 Fleet.
  ///
  /// If the allocation strategy is `lowestPrice`, EC2 Fleet launches instances
  /// from the Spot Instance pools with the lowest price. This is the default
  /// allocation strategy.
  ///
  /// If the allocation strategy is `diversified`, EC2 Fleet launches instances
  /// from all the Spot Instance pools that you specify.
  ///
  /// If the allocation strategy is `capacityOptimized`, EC2 Fleet launches
  /// instances from Spot Instance pools with optimal capacity for the number of
  /// instances that are launching.
  final String allocationStrategy;

  /// The behavior when a Spot Instance is interrupted. The default is
  /// `terminate`.
  final String instanceInterruptionBehavior;

  /// The number of Spot pools across which to allocate your target Spot
  /// capacity. Valid only when Spot **AllocationStrategy** is set to
  /// `lowest-price`. EC2 Fleet selects the cheapest Spot pools and evenly
  /// allocates your target Spot capacity across the number of Spot pools that
  /// you specify.
  final int instancePoolsToUseCount;

  /// Indicates that the fleet uses a single instance type to launch all Spot
  /// Instances in the fleet.
  final bool singleInstanceType;

  /// Indicates that the fleet launches all Spot Instances into a single
  /// Availability Zone.
  final bool singleAvailabilityZone;

  /// The minimum target capacity for Spot Instances in the fleet. If the
  /// minimum target capacity is not reached, the fleet launches no instances.
  final int minTargetCapacity;

  /// The maximum amount per hour for Spot Instances that you're willing to pay.
  final String maxTotalPrice;

  SpotOptionsRequest({
    this.allocationStrategy,
    this.instanceInterruptionBehavior,
    this.instancePoolsToUseCount,
    this.singleInstanceType,
    this.singleAvailabilityZone,
    this.minTargetCapacity,
    this.maxTotalPrice,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes Spot Instance placement.
class SpotPlacement {
  /// The Availability Zone.
  ///
  /// [Spot Fleet only] To specify multiple Availability Zones, separate them
  /// using commas; for example, "us-west-2a, us-west-2b".
  final String availabilityZone;

  /// The name of the placement group.
  final String groupName;

  /// The tenancy of the instance (if the instance is running in a VPC). An
  /// instance with a tenancy of `dedicated` runs on single-tenant hardware. The
  /// `host` tenancy is not supported for Spot Instances.
  final String tenancy;

  SpotPlacement({
    this.availabilityZone,
    this.groupName,
    this.tenancy,
  });
  static SpotPlacement fromJson(Map<String, dynamic> json) => SpotPlacement(
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        groupName:
            json.containsKey('GroupName') ? json['GroupName'] as String : null,
        tenancy: json.containsKey('Tenancy') ? json['Tenancy'] as String : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the maximum price per hour that you are willing to pay for a Spot
/// Instance.
class SpotPrice {
  /// The Availability Zone.
  final String availabilityZone;

  /// The instance type.
  final String instanceType;

  /// A general description of the AMI.
  final String productDescription;

  /// The maximum price per hour that you are willing to pay for a Spot
  /// Instance.
  final String spotPrice;

  /// The date and time the request was created, in UTC format (for example,
  /// _YYYY_-_MM_-_DD_T_HH_:_MM_:_SS_Z).
  final DateTime timestamp;

  SpotPrice({
    this.availabilityZone,
    this.instanceType,
    this.productDescription,
    this.spotPrice,
    this.timestamp,
  });
  static SpotPrice fromJson(Map<String, dynamic> json) => SpotPrice(
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        instanceType: json.containsKey('InstanceType')
            ? json['InstanceType'] as String
            : null,
        productDescription: json.containsKey('ProductDescription')
            ? json['ProductDescription'] as String
            : null,
        spotPrice:
            json.containsKey('SpotPrice') ? json['SpotPrice'] as String : null,
        timestamp: json.containsKey('Timestamp')
            ? DateTime.parse(json['Timestamp'])
            : null,
      );
}

/// Describes a stale rule in a security group.
class StaleIpPermission {
  /// The start of the port range for the TCP and UDP protocols, or an ICMP type
  /// number. A value of `-1` indicates all ICMP types.
  final int fromPort;

  /// The IP protocol name (for `tcp`, `udp`, and `icmp`) or number (see
  /// [Protocol Numbers)](http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
  final String ipProtocol;

  /// The IP ranges. Not applicable for stale security group rules.
  final List<String> ipRanges;

  /// The prefix list IDs for an AWS service. Not applicable for stale security
  /// group rules.
  final List<String> prefixListIds;

  /// The end of the port range for the TCP and UDP protocols, or an ICMP type
  /// number. A value of `-1` indicates all ICMP types.
  final int toPort;

  /// The security group pairs. Returns the ID of the referenced security group
  /// and VPC, and the ID and status of the VPC peering connection.
  final List<UserIdGroupPair> userIdGroupPairs;

  StaleIpPermission({
    this.fromPort,
    this.ipProtocol,
    this.ipRanges,
    this.prefixListIds,
    this.toPort,
    this.userIdGroupPairs,
  });
  static StaleIpPermission fromJson(Map<String, dynamic> json) =>
      StaleIpPermission(
        fromPort: json.containsKey('FromPort') ? json['FromPort'] as int : null,
        ipProtocol: json.containsKey('IpProtocol')
            ? json['IpProtocol'] as String
            : null,
        ipRanges: json.containsKey('IpRanges')
            ? (json['IpRanges'] as List).map((e) => e as String).toList()
            : null,
        prefixListIds: json.containsKey('PrefixListIds')
            ? (json['PrefixListIds'] as List).map((e) => e as String).toList()
            : null,
        toPort: json.containsKey('ToPort') ? json['ToPort'] as int : null,
        userIdGroupPairs: json.containsKey('UserIdGroupPairs')
            ? (json['UserIdGroupPairs'] as List)
                .map((e) => UserIdGroupPair.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes a stale security group (a security group that contains stale
/// rules).
class StaleSecurityGroup {
  /// The description of the security group.
  final String description;

  /// The ID of the security group.
  final String groupId;

  /// The name of the security group.
  final String groupName;

  /// Information about the stale inbound rules in the security group.
  final List<StaleIpPermission> staleIpPermissions;

  /// Information about the stale outbound rules in the security group.
  final List<StaleIpPermission> staleIpPermissionsEgress;

  /// The ID of the VPC for the security group.
  final String vpcId;

  StaleSecurityGroup({
    this.description,
    this.groupId,
    this.groupName,
    this.staleIpPermissions,
    this.staleIpPermissionsEgress,
    this.vpcId,
  });
  static StaleSecurityGroup fromJson(Map<String, dynamic> json) =>
      StaleSecurityGroup(
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        groupId: json.containsKey('GroupId') ? json['GroupId'] as String : null,
        groupName:
            json.containsKey('GroupName') ? json['GroupName'] as String : null,
        staleIpPermissions: json.containsKey('StaleIpPermissions')
            ? (json['StaleIpPermissions'] as List)
                .map((e) => StaleIpPermission.fromJson(e))
                .toList()
            : null,
        staleIpPermissionsEgress: json.containsKey('StaleIpPermissionsEgress')
            ? (json['StaleIpPermissionsEgress'] as List)
                .map((e) => StaleIpPermission.fromJson(e))
                .toList()
            : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
      );
}

class StartInstancesResult {
  /// Information about the started instances.
  final List<InstanceStateChange> startingInstances;

  StartInstancesResult({
    this.startingInstances,
  });
  static StartInstancesResult fromJson(Map<String, dynamic> json) =>
      StartInstancesResult(
        startingInstances: json.containsKey('StartingInstances')
            ? (json['StartingInstances'] as List)
                .map((e) => InstanceStateChange.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes a state change.
class StateReason {
  /// The reason code for the state change.
  final String code;

  /// The message for the state change.
  ///
  /// *    `Server.InsufficientInstanceCapacity`: There was insufficient
  /// capacity available to satisfy the launch request.
  ///
  /// *    `Server.InternalError`: An internal error caused the instance to
  /// terminate during launch.
  ///
  /// *    `Server.ScheduledStop`: The instance was stopped due to a scheduled
  /// retirement.
  ///
  /// *    `Server.SpotInstanceShutdown`: The instance was stopped because the
  /// number of Spot requests with a maximum price equal to or higher than the
  /// Spot price exceeded available capacity or because of an increase in the
  /// Spot price.
  ///
  /// *    `Server.SpotInstanceTermination`: The instance was terminated because
  /// the number of Spot requests with a maximum price equal to or higher than
  /// the Spot price exceeded available capacity or because of an increase in
  /// the Spot price.
  ///
  /// *    `Client.InstanceInitiatedShutdown`: The instance was shut down using
  /// the `shutdown -h` command from the instance.
  ///
  /// *    `Client.InstanceTerminated`: The instance was terminated or rebooted
  /// during AMI creation.
  ///
  /// *    `Client.InternalError`: A client error caused the instance to
  /// terminate during launch.
  ///
  /// *    `Client.InvalidSnapshot.NotFound`: The specified snapshot was not
  /// found.
  ///
  /// *    `Client.UserInitiatedHibernate`: Hibernation was initiated on the
  /// instance.
  ///
  /// *    `Client.UserInitiatedShutdown`: The instance was shut down using the
  /// Amazon EC2 API.
  ///
  /// *    `Client.VolumeLimitExceeded`: The limit on the number of EBS volumes
  /// or total storage was exceeded. Decrease usage or request an increase in
  /// your account limits.
  final String message;

  StateReason({
    this.code,
    this.message,
  });
  static StateReason fromJson(Map<String, dynamic> json) => StateReason(
        code: json.containsKey('Code') ? json['Code'] as String : null,
        message: json.containsKey('Message') ? json['Message'] as String : null,
      );
}

class StopInstancesResult {
  /// Information about the stopped instances.
  final List<InstanceStateChange> stoppingInstances;

  StopInstancesResult({
    this.stoppingInstances,
  });
  static StopInstancesResult fromJson(Map<String, dynamic> json) =>
      StopInstancesResult(
        stoppingInstances: json.containsKey('StoppingInstances')
            ? (json['StoppingInstances'] as List)
                .map((e) => InstanceStateChange.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes the storage location for an instance store-backed AMI.
class Storage {
  /// An Amazon S3 storage location.
  final S3Storage s3;

  Storage({
    this.s3,
  });
  static Storage fromJson(Map<String, dynamic> json) => Storage(
        s3: json.containsKey('S3') ? S3Storage.fromJson(json['S3']) : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a storage location in Amazon S3.
class StorageLocation {
  /// The name of the S3 bucket.
  final String bucket;

  /// The key.
  final String key;

  StorageLocation({
    this.bucket,
    this.key,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a subnet.
class Subnet {
  /// The Availability Zone of the subnet.
  final String availabilityZone;

  /// The AZ ID of the subnet.
  final String availabilityZoneId;

  /// The number of unused private IPv4 addresses in the subnet. The IPv4
  /// addresses for any stopped instances are considered unavailable.
  final int availableIpAddressCount;

  /// The IPv4 CIDR block assigned to the subnet.
  final String cidrBlock;

  /// Indicates whether this is the default subnet for the Availability Zone.
  final bool defaultForAz;

  /// Indicates whether instances launched in this subnet receive a public IPv4
  /// address.
  final bool mapPublicIpOnLaunch;

  /// The current state of the subnet.
  final String state;

  /// The ID of the subnet.
  final String subnetId;

  /// The ID of the VPC the subnet is in.
  final String vpcId;

  /// The ID of the AWS account that owns the subnet.
  final String ownerId;

  /// Indicates whether a network interface created in this subnet (including a
  /// network interface created by RunInstances) receives an IPv6 address.
  final bool assignIpv6AddressOnCreation;

  /// Information about the IPv6 CIDR blocks associated with the subnet.
  final List<SubnetIpv6CidrBlockAssociation> ipv6CidrBlockAssociationSet;

  /// Any tags assigned to the subnet.
  final List<Tag> tags;

  /// The Amazon Resource Name (ARN) of the subnet.
  final String subnetArn;

  Subnet({
    this.availabilityZone,
    this.availabilityZoneId,
    this.availableIpAddressCount,
    this.cidrBlock,
    this.defaultForAz,
    this.mapPublicIpOnLaunch,
    this.state,
    this.subnetId,
    this.vpcId,
    this.ownerId,
    this.assignIpv6AddressOnCreation,
    this.ipv6CidrBlockAssociationSet,
    this.tags,
    this.subnetArn,
  });
  static Subnet fromJson(Map<String, dynamic> json) => Subnet(
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        availabilityZoneId: json.containsKey('AvailabilityZoneId')
            ? json['AvailabilityZoneId'] as String
            : null,
        availableIpAddressCount: json.containsKey('AvailableIpAddressCount')
            ? json['AvailableIpAddressCount'] as int
            : null,
        cidrBlock:
            json.containsKey('CidrBlock') ? json['CidrBlock'] as String : null,
        defaultForAz: json.containsKey('DefaultForAz')
            ? json['DefaultForAz'] as bool
            : null,
        mapPublicIpOnLaunch: json.containsKey('MapPublicIpOnLaunch')
            ? json['MapPublicIpOnLaunch'] as bool
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        subnetId:
            json.containsKey('SubnetId') ? json['SubnetId'] as String : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        assignIpv6AddressOnCreation:
            json.containsKey('AssignIpv6AddressOnCreation')
                ? json['AssignIpv6AddressOnCreation'] as bool
                : null,
        ipv6CidrBlockAssociationSet:
            json.containsKey('Ipv6CidrBlockAssociationSet')
                ? (json['Ipv6CidrBlockAssociationSet'] as List)
                    .map((e) => SubnetIpv6CidrBlockAssociation.fromJson(e))
                    .toList()
                : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        subnetArn:
            json.containsKey('SubnetArn') ? json['SubnetArn'] as String : null,
      );
}

/// Describes the state of a CIDR block.
class SubnetCidrBlockState {
  /// The state of a CIDR block.
  final String state;

  /// A message about the status of the CIDR block, if applicable.
  final String statusMessage;

  SubnetCidrBlockState({
    this.state,
    this.statusMessage,
  });
  static SubnetCidrBlockState fromJson(Map<String, dynamic> json) =>
      SubnetCidrBlockState(
        state: json.containsKey('State') ? json['State'] as String : null,
        statusMessage: json.containsKey('StatusMessage')
            ? json['StatusMessage'] as String
            : null,
      );
}

/// Describes an IPv6 CIDR block associated with a subnet.
class SubnetIpv6CidrBlockAssociation {
  /// The association ID for the CIDR block.
  final String associationId;

  /// The IPv6 CIDR block.
  final String ipv6CidrBlock;

  /// Information about the state of the CIDR block.
  final SubnetCidrBlockState ipv6CidrBlockState;

  SubnetIpv6CidrBlockAssociation({
    this.associationId,
    this.ipv6CidrBlock,
    this.ipv6CidrBlockState,
  });
  static SubnetIpv6CidrBlockAssociation fromJson(Map<String, dynamic> json) =>
      SubnetIpv6CidrBlockAssociation(
        associationId: json.containsKey('AssociationId')
            ? json['AssociationId'] as String
            : null,
        ipv6CidrBlock: json.containsKey('Ipv6CidrBlock')
            ? json['Ipv6CidrBlock'] as String
            : null,
        ipv6CidrBlockState: json.containsKey('Ipv6CidrBlockState')
            ? SubnetCidrBlockState.fromJson(json['Ipv6CidrBlockState'])
            : null,
      );
}

/// Describes the T2 or T3 instance whose credit option for CPU usage was
/// successfully modified.
class SuccessfulInstanceCreditSpecificationItem {
  /// The ID of the instance.
  final String instanceId;

  SuccessfulInstanceCreditSpecificationItem({
    this.instanceId,
  });
  static SuccessfulInstanceCreditSpecificationItem fromJson(
          Map<String, dynamic> json) =>
      SuccessfulInstanceCreditSpecificationItem(
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
      );
}

/// Describes a tag.
class Tag {
  /// The key of the tag.
  ///
  /// Constraints: Tag keys are case-sensitive and accept a maximum of 127
  /// Unicode characters. May not begin with `aws:`.
  final String key;

  /// The value of the tag.
  ///
  /// Constraints: Tag values are case-sensitive and accept a maximum of 255
  /// Unicode characters.
  final String value;

  Tag({
    this.key,
    this.value,
  });
  static Tag fromJson(Map<String, dynamic> json) => Tag(
        key: json.containsKey('Key') ? json['Key'] as String : null,
        value: json.containsKey('Value') ? json['Value'] as String : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a tag.
class TagDescription {
  /// The tag key.
  final String key;

  /// The ID of the resource.
  final String resourceId;

  /// The resource type.
  final String resourceType;

  /// The tag value.
  final String value;

  TagDescription({
    this.key,
    this.resourceId,
    this.resourceType,
    this.value,
  });
  static TagDescription fromJson(Map<String, dynamic> json) => TagDescription(
        key: json.containsKey('Key') ? json['Key'] as String : null,
        resourceId: json.containsKey('ResourceId')
            ? json['ResourceId'] as String
            : null,
        resourceType: json.containsKey('ResourceType')
            ? json['ResourceType'] as String
            : null,
        value: json.containsKey('Value') ? json['Value'] as String : null,
      );
}

/// The tags to apply to a resource when the resource is being created.
class TagSpecification {
  /// The type of resource to tag. Currently, the resource types that support
  /// tagging on creation are: `capacity-reservation` | `client-vpn-endpoint` |
  /// `dedicated-host` | `fleet` | `instance` | `launch-template` | `snapshot` |
  /// `transit-gateway` | `transit-gateway-attachment` |
  /// `transit-gateway-route-table` | `volume`.
  ///
  /// To tag a resource after it has been created, see CreateTags.
  final String resourceType;

  /// The tags to apply to the resource.
  final List<Tag> tags;

  TagSpecification({
    this.resourceType,
    this.tags,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// The number of units to request. You can choose to set the target capacity in
/// terms of instances or a performance characteristic that is important to your
/// application workload, such as vCPUs, memory, or I/O. If the request type is
/// `maintain`, you can specify a target capacity of 0 and add capacity later.
///
/// You can use the On-Demand Instance `MaxTotalPrice` parameter, the Spot
/// Instance `MaxTotalPrice`, or both to ensure your fleet cost does not exceed
/// your budget. If you set a maximum price per hour for the On-Demand Instances
/// and Spot Instances in your request, EC2 Fleet will launch instances until it
/// reaches the maximum amount you're willing to pay. When the maximum amount
/// you're willing to pay is reached, the fleet stops launching instances even
/// if it hasnt met the target capacity. The `MaxTotalPrice` parameters are
/// located in and
class TargetCapacitySpecification {
  /// The number of units to request, filled using `DefaultTargetCapacityType`.
  final int totalTargetCapacity;

  /// The number of On-Demand units to request. If you specify a target capacity
  /// for Spot units, you cannot specify a target capacity for On-Demand units.
  final int onDemandTargetCapacity;

  /// The maximum number of Spot units to launch. If you specify a target
  /// capacity for On-Demand units, you cannot specify a target capacity for
  /// Spot units.
  final int spotTargetCapacity;

  /// The default `TotalTargetCapacity`, which is either `Spot` or `On-Demand`.
  final String defaultTargetCapacityType;

  TargetCapacitySpecification({
    this.totalTargetCapacity,
    this.onDemandTargetCapacity,
    this.spotTargetCapacity,
    this.defaultTargetCapacityType,
  });
  static TargetCapacitySpecification fromJson(Map<String, dynamic> json) =>
      TargetCapacitySpecification(
        totalTargetCapacity: json.containsKey('TotalTargetCapacity')
            ? json['TotalTargetCapacity'] as int
            : null,
        onDemandTargetCapacity: json.containsKey('OnDemandTargetCapacity')
            ? json['OnDemandTargetCapacity'] as int
            : null,
        spotTargetCapacity: json.containsKey('SpotTargetCapacity')
            ? json['SpotTargetCapacity'] as int
            : null,
        defaultTargetCapacityType: json.containsKey('DefaultTargetCapacityType')
            ? json['DefaultTargetCapacityType'] as String
            : null,
      );
}

/// The number of units to request. You can choose to set the target capacity as
/// the number of instances. Or you can set the target capacity to a performance
/// characteristic that is important to your application workload, such as
/// vCPUs, memory, or I/O. If the request type is `maintain`, you can specify a
/// target capacity of 0 and add capacity later.
///
/// You can use the On-Demand Instance `MaxTotalPrice` parameter, the Spot
/// Instance `MaxTotalPrice` parameter, or both parameters to ensure that your
/// fleet cost does not exceed your budget. If you set a maximum price per hour
/// for the On-Demand Instances and Spot Instances in your request, EC2 Fleet
/// will launch instances until it reaches the maximum amount you're willing to
/// pay. When the maximum amount you're willing to pay is reached, the fleet
/// stops launching instances even if it hasnt met the target capacity. The
/// `MaxTotalPrice` parameters are located in and .
class TargetCapacitySpecificationRequest {
  /// The number of units to request, filled using `DefaultTargetCapacityType`.
  final int totalTargetCapacity;

  /// The number of On-Demand units to request.
  final int onDemandTargetCapacity;

  /// The number of Spot units to request.
  final int spotTargetCapacity;

  /// The default `TotalTargetCapacity`, which is either `Spot` or `On-Demand`.
  final String defaultTargetCapacityType;

  TargetCapacitySpecificationRequest({
    @required this.totalTargetCapacity,
    this.onDemandTargetCapacity,
    this.spotTargetCapacity,
    this.defaultTargetCapacityType,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Information about the Convertible Reserved Instance offering.
class TargetConfiguration {
  /// The number of instances the Convertible Reserved Instance offering can be
  /// applied to. This parameter is reserved and cannot be specified in a
  /// request
  final int instanceCount;

  /// The ID of the Convertible Reserved Instance offering.
  final String offeringId;

  TargetConfiguration({
    this.instanceCount,
    this.offeringId,
  });
  static TargetConfiguration fromJson(Map<String, dynamic> json) =>
      TargetConfiguration(
        instanceCount: json.containsKey('InstanceCount')
            ? json['InstanceCount'] as int
            : null,
        offeringId: json.containsKey('OfferingId')
            ? json['OfferingId'] as String
            : null,
      );
}

/// Details about the target configuration.
class TargetConfigurationRequest {
  /// The number of instances the Covertible Reserved Instance offering can be
  /// applied to. This parameter is reserved and cannot be specified in a
  /// request
  final int instanceCount;

  /// The Convertible Reserved Instance offering ID.
  final String offeringId;

  TargetConfigurationRequest({
    this.instanceCount,
    @required this.offeringId,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a load balancer target group.
class TargetGroup {
  /// The Amazon Resource Name (ARN) of the target group.
  final String arn;

  TargetGroup({
    this.arn,
  });
  static TargetGroup fromJson(Map<String, dynamic> json) => TargetGroup(
        arn: json.containsKey('Arn') ? json['Arn'] as String : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the target groups to attach to a Spot Fleet. Spot Fleet registers
/// the running Spot Instances with these target groups.
class TargetGroupsConfig {
  /// One or more target groups.
  final List<TargetGroup> targetGroups;

  TargetGroupsConfig({
    this.targetGroups,
  });
  static TargetGroupsConfig fromJson(Map<String, dynamic> json) =>
      TargetGroupsConfig(
        targetGroups: json.containsKey('TargetGroups')
            ? (json['TargetGroups'] as List)
                .map((e) => TargetGroup.fromJson(e))
                .toList()
            : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a target network associated with a Client VPN endpoint.
class TargetNetwork {
  /// The ID of the association.
  final String associationId;

  /// The ID of the VPC in which the target network (subnet) is located.
  final String vpcId;

  /// The ID of the subnet specified as the target network.
  final String targetNetworkId;

  /// The ID of the Client VPN endpoint with which the target network is
  /// associated.
  final String clientVpnEndpointId;

  /// The current state of the target network association.
  final AssociationStatus status;

  /// The IDs of the security groups applied to the target network association.
  final List<String> securityGroups;

  TargetNetwork({
    this.associationId,
    this.vpcId,
    this.targetNetworkId,
    this.clientVpnEndpointId,
    this.status,
    this.securityGroups,
  });
  static TargetNetwork fromJson(Map<String, dynamic> json) => TargetNetwork(
        associationId: json.containsKey('AssociationId')
            ? json['AssociationId'] as String
            : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
        targetNetworkId: json.containsKey('TargetNetworkId')
            ? json['TargetNetworkId'] as String
            : null,
        clientVpnEndpointId: json.containsKey('ClientVpnEndpointId')
            ? json['ClientVpnEndpointId'] as String
            : null,
        status: json.containsKey('Status')
            ? AssociationStatus.fromJson(json['Status'])
            : null,
        securityGroups: json.containsKey('SecurityGroups')
            ? (json['SecurityGroups'] as List).map((e) => e as String).toList()
            : null,
      );
}

/// The total value of the new Convertible Reserved Instances.
class TargetReservationValue {
  /// The total value of the Convertible Reserved Instances that make up the
  /// exchange. This is the sum of the list value, remaining upfront price, and
  /// additional upfront cost of the exchange.
  final ReservationValue reservationValue;

  /// The configuration of the Convertible Reserved Instances that make up the
  /// exchange.
  final TargetConfiguration targetConfiguration;

  TargetReservationValue({
    this.reservationValue,
    this.targetConfiguration,
  });
  static TargetReservationValue fromJson(Map<String, dynamic> json) =>
      TargetReservationValue(
        reservationValue: json.containsKey('ReservationValue')
            ? ReservationValue.fromJson(json['ReservationValue'])
            : null,
        targetConfiguration: json.containsKey('TargetConfiguration')
            ? TargetConfiguration.fromJson(json['TargetConfiguration'])
            : null,
      );
}

class TerminateClientVpnConnectionsResult {
  /// The ID of the Client VPN endpoint.
  final String clientVpnEndpointId;

  /// The user who established the terminated client connections.
  final String username;

  /// The current state of the client connections.
  final List<TerminateConnectionStatus> connectionStatuses;

  TerminateClientVpnConnectionsResult({
    this.clientVpnEndpointId,
    this.username,
    this.connectionStatuses,
  });
  static TerminateClientVpnConnectionsResult fromJson(
          Map<String, dynamic> json) =>
      TerminateClientVpnConnectionsResult(
        clientVpnEndpointId: json.containsKey('ClientVpnEndpointId')
            ? json['ClientVpnEndpointId'] as String
            : null,
        username:
            json.containsKey('Username') ? json['Username'] as String : null,
        connectionStatuses: json.containsKey('ConnectionStatuses')
            ? (json['ConnectionStatuses'] as List)
                .map((e) => TerminateConnectionStatus.fromJson(e))
                .toList()
            : null,
      );
}

/// Information about a terminated Client VPN endpoint client connection.
class TerminateConnectionStatus {
  /// The ID of the client connection.
  final String connectionId;

  /// The state of the client connection.
  final ClientVpnConnectionStatus previousStatus;

  /// A message about the status of the client connection, if applicable.
  final ClientVpnConnectionStatus currentStatus;

  TerminateConnectionStatus({
    this.connectionId,
    this.previousStatus,
    this.currentStatus,
  });
  static TerminateConnectionStatus fromJson(Map<String, dynamic> json) =>
      TerminateConnectionStatus(
        connectionId: json.containsKey('ConnectionId')
            ? json['ConnectionId'] as String
            : null,
        previousStatus: json.containsKey('PreviousStatus')
            ? ClientVpnConnectionStatus.fromJson(json['PreviousStatus'])
            : null,
        currentStatus: json.containsKey('CurrentStatus')
            ? ClientVpnConnectionStatus.fromJson(json['CurrentStatus'])
            : null,
      );
}

class TerminateInstancesResult {
  /// Information about the terminated instances.
  final List<InstanceStateChange> terminatingInstances;

  TerminateInstancesResult({
    this.terminatingInstances,
  });
  static TerminateInstancesResult fromJson(Map<String, dynamic> json) =>
      TerminateInstancesResult(
        terminatingInstances: json.containsKey('TerminatingInstances')
            ? (json['TerminatingInstances'] as List)
                .map((e) => InstanceStateChange.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes the Traffic Mirror filter.
class TrafficMirrorFilter {
  /// The ID of the Traffic Mirror filter.
  final String trafficMirrorFilterId;

  /// Information about the ingress rules that are associated with the Traffic
  /// Mirror filter.
  final List<TrafficMirrorFilterRule> ingressFilterRules;

  /// Information about the egress rules that are associated with the Traffic
  /// Mirror filter.
  final List<TrafficMirrorFilterRule> egressFilterRules;

  /// The network service traffic that is associated with the Traffic Mirror
  /// filter.
  final List<String> networkServices;

  /// The description of the Traffic Mirror filter.
  final String description;

  /// The tags assigned to the Traffic Mirror filter.
  final List<Tag> tags;

  TrafficMirrorFilter({
    this.trafficMirrorFilterId,
    this.ingressFilterRules,
    this.egressFilterRules,
    this.networkServices,
    this.description,
    this.tags,
  });
  static TrafficMirrorFilter fromJson(Map<String, dynamic> json) =>
      TrafficMirrorFilter(
        trafficMirrorFilterId: json.containsKey('TrafficMirrorFilterId')
            ? json['TrafficMirrorFilterId'] as String
            : null,
        ingressFilterRules: json.containsKey('IngressFilterRules')
            ? (json['IngressFilterRules'] as List)
                .map((e) => TrafficMirrorFilterRule.fromJson(e))
                .toList()
            : null,
        egressFilterRules: json.containsKey('EgressFilterRules')
            ? (json['EgressFilterRules'] as List)
                .map((e) => TrafficMirrorFilterRule.fromJson(e))
                .toList()
            : null,
        networkServices: json.containsKey('NetworkServices')
            ? (json['NetworkServices'] as List).map((e) => e as String).toList()
            : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes the Traffic Mirror rule.
class TrafficMirrorFilterRule {
  /// The ID of the Traffic Mirror rule.
  final String trafficMirrorFilterRuleId;

  /// The ID of the Traffic Mirror filter that the rule is associated with.
  final String trafficMirrorFilterId;

  /// The traffic direction assigned to the Traffic Mirror rule.
  final String trafficDirection;

  /// The rule number of the Traffic Mirror rule.
  final int ruleNumber;

  /// The action assigned to the Traffic Mirror rule.
  final String ruleAction;

  /// The protocol assigned to the Traffic Mirror rule.
  final int protocol;

  /// The destination port range assigned to the Traffic Mirror rule.
  final TrafficMirrorPortRange destinationPortRange;

  /// The source port range assigned to the Traffic Mirror rule.
  final TrafficMirrorPortRange sourcePortRange;

  /// The destination CIDR block assigned to the Traffic Mirror rule.
  final String destinationCidrBlock;

  /// The source CIDR block assigned to the Traffic Mirror rule.
  final String sourceCidrBlock;

  /// The description of the Traffic Mirror rule.
  final String description;

  TrafficMirrorFilterRule({
    this.trafficMirrorFilterRuleId,
    this.trafficMirrorFilterId,
    this.trafficDirection,
    this.ruleNumber,
    this.ruleAction,
    this.protocol,
    this.destinationPortRange,
    this.sourcePortRange,
    this.destinationCidrBlock,
    this.sourceCidrBlock,
    this.description,
  });
  static TrafficMirrorFilterRule fromJson(Map<String, dynamic> json) =>
      TrafficMirrorFilterRule(
        trafficMirrorFilterRuleId: json.containsKey('TrafficMirrorFilterRuleId')
            ? json['TrafficMirrorFilterRuleId'] as String
            : null,
        trafficMirrorFilterId: json.containsKey('TrafficMirrorFilterId')
            ? json['TrafficMirrorFilterId'] as String
            : null,
        trafficDirection: json.containsKey('TrafficDirection')
            ? json['TrafficDirection'] as String
            : null,
        ruleNumber:
            json.containsKey('RuleNumber') ? json['RuleNumber'] as int : null,
        ruleAction: json.containsKey('RuleAction')
            ? json['RuleAction'] as String
            : null,
        protocol: json.containsKey('Protocol') ? json['Protocol'] as int : null,
        destinationPortRange: json.containsKey('DestinationPortRange')
            ? TrafficMirrorPortRange.fromJson(json['DestinationPortRange'])
            : null,
        sourcePortRange: json.containsKey('SourcePortRange')
            ? TrafficMirrorPortRange.fromJson(json['SourcePortRange'])
            : null,
        destinationCidrBlock: json.containsKey('DestinationCidrBlock')
            ? json['DestinationCidrBlock'] as String
            : null,
        sourceCidrBlock: json.containsKey('SourceCidrBlock')
            ? json['SourceCidrBlock'] as String
            : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
      );
}

/// Describes the Traffic Mirror port range.
class TrafficMirrorPortRange {
  /// The start of the Traffic Mirror port range. This applies to the TCP and
  /// UDP protocols.
  final int fromPort;

  /// The end of the Traffic Mirror port range. This applies to the TCP and UDP
  /// protocols.
  final int toPort;

  TrafficMirrorPortRange({
    this.fromPort,
    this.toPort,
  });
  static TrafficMirrorPortRange fromJson(Map<String, dynamic> json) =>
      TrafficMirrorPortRange(
        fromPort: json.containsKey('FromPort') ? json['FromPort'] as int : null,
        toPort: json.containsKey('ToPort') ? json['ToPort'] as int : null,
      );
}

/// Information about the Traffic Mirror filter rule port range.
class TrafficMirrorPortRangeRequest {
  /// The first port in the Traffic Mirror port range. This applies to the TCP
  /// and UDP protocols.
  final int fromPort;

  /// The last port in the Traffic Mirror port range. This applies to the TCP
  /// and UDP protocols.
  final int toPort;

  TrafficMirrorPortRangeRequest({
    this.fromPort,
    this.toPort,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a Traffic Mirror session.
class TrafficMirrorSession {
  /// The ID for the Traffic Mirror session.
  final String trafficMirrorSessionId;

  /// The ID of the Traffic Mirror target.
  final String trafficMirrorTargetId;

  /// The ID of the Traffic Mirror filter.
  final String trafficMirrorFilterId;

  /// The ID of the Traffic Mirror session's network interface.
  final String networkInterfaceId;

  /// The ID of the account that owns the Traffic Mirror session.
  final String ownerId;

  /// The number of bytes in each packet to mirror. These are the bytes after
  /// the VXLAN header. To mirror a subset, set this to the length (in bytes) to
  /// mirror. For example, if you set this value to 100, then the first 100
  /// bytes that meet the filter criteria are copied to the target. Do not
  /// specify this parameter when you want to mirror the entire packet
  final int packetLength;

  /// The session number determines the order in which sessions are evaluated
  /// when an interface is used by multiple sessions. The first session with a
  /// matching filter is the one that mirrors the packets.
  ///
  /// Valid values are 1-32766.
  final int sessionNumber;

  /// The virtual network ID associated with the Traffic Mirror session.
  final int virtualNetworkId;

  /// The description of the Traffic Mirror session.
  final String description;

  /// The tags assigned to the Traffic Mirror session.
  final List<Tag> tags;

  TrafficMirrorSession({
    this.trafficMirrorSessionId,
    this.trafficMirrorTargetId,
    this.trafficMirrorFilterId,
    this.networkInterfaceId,
    this.ownerId,
    this.packetLength,
    this.sessionNumber,
    this.virtualNetworkId,
    this.description,
    this.tags,
  });
  static TrafficMirrorSession fromJson(Map<String, dynamic> json) =>
      TrafficMirrorSession(
        trafficMirrorSessionId: json.containsKey('TrafficMirrorSessionId')
            ? json['TrafficMirrorSessionId'] as String
            : null,
        trafficMirrorTargetId: json.containsKey('TrafficMirrorTargetId')
            ? json['TrafficMirrorTargetId'] as String
            : null,
        trafficMirrorFilterId: json.containsKey('TrafficMirrorFilterId')
            ? json['TrafficMirrorFilterId'] as String
            : null,
        networkInterfaceId: json.containsKey('NetworkInterfaceId')
            ? json['NetworkInterfaceId'] as String
            : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        packetLength: json.containsKey('PacketLength')
            ? json['PacketLength'] as int
            : null,
        sessionNumber: json.containsKey('SessionNumber')
            ? json['SessionNumber'] as int
            : null,
        virtualNetworkId: json.containsKey('VirtualNetworkId')
            ? json['VirtualNetworkId'] as int
            : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes a Traffic Mirror target.
class TrafficMirrorTarget {
  /// The ID of the Traffic Mirror target.
  final String trafficMirrorTargetId;

  /// The network interface ID that is attached to the target.
  final String networkInterfaceId;

  /// The Amazon Resource Name (ARN) of the Network Load Balancer.
  final String networkLoadBalancerArn;

  /// The type of Traffic Mirror target.
  final String type;

  /// Information about the Traffic Mirror target.
  final String description;

  /// The ID of the account that owns the Traffic Mirror target.
  final String ownerId;

  /// The tags assigned to the Traffic Mirror target.
  final List<Tag> tags;

  TrafficMirrorTarget({
    this.trafficMirrorTargetId,
    this.networkInterfaceId,
    this.networkLoadBalancerArn,
    this.type,
    this.description,
    this.ownerId,
    this.tags,
  });
  static TrafficMirrorTarget fromJson(Map<String, dynamic> json) =>
      TrafficMirrorTarget(
        trafficMirrorTargetId: json.containsKey('TrafficMirrorTargetId')
            ? json['TrafficMirrorTargetId'] as String
            : null,
        networkInterfaceId: json.containsKey('NetworkInterfaceId')
            ? json['NetworkInterfaceId'] as String
            : null,
        networkLoadBalancerArn: json.containsKey('NetworkLoadBalancerArn')
            ? json['NetworkLoadBalancerArn'] as String
            : null,
        type: json.containsKey('Type') ? json['Type'] as String : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes a transit gateway.
class TransitGateway {
  /// The ID of the transit gateway.
  final String transitGatewayId;

  /// The Amazon Resource Name (ARN) of the transit gateway.
  final String transitGatewayArn;

  /// The state of the transit gateway.
  final String state;

  /// The ID of the AWS account ID that owns the transit gateway.
  final String ownerId;

  /// The description of the transit gateway.
  final String description;

  /// The creation time.
  final DateTime creationTime;

  /// The transit gateway options.
  final TransitGatewayOptions options;

  /// The tags for the transit gateway.
  final List<Tag> tags;

  TransitGateway({
    this.transitGatewayId,
    this.transitGatewayArn,
    this.state,
    this.ownerId,
    this.description,
    this.creationTime,
    this.options,
    this.tags,
  });
  static TransitGateway fromJson(Map<String, dynamic> json) => TransitGateway(
        transitGatewayId: json.containsKey('TransitGatewayId')
            ? json['TransitGatewayId'] as String
            : null,
        transitGatewayArn: json.containsKey('TransitGatewayArn')
            ? json['TransitGatewayArn'] as String
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        creationTime: json.containsKey('CreationTime')
            ? DateTime.parse(json['CreationTime'])
            : null,
        options: json.containsKey('Options')
            ? TransitGatewayOptions.fromJson(json['Options'])
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes an association between a resource attachment and a transit gateway
/// route table.
class TransitGatewayAssociation {
  /// The ID of the transit gateway route table.
  final String transitGatewayRouteTableId;

  /// The ID of the attachment.
  final String transitGatewayAttachmentId;

  /// The ID of the resource.
  final String resourceId;

  /// The resource type.
  final String resourceType;

  /// The state of the association.
  final String state;

  TransitGatewayAssociation({
    this.transitGatewayRouteTableId,
    this.transitGatewayAttachmentId,
    this.resourceId,
    this.resourceType,
    this.state,
  });
  static TransitGatewayAssociation fromJson(Map<String, dynamic> json) =>
      TransitGatewayAssociation(
        transitGatewayRouteTableId:
            json.containsKey('TransitGatewayRouteTableId')
                ? json['TransitGatewayRouteTableId'] as String
                : null,
        transitGatewayAttachmentId:
            json.containsKey('TransitGatewayAttachmentId')
                ? json['TransitGatewayAttachmentId'] as String
                : null,
        resourceId: json.containsKey('ResourceId')
            ? json['ResourceId'] as String
            : null,
        resourceType: json.containsKey('ResourceType')
            ? json['ResourceType'] as String
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
      );
}

/// Describes an attachment between a resource and a transit gateway.
class TransitGatewayAttachment {
  /// The ID of the attachment.
  final String transitGatewayAttachmentId;

  /// The ID of the transit gateway.
  final String transitGatewayId;

  /// The ID of the AWS account that owns the transit gateway.
  final String transitGatewayOwnerId;

  /// The ID of the AWS account that owns the resource.
  final String resourceOwnerId;

  /// The resource type.
  final String resourceType;

  /// The ID of the resource.
  final String resourceId;

  /// The attachment state.
  final String state;

  /// The association.
  final TransitGatewayAttachmentAssociation association;

  /// The creation time.
  final DateTime creationTime;

  /// The tags for the attachment.
  final List<Tag> tags;

  TransitGatewayAttachment({
    this.transitGatewayAttachmentId,
    this.transitGatewayId,
    this.transitGatewayOwnerId,
    this.resourceOwnerId,
    this.resourceType,
    this.resourceId,
    this.state,
    this.association,
    this.creationTime,
    this.tags,
  });
  static TransitGatewayAttachment fromJson(Map<String, dynamic> json) =>
      TransitGatewayAttachment(
        transitGatewayAttachmentId:
            json.containsKey('TransitGatewayAttachmentId')
                ? json['TransitGatewayAttachmentId'] as String
                : null,
        transitGatewayId: json.containsKey('TransitGatewayId')
            ? json['TransitGatewayId'] as String
            : null,
        transitGatewayOwnerId: json.containsKey('TransitGatewayOwnerId')
            ? json['TransitGatewayOwnerId'] as String
            : null,
        resourceOwnerId: json.containsKey('ResourceOwnerId')
            ? json['ResourceOwnerId'] as String
            : null,
        resourceType: json.containsKey('ResourceType')
            ? json['ResourceType'] as String
            : null,
        resourceId: json.containsKey('ResourceId')
            ? json['ResourceId'] as String
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        association: json.containsKey('Association')
            ? TransitGatewayAttachmentAssociation.fromJson(json['Association'])
            : null,
        creationTime: json.containsKey('CreationTime')
            ? DateTime.parse(json['CreationTime'])
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes an association.
class TransitGatewayAttachmentAssociation {
  /// The ID of the route table for the transit gateway.
  final String transitGatewayRouteTableId;

  /// The state of the association.
  final String state;

  TransitGatewayAttachmentAssociation({
    this.transitGatewayRouteTableId,
    this.state,
  });
  static TransitGatewayAttachmentAssociation fromJson(
          Map<String, dynamic> json) =>
      TransitGatewayAttachmentAssociation(
        transitGatewayRouteTableId:
            json.containsKey('TransitGatewayRouteTableId')
                ? json['TransitGatewayRouteTableId'] as String
                : null,
        state: json.containsKey('State') ? json['State'] as String : null,
      );
}

/// Describes a propagation route table.
class TransitGatewayAttachmentPropagation {
  /// The ID of the propagation route table.
  final String transitGatewayRouteTableId;

  /// The state of the propagation route table.
  final String state;

  TransitGatewayAttachmentPropagation({
    this.transitGatewayRouteTableId,
    this.state,
  });
  static TransitGatewayAttachmentPropagation fromJson(
          Map<String, dynamic> json) =>
      TransitGatewayAttachmentPropagation(
        transitGatewayRouteTableId:
            json.containsKey('TransitGatewayRouteTableId')
                ? json['TransitGatewayRouteTableId'] as String
                : null,
        state: json.containsKey('State') ? json['State'] as String : null,
      );
}

/// Describes the options for a transit gateway.
class TransitGatewayOptions {
  /// A private Autonomous System Number (ASN) for the Amazon side of a BGP
  /// session. The range is 64512 to 65534 for 16-bit ASNs and 4200000000 to
  /// 4294967294 for 32-bit ASNs.
  final BigInt amazonSideAsn;

  /// Indicates whether attachment requests are automatically accepted.
  final String autoAcceptSharedAttachments;

  /// Indicates whether resource attachments are automatically associated with
  /// the default association route table.
  final String defaultRouteTableAssociation;

  /// The ID of the default association route table.
  final String associationDefaultRouteTableId;

  /// Indicates whether resource attachments automatically propagate routes to
  /// the default propagation route table.
  final String defaultRouteTablePropagation;

  /// The ID of the default propagation route table.
  final String propagationDefaultRouteTableId;

  /// Indicates whether Equal Cost Multipath Protocol support is enabled.
  final String vpnEcmpSupport;

  /// Indicates whether DNS support is enabled.
  final String dnsSupport;

  TransitGatewayOptions({
    this.amazonSideAsn,
    this.autoAcceptSharedAttachments,
    this.defaultRouteTableAssociation,
    this.associationDefaultRouteTableId,
    this.defaultRouteTablePropagation,
    this.propagationDefaultRouteTableId,
    this.vpnEcmpSupport,
    this.dnsSupport,
  });
  static TransitGatewayOptions fromJson(Map<String, dynamic> json) =>
      TransitGatewayOptions(
        amazonSideAsn: json.containsKey('AmazonSideAsn')
            ? BigInt.from(json['AmazonSideAsn'])
            : null,
        autoAcceptSharedAttachments:
            json.containsKey('AutoAcceptSharedAttachments')
                ? json['AutoAcceptSharedAttachments'] as String
                : null,
        defaultRouteTableAssociation:
            json.containsKey('DefaultRouteTableAssociation')
                ? json['DefaultRouteTableAssociation'] as String
                : null,
        associationDefaultRouteTableId:
            json.containsKey('AssociationDefaultRouteTableId')
                ? json['AssociationDefaultRouteTableId'] as String
                : null,
        defaultRouteTablePropagation:
            json.containsKey('DefaultRouteTablePropagation')
                ? json['DefaultRouteTablePropagation'] as String
                : null,
        propagationDefaultRouteTableId:
            json.containsKey('PropagationDefaultRouteTableId')
                ? json['PropagationDefaultRouteTableId'] as String
                : null,
        vpnEcmpSupport: json.containsKey('VpnEcmpSupport')
            ? json['VpnEcmpSupport'] as String
            : null,
        dnsSupport: json.containsKey('DnsSupport')
            ? json['DnsSupport'] as String
            : null,
      );
}

/// Describes route propagation.
class TransitGatewayPropagation {
  /// The ID of the attachment.
  final String transitGatewayAttachmentId;

  /// The ID of the resource.
  final String resourceId;

  /// The resource type.
  final String resourceType;

  /// The ID of the transit gateway route table.
  final String transitGatewayRouteTableId;

  /// The state.
  final String state;

  TransitGatewayPropagation({
    this.transitGatewayAttachmentId,
    this.resourceId,
    this.resourceType,
    this.transitGatewayRouteTableId,
    this.state,
  });
  static TransitGatewayPropagation fromJson(Map<String, dynamic> json) =>
      TransitGatewayPropagation(
        transitGatewayAttachmentId:
            json.containsKey('TransitGatewayAttachmentId')
                ? json['TransitGatewayAttachmentId'] as String
                : null,
        resourceId: json.containsKey('ResourceId')
            ? json['ResourceId'] as String
            : null,
        resourceType: json.containsKey('ResourceType')
            ? json['ResourceType'] as String
            : null,
        transitGatewayRouteTableId:
            json.containsKey('TransitGatewayRouteTableId')
                ? json['TransitGatewayRouteTableId'] as String
                : null,
        state: json.containsKey('State') ? json['State'] as String : null,
      );
}

/// Describes the options for a transit gateway.
class TransitGatewayRequestOptions {
  /// A private Autonomous System Number (ASN) for the Amazon side of a BGP
  /// session. The range is 64512 to 65534 for 16-bit ASNs and 4200000000 to
  /// 4294967294 for 32-bit ASNs.
  final BigInt amazonSideAsn;

  /// Enable or disable automatic acceptance of attachment requests. The default
  /// is `disable`.
  final String autoAcceptSharedAttachments;

  /// Enable or disable automatic association with the default association route
  /// table. The default is `enable`.
  final String defaultRouteTableAssociation;

  /// Enable or disable automatic propagation of routes to the default
  /// propagation route table. The default is `enable`.
  final String defaultRouteTablePropagation;

  /// Enable or disable Equal Cost Multipath Protocol support.
  final String vpnEcmpSupport;

  /// Enable or disable DNS support.
  final String dnsSupport;

  TransitGatewayRequestOptions({
    this.amazonSideAsn,
    this.autoAcceptSharedAttachments,
    this.defaultRouteTableAssociation,
    this.defaultRouteTablePropagation,
    this.vpnEcmpSupport,
    this.dnsSupport,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a route for a transit gateway route table.
class TransitGatewayRoute {
  /// The CIDR block used for destination matches.
  final String destinationCidrBlock;

  /// The attachments.
  final List<TransitGatewayRouteAttachment> transitGatewayAttachments;

  /// The route type.
  final String type;

  /// The state of the route.
  final String state;

  TransitGatewayRoute({
    this.destinationCidrBlock,
    this.transitGatewayAttachments,
    this.type,
    this.state,
  });
  static TransitGatewayRoute fromJson(Map<String, dynamic> json) =>
      TransitGatewayRoute(
        destinationCidrBlock: json.containsKey('DestinationCidrBlock')
            ? json['DestinationCidrBlock'] as String
            : null,
        transitGatewayAttachments: json.containsKey('TransitGatewayAttachments')
            ? (json['TransitGatewayAttachments'] as List)
                .map((e) => TransitGatewayRouteAttachment.fromJson(e))
                .toList()
            : null,
        type: json.containsKey('Type') ? json['Type'] as String : null,
        state: json.containsKey('State') ? json['State'] as String : null,
      );
}

/// Describes a route attachment.
class TransitGatewayRouteAttachment {
  /// The ID of the resource.
  final String resourceId;

  /// The ID of the attachment.
  final String transitGatewayAttachmentId;

  /// The resource type.
  final String resourceType;

  TransitGatewayRouteAttachment({
    this.resourceId,
    this.transitGatewayAttachmentId,
    this.resourceType,
  });
  static TransitGatewayRouteAttachment fromJson(Map<String, dynamic> json) =>
      TransitGatewayRouteAttachment(
        resourceId: json.containsKey('ResourceId')
            ? json['ResourceId'] as String
            : null,
        transitGatewayAttachmentId:
            json.containsKey('TransitGatewayAttachmentId')
                ? json['TransitGatewayAttachmentId'] as String
                : null,
        resourceType: json.containsKey('ResourceType')
            ? json['ResourceType'] as String
            : null,
      );
}

/// Describes a transit gateway route table.
class TransitGatewayRouteTable {
  /// The ID of the transit gateway route table.
  final String transitGatewayRouteTableId;

  /// The ID of the transit gateway.
  final String transitGatewayId;

  /// The state of the transit gateway route table.
  final String state;

  /// Indicates whether this is the default association route table for the
  /// transit gateway.
  final bool defaultAssociationRouteTable;

  /// Indicates whether this is the default propagation route table for the
  /// transit gateway.
  final bool defaultPropagationRouteTable;

  /// The creation time.
  final DateTime creationTime;

  /// Any tags assigned to the route table.
  final List<Tag> tags;

  TransitGatewayRouteTable({
    this.transitGatewayRouteTableId,
    this.transitGatewayId,
    this.state,
    this.defaultAssociationRouteTable,
    this.defaultPropagationRouteTable,
    this.creationTime,
    this.tags,
  });
  static TransitGatewayRouteTable fromJson(Map<String, dynamic> json) =>
      TransitGatewayRouteTable(
        transitGatewayRouteTableId:
            json.containsKey('TransitGatewayRouteTableId')
                ? json['TransitGatewayRouteTableId'] as String
                : null,
        transitGatewayId: json.containsKey('TransitGatewayId')
            ? json['TransitGatewayId'] as String
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        defaultAssociationRouteTable:
            json.containsKey('DefaultAssociationRouteTable')
                ? json['DefaultAssociationRouteTable'] as bool
                : null,
        defaultPropagationRouteTable:
            json.containsKey('DefaultPropagationRouteTable')
                ? json['DefaultPropagationRouteTable'] as bool
                : null,
        creationTime: json.containsKey('CreationTime')
            ? DateTime.parse(json['CreationTime'])
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes an association between a route table and a resource attachment.
class TransitGatewayRouteTableAssociation {
  /// The ID of the attachment.
  final String transitGatewayAttachmentId;

  /// The ID of the resource.
  final String resourceId;

  /// The resource type.
  final String resourceType;

  /// The state of the association.
  final String state;

  TransitGatewayRouteTableAssociation({
    this.transitGatewayAttachmentId,
    this.resourceId,
    this.resourceType,
    this.state,
  });
  static TransitGatewayRouteTableAssociation fromJson(
          Map<String, dynamic> json) =>
      TransitGatewayRouteTableAssociation(
        transitGatewayAttachmentId:
            json.containsKey('TransitGatewayAttachmentId')
                ? json['TransitGatewayAttachmentId'] as String
                : null,
        resourceId: json.containsKey('ResourceId')
            ? json['ResourceId'] as String
            : null,
        resourceType: json.containsKey('ResourceType')
            ? json['ResourceType'] as String
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
      );
}

/// Describes a route table propagation.
class TransitGatewayRouteTablePropagation {
  /// The ID of the attachment.
  final String transitGatewayAttachmentId;

  /// The ID of the resource.
  final String resourceId;

  /// The type of resource.
  final String resourceType;

  /// The state of the resource.
  final String state;

  TransitGatewayRouteTablePropagation({
    this.transitGatewayAttachmentId,
    this.resourceId,
    this.resourceType,
    this.state,
  });
  static TransitGatewayRouteTablePropagation fromJson(
          Map<String, dynamic> json) =>
      TransitGatewayRouteTablePropagation(
        transitGatewayAttachmentId:
            json.containsKey('TransitGatewayAttachmentId')
                ? json['TransitGatewayAttachmentId'] as String
                : null,
        resourceId: json.containsKey('ResourceId')
            ? json['ResourceId'] as String
            : null,
        resourceType: json.containsKey('ResourceType')
            ? json['ResourceType'] as String
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
      );
}

/// Describes a VPC attachment.
class TransitGatewayVpcAttachment {
  /// The ID of the attachment.
  final String transitGatewayAttachmentId;

  /// The ID of the transit gateway.
  final String transitGatewayId;

  /// The ID of the VPC.
  final String vpcId;

  /// The ID of the AWS account that owns the VPC.
  final String vpcOwnerId;

  /// The state of the VPC attachment.
  final String state;

  /// The IDs of the subnets.
  final List<String> subnetIds;

  /// The creation time.
  final DateTime creationTime;

  /// The VPC attachment options.
  final TransitGatewayVpcAttachmentOptions options;

  /// The tags for the VPC attachment.
  final List<Tag> tags;

  TransitGatewayVpcAttachment({
    this.transitGatewayAttachmentId,
    this.transitGatewayId,
    this.vpcId,
    this.vpcOwnerId,
    this.state,
    this.subnetIds,
    this.creationTime,
    this.options,
    this.tags,
  });
  static TransitGatewayVpcAttachment fromJson(Map<String, dynamic> json) =>
      TransitGatewayVpcAttachment(
        transitGatewayAttachmentId:
            json.containsKey('TransitGatewayAttachmentId')
                ? json['TransitGatewayAttachmentId'] as String
                : null,
        transitGatewayId: json.containsKey('TransitGatewayId')
            ? json['TransitGatewayId'] as String
            : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
        vpcOwnerId: json.containsKey('VpcOwnerId')
            ? json['VpcOwnerId'] as String
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        subnetIds: json.containsKey('SubnetIds')
            ? (json['SubnetIds'] as List).map((e) => e as String).toList()
            : null,
        creationTime: json.containsKey('CreationTime')
            ? DateTime.parse(json['CreationTime'])
            : null,
        options: json.containsKey('Options')
            ? TransitGatewayVpcAttachmentOptions.fromJson(json['Options'])
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes the VPC attachment options.
class TransitGatewayVpcAttachmentOptions {
  /// Indicates whether DNS support is enabled.
  final String dnsSupport;

  /// Indicates whether IPv6 support is enabled.
  final String ipv6Support;

  TransitGatewayVpcAttachmentOptions({
    this.dnsSupport,
    this.ipv6Support,
  });
  static TransitGatewayVpcAttachmentOptions fromJson(
          Map<String, dynamic> json) =>
      TransitGatewayVpcAttachmentOptions(
        dnsSupport: json.containsKey('DnsSupport')
            ? json['DnsSupport'] as String
            : null,
        ipv6Support: json.containsKey('Ipv6Support')
            ? json['Ipv6Support'] as String
            : null,
      );
}

/// The VPN tunnel options.
class TunnelOption {
  /// The external IP address of the VPN tunnel.
  final String outsideIpAddress;

  /// The range of inside IP addresses for the tunnel.
  final String tunnelInsideCidr;

  /// The pre-shared key (PSK) to establish initial authentication between the
  /// virtual private gateway and the customer gateway.
  final String preSharedKey;

  /// The lifetime for phase 1 of the IKE negotiation, in seconds.
  final int phase1LifetimeSeconds;

  /// The lifetime for phase 2 of the IKE negotiation, in seconds.
  final int phase2LifetimeSeconds;

  /// The margin time, in seconds, before the phase 2 lifetime expires, during
  /// which the AWS side of the VPN connection performs an IKE rekey.
  final int rekeyMarginTimeSeconds;

  /// The percentage of the rekey window determined by `RekeyMarginTimeSeconds`
  /// during which the rekey time is randomly selected.
  final int rekeyFuzzPercentage;

  /// The number of packets in an IKE replay window.
  final int replayWindowSize;

  /// The number of seconds after which a DPD timeout occurs.
  final int dpdTimeoutSeconds;

  /// The permitted encryption algorithms for the VPN tunnel for phase 1 IKE
  /// negotiations.
  final List<Phase1EncryptionAlgorithmsListValue> phase1EncryptionAlgorithms;

  /// The permitted encryption algorithms for the VPN tunnel for phase 2 IKE
  /// negotiations.
  final List<Phase2EncryptionAlgorithmsListValue> phase2EncryptionAlgorithms;

  /// The permitted integrity algorithms for the VPN tunnel for phase 1 IKE
  /// negotiations.
  final List<Phase1IntegrityAlgorithmsListValue> phase1IntegrityAlgorithms;

  /// The permitted integrity algorithms for the VPN tunnel for phase 2 IKE
  /// negotiations.
  final List<Phase2IntegrityAlgorithmsListValue> phase2IntegrityAlgorithms;

  /// The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 1
  /// IKE negotiations.
  final List<Phase1dhGroupNumbersListValue> phase1dhGroupNumbers;

  /// The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 2
  /// IKE negotiations.
  final List<Phase2dhGroupNumbersListValue> phase2dhGroupNumbers;

  /// The IKE versions that are permitted for the VPN tunnel.
  final List<IkeVersionsListValue> ikeVersions;

  TunnelOption({
    this.outsideIpAddress,
    this.tunnelInsideCidr,
    this.preSharedKey,
    this.phase1LifetimeSeconds,
    this.phase2LifetimeSeconds,
    this.rekeyMarginTimeSeconds,
    this.rekeyFuzzPercentage,
    this.replayWindowSize,
    this.dpdTimeoutSeconds,
    this.phase1EncryptionAlgorithms,
    this.phase2EncryptionAlgorithms,
    this.phase1IntegrityAlgorithms,
    this.phase2IntegrityAlgorithms,
    this.phase1dhGroupNumbers,
    this.phase2dhGroupNumbers,
    this.ikeVersions,
  });
  static TunnelOption fromJson(Map<String, dynamic> json) => TunnelOption(
        outsideIpAddress: json.containsKey('OutsideIpAddress')
            ? json['OutsideIpAddress'] as String
            : null,
        tunnelInsideCidr: json.containsKey('TunnelInsideCidr')
            ? json['TunnelInsideCidr'] as String
            : null,
        preSharedKey: json.containsKey('PreSharedKey')
            ? json['PreSharedKey'] as String
            : null,
        phase1LifetimeSeconds: json.containsKey('Phase1LifetimeSeconds')
            ? json['Phase1LifetimeSeconds'] as int
            : null,
        phase2LifetimeSeconds: json.containsKey('Phase2LifetimeSeconds')
            ? json['Phase2LifetimeSeconds'] as int
            : null,
        rekeyMarginTimeSeconds: json.containsKey('RekeyMarginTimeSeconds')
            ? json['RekeyMarginTimeSeconds'] as int
            : null,
        rekeyFuzzPercentage: json.containsKey('RekeyFuzzPercentage')
            ? json['RekeyFuzzPercentage'] as int
            : null,
        replayWindowSize: json.containsKey('ReplayWindowSize')
            ? json['ReplayWindowSize'] as int
            : null,
        dpdTimeoutSeconds: json.containsKey('DpdTimeoutSeconds')
            ? json['DpdTimeoutSeconds'] as int
            : null,
        phase1EncryptionAlgorithms:
            json.containsKey('Phase1EncryptionAlgorithms')
                ? (json['Phase1EncryptionAlgorithms'] as List)
                    .map((e) => Phase1EncryptionAlgorithmsListValue.fromJson(e))
                    .toList()
                : null,
        phase2EncryptionAlgorithms:
            json.containsKey('Phase2EncryptionAlgorithms')
                ? (json['Phase2EncryptionAlgorithms'] as List)
                    .map((e) => Phase2EncryptionAlgorithmsListValue.fromJson(e))
                    .toList()
                : null,
        phase1IntegrityAlgorithms: json.containsKey('Phase1IntegrityAlgorithms')
            ? (json['Phase1IntegrityAlgorithms'] as List)
                .map((e) => Phase1IntegrityAlgorithmsListValue.fromJson(e))
                .toList()
            : null,
        phase2IntegrityAlgorithms: json.containsKey('Phase2IntegrityAlgorithms')
            ? (json['Phase2IntegrityAlgorithms'] as List)
                .map((e) => Phase2IntegrityAlgorithmsListValue.fromJson(e))
                .toList()
            : null,
        phase1dhGroupNumbers: json.containsKey('Phase1DHGroupNumbers')
            ? (json['Phase1DHGroupNumbers'] as List)
                .map((e) => Phase1dhGroupNumbersListValue.fromJson(e))
                .toList()
            : null,
        phase2dhGroupNumbers: json.containsKey('Phase2DHGroupNumbers')
            ? (json['Phase2DHGroupNumbers'] as List)
                .map((e) => Phase2dhGroupNumbersListValue.fromJson(e))
                .toList()
            : null,
        ikeVersions: json.containsKey('IkeVersions')
            ? (json['IkeVersions'] as List)
                .map((e) => IkeVersionsListValue.fromJson(e))
                .toList()
            : null,
      );
}

class UnassignIpv6AddressesResult {
  /// The ID of the network interface.
  final String networkInterfaceId;

  /// The IPv6 addresses that have been unassigned from the network interface.
  final List<String> unassignedIpv6Addresses;

  UnassignIpv6AddressesResult({
    this.networkInterfaceId,
    this.unassignedIpv6Addresses,
  });
  static UnassignIpv6AddressesResult fromJson(Map<String, dynamic> json) =>
      UnassignIpv6AddressesResult(
        networkInterfaceId: json.containsKey('NetworkInterfaceId')
            ? json['NetworkInterfaceId'] as String
            : null,
        unassignedIpv6Addresses: json.containsKey('UnassignedIpv6Addresses')
            ? (json['UnassignedIpv6Addresses'] as List)
                .map((e) => e as String)
                .toList()
            : null,
      );
}

class UnmonitorInstancesResult {
  /// The monitoring information.
  final List<InstanceMonitoring> instanceMonitorings;

  UnmonitorInstancesResult({
    this.instanceMonitorings,
  });
  static UnmonitorInstancesResult fromJson(Map<String, dynamic> json) =>
      UnmonitorInstancesResult(
        instanceMonitorings: json.containsKey('InstanceMonitorings')
            ? (json['InstanceMonitorings'] as List)
                .map((e) => InstanceMonitoring.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes the T2 or T3 instance whose credit option for CPU usage was not
/// modified.
class UnsuccessfulInstanceCreditSpecificationItem {
  /// The ID of the instance.
  final String instanceId;

  /// The applicable error for the T2 or T3 instance whose credit option for CPU
  /// usage was not modified.
  final UnsuccessfulInstanceCreditSpecificationItemError error;

  UnsuccessfulInstanceCreditSpecificationItem({
    this.instanceId,
    this.error,
  });
  static UnsuccessfulInstanceCreditSpecificationItem fromJson(
          Map<String, dynamic> json) =>
      UnsuccessfulInstanceCreditSpecificationItem(
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        error: json.containsKey('Error')
            ? UnsuccessfulInstanceCreditSpecificationItemError.fromJson(
                json['Error'])
            : null,
      );
}

/// Information about the error for the T2 or T3 instance whose credit option
/// for CPU usage was not modified.
class UnsuccessfulInstanceCreditSpecificationItemError {
  /// The error code.
  final String code;

  /// The applicable error message.
  final String message;

  UnsuccessfulInstanceCreditSpecificationItemError({
    this.code,
    this.message,
  });
  static UnsuccessfulInstanceCreditSpecificationItemError fromJson(
          Map<String, dynamic> json) =>
      UnsuccessfulInstanceCreditSpecificationItemError(
        code: json.containsKey('Code') ? json['Code'] as String : null,
        message: json.containsKey('Message') ? json['Message'] as String : null,
      );
}

/// Information about items that were not successfully processed in a batch
/// call.
class UnsuccessfulItem {
  /// Information about the error.
  final UnsuccessfulItemError error;

  /// The ID of the resource.
  final String resourceId;

  UnsuccessfulItem({
    this.error,
    this.resourceId,
  });
  static UnsuccessfulItem fromJson(Map<String, dynamic> json) =>
      UnsuccessfulItem(
        error: json.containsKey('Error')
            ? UnsuccessfulItemError.fromJson(json['Error'])
            : null,
        resourceId: json.containsKey('ResourceId')
            ? json['ResourceId'] as String
            : null,
      );
}

/// Information about the error that occurred. For more information about
/// errors, see
/// [Error Codes](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html).
class UnsuccessfulItemError {
  /// The error code.
  final String code;

  /// The error message accompanying the error code.
  final String message;

  UnsuccessfulItemError({
    this.code,
    this.message,
  });
  static UnsuccessfulItemError fromJson(Map<String, dynamic> json) =>
      UnsuccessfulItemError(
        code: json.containsKey('Code') ? json['Code'] as String : null,
        message: json.containsKey('Message') ? json['Message'] as String : null,
      );
}

class UpdateSecurityGroupRuleDescriptionsEgressResult {
  /// Returns `true` if the request succeeds; otherwise, returns an error.
  final bool return$;

  UpdateSecurityGroupRuleDescriptionsEgressResult({
    this.return$,
  });
  static UpdateSecurityGroupRuleDescriptionsEgressResult fromJson(
          Map<String, dynamic> json) =>
      UpdateSecurityGroupRuleDescriptionsEgressResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

class UpdateSecurityGroupRuleDescriptionsIngressResult {
  /// Returns `true` if the request succeeds; otherwise, returns an error.
  final bool return$;

  UpdateSecurityGroupRuleDescriptionsIngressResult({
    this.return$,
  });
  static UpdateSecurityGroupRuleDescriptionsIngressResult fromJson(
          Map<String, dynamic> json) =>
      UpdateSecurityGroupRuleDescriptionsIngressResult(
        return$: json.containsKey('Return') ? json['Return'] as bool : null,
      );
}

/// Describes the S3 bucket for the disk image.
class UserBucket {
  /// The name of the S3 bucket where the disk image is located.
  final String s3Bucket;

  /// The file name of the disk image.
  final String s3Key;

  UserBucket({
    this.s3Bucket,
    this.s3Key,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the S3 bucket for the disk image.
class UserBucketDetails {
  /// The S3 bucket from which the disk image was created.
  final String s3Bucket;

  /// The file name of the disk image.
  final String s3Key;

  UserBucketDetails({
    this.s3Bucket,
    this.s3Key,
  });
  static UserBucketDetails fromJson(Map<String, dynamic> json) =>
      UserBucketDetails(
        s3Bucket:
            json.containsKey('S3Bucket') ? json['S3Bucket'] as String : null,
        s3Key: json.containsKey('S3Key') ? json['S3Key'] as String : null,
      );
}

/// Describes the user data for an instance.
class UserData {
  /// The user data. If you are using an AWS SDK or command line tool,
  /// Base64-encoding is performed for you, and you can load the text from a
  /// file. Otherwise, you must provide Base64-encoded text.
  final String data;

  UserData({
    this.data,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a security group and AWS account ID pair.
class UserIdGroupPair {
  /// A description for the security group rule that references this user ID
  /// group pair.
  ///
  /// Constraints: Up to 255 characters in length. Allowed characters are a-z,
  /// A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
  final String description;

  /// The ID of the security group.
  final String groupId;

  /// The name of the security group. In a request, use this parameter for a
  /// security group in EC2-Classic or a default VPC only. For a security group
  /// in a nondefault VPC, use the security group ID.
  ///
  /// For a referenced security group in another VPC, this value is not returned
  /// if the referenced security group is deleted.
  final String groupName;

  /// The status of a VPC peering connection, if applicable.
  final String peeringStatus;

  /// The ID of an AWS account.
  ///
  /// For a referenced security group in another VPC, the account ID of the
  /// referenced security group is returned in the response. If the referenced
  /// security group is deleted, this value is not returned.
  ///
  /// [EC2-Classic] Required when adding or removing rules that reference a
  /// security group in another AWS account.
  final String userId;

  /// The ID of the VPC for the referenced security group, if applicable.
  final String vpcId;

  /// The ID of the VPC peering connection, if applicable.
  final String vpcPeeringConnectionId;

  UserIdGroupPair({
    this.description,
    this.groupId,
    this.groupName,
    this.peeringStatus,
    this.userId,
    this.vpcId,
    this.vpcPeeringConnectionId,
  });
  static UserIdGroupPair fromJson(Map<String, dynamic> json) => UserIdGroupPair(
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        groupId: json.containsKey('GroupId') ? json['GroupId'] as String : null,
        groupName:
            json.containsKey('GroupName') ? json['GroupName'] as String : null,
        peeringStatus: json.containsKey('PeeringStatus')
            ? json['PeeringStatus'] as String
            : null,
        userId: json.containsKey('UserId') ? json['UserId'] as String : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
        vpcPeeringConnectionId: json.containsKey('VpcPeeringConnectionId')
            ? json['VpcPeeringConnectionId'] as String
            : null,
      );
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes telemetry for a VPN tunnel.
class VgwTelemetry {
  /// The number of accepted routes.
  final int acceptedRouteCount;

  /// The date and time of the last change in status.
  final DateTime lastStatusChange;

  /// The Internet-routable IP address of the virtual private gateway's outside
  /// interface.
  final String outsideIpAddress;

  /// The status of the VPN tunnel.
  final String status;

  /// If an error occurs, a description of the error.
  final String statusMessage;

  /// The Amazon Resource Name (ARN) of the VPN tunnel endpoint certificate.
  final String certificateArn;

  VgwTelemetry({
    this.acceptedRouteCount,
    this.lastStatusChange,
    this.outsideIpAddress,
    this.status,
    this.statusMessage,
    this.certificateArn,
  });
  static VgwTelemetry fromJson(Map<String, dynamic> json) => VgwTelemetry(
        acceptedRouteCount: json.containsKey('AcceptedRouteCount')
            ? json['AcceptedRouteCount'] as int
            : null,
        lastStatusChange: json.containsKey('LastStatusChange')
            ? DateTime.parse(json['LastStatusChange'])
            : null,
        outsideIpAddress: json.containsKey('OutsideIpAddress')
            ? json['OutsideIpAddress'] as String
            : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
        statusMessage: json.containsKey('StatusMessage')
            ? json['StatusMessage'] as String
            : null,
        certificateArn: json.containsKey('CertificateArn')
            ? json['CertificateArn'] as String
            : null,
      );
}

/// Describes a volume.
class Volume {
  /// Information about the volume attachments.
  final List<VolumeAttachment> attachments;

  /// The Availability Zone for the volume.
  final String availabilityZone;

  /// The time stamp when volume creation was initiated.
  final DateTime createTime;

  /// Indicates whether the volume is encrypted.
  final bool encrypted;

  /// The Amazon Resource Name (ARN) of the AWS Key Management Service (AWS KMS)
  /// customer master key (CMK) that was used to protect the volume encryption
  /// key for the volume.
  final String kmsKeyId;

  /// The size of the volume, in GiBs.
  final int size;

  /// The snapshot from which the volume was created, if applicable.
  final String snapshotId;

  /// The volume state.
  final String state;

  /// The ID of the volume.
  final String volumeId;

  /// The number of I/O operations per second (IOPS) that the volume supports.
  /// For Provisioned IOPS SSD volumes, this represents the number of IOPS that
  /// are provisioned for the volume. For General Purpose SSD volumes, this
  /// represents the baseline performance of the volume and the rate at which
  /// the volume accumulates I/O credits for bursting. For more information, see
  /// [Amazon EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html)
  /// in the _Amazon Elastic Compute Cloud User Guide_.
  ///
  /// Constraints: Range is 100-16,000 IOPS for `gp2` volumes and 100 to
  /// 64,000IOPS for `io1` volumes, in most Regions. The maximum IOPS for `io1`
  /// of 64,000 is guaranteed only on
  /// [Nitro-based instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances).
  /// Other instance families guarantee performance up to 32,000 IOPS.
  ///
  /// Condition: This parameter is required for requests to create `io1`
  /// volumes; it is not used in requests to create `gp2`, `st1`, `sc1`, or
  /// `standard` volumes.
  final int iops;

  /// Any tags assigned to the volume.
  final List<Tag> tags;

  /// The volume type. This can be `gp2` for General Purpose SSD, `io1` for
  /// Provisioned IOPS SSD, `st1` for Throughput Optimized HDD, `sc1` for Cold
  /// HDD, or `standard` for Magnetic volumes.
  final String volumeType;

  Volume({
    this.attachments,
    this.availabilityZone,
    this.createTime,
    this.encrypted,
    this.kmsKeyId,
    this.size,
    this.snapshotId,
    this.state,
    this.volumeId,
    this.iops,
    this.tags,
    this.volumeType,
  });
  static Volume fromJson(Map<String, dynamic> json) => Volume(
        attachments: json.containsKey('Attachments')
            ? (json['Attachments'] as List)
                .map((e) => VolumeAttachment.fromJson(e))
                .toList()
            : null,
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        createTime: json.containsKey('CreateTime')
            ? DateTime.parse(json['CreateTime'])
            : null,
        encrypted:
            json.containsKey('Encrypted') ? json['Encrypted'] as bool : null,
        kmsKeyId:
            json.containsKey('KmsKeyId') ? json['KmsKeyId'] as String : null,
        size: json.containsKey('Size') ? json['Size'] as int : null,
        snapshotId: json.containsKey('SnapshotId')
            ? json['SnapshotId'] as String
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        volumeId:
            json.containsKey('VolumeId') ? json['VolumeId'] as String : null,
        iops: json.containsKey('Iops') ? json['Iops'] as int : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        volumeType: json.containsKey('VolumeType')
            ? json['VolumeType'] as String
            : null,
      );
}

/// Describes volume attachment details.
class VolumeAttachment {
  /// The time stamp when the attachment initiated.
  final DateTime attachTime;

  /// The device name.
  final String device;

  /// The ID of the instance.
  final String instanceId;

  /// The attachment state of the volume.
  final String state;

  /// The ID of the volume.
  final String volumeId;

  /// Indicates whether the EBS volume is deleted on instance termination.
  final bool deleteOnTermination;

  VolumeAttachment({
    this.attachTime,
    this.device,
    this.instanceId,
    this.state,
    this.volumeId,
    this.deleteOnTermination,
  });
  static VolumeAttachment fromJson(Map<String, dynamic> json) =>
      VolumeAttachment(
        attachTime: json.containsKey('AttachTime')
            ? DateTime.parse(json['AttachTime'])
            : null,
        device: json.containsKey('Device') ? json['Device'] as String : null,
        instanceId: json.containsKey('InstanceId')
            ? json['InstanceId'] as String
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        volumeId:
            json.containsKey('VolumeId') ? json['VolumeId'] as String : null,
        deleteOnTermination: json.containsKey('DeleteOnTermination')
            ? json['DeleteOnTermination'] as bool
            : null,
      );
}

/// Describes an EBS volume.
class VolumeDetail {
  /// The size of the volume, in GiB.
  final BigInt size;

  VolumeDetail({
    @required this.size,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes the modification status of an EBS volume.
///
/// If the volume has never been modified, some element values will be null.
class VolumeModification {
  /// The ID of the volume.
  final String volumeId;

  /// The current modification state. The modification state is null for
  /// unmodified volumes.
  final String modificationState;

  /// A status message about the modification progress or failure.
  final String statusMessage;

  /// The target size of the volume, in GiB.
  final int targetSize;

  /// The target IOPS rate of the volume.
  final int targetIops;

  /// The target EBS volume type of the volume.
  final String targetVolumeType;

  /// The original size of the volume.
  final int originalSize;

  /// The original IOPS rate of the volume.
  final int originalIops;

  /// The original EBS volume type of the volume.
  final String originalVolumeType;

  /// The modification progress, from 0 to 100 percent complete.
  final BigInt progress;

  /// The modification start time.
  final DateTime startTime;

  /// The modification completion or failure time.
  final DateTime endTime;

  VolumeModification({
    this.volumeId,
    this.modificationState,
    this.statusMessage,
    this.targetSize,
    this.targetIops,
    this.targetVolumeType,
    this.originalSize,
    this.originalIops,
    this.originalVolumeType,
    this.progress,
    this.startTime,
    this.endTime,
  });
  static VolumeModification fromJson(Map<String, dynamic> json) =>
      VolumeModification(
        volumeId:
            json.containsKey('VolumeId') ? json['VolumeId'] as String : null,
        modificationState: json.containsKey('ModificationState')
            ? json['ModificationState'] as String
            : null,
        statusMessage: json.containsKey('StatusMessage')
            ? json['StatusMessage'] as String
            : null,
        targetSize:
            json.containsKey('TargetSize') ? json['TargetSize'] as int : null,
        targetIops:
            json.containsKey('TargetIops') ? json['TargetIops'] as int : null,
        targetVolumeType: json.containsKey('TargetVolumeType')
            ? json['TargetVolumeType'] as String
            : null,
        originalSize: json.containsKey('OriginalSize')
            ? json['OriginalSize'] as int
            : null,
        originalIops: json.containsKey('OriginalIops')
            ? json['OriginalIops'] as int
            : null,
        originalVolumeType: json.containsKey('OriginalVolumeType')
            ? json['OriginalVolumeType'] as String
            : null,
        progress:
            json.containsKey('Progress') ? BigInt.from(json['Progress']) : null,
        startTime: json.containsKey('StartTime')
            ? DateTime.parse(json['StartTime'])
            : null,
        endTime: json.containsKey('EndTime')
            ? DateTime.parse(json['EndTime'])
            : null,
      );
}

/// Describes a volume status operation code.
class VolumeStatusAction {
  /// The code identifying the operation, for example, `enable-volume-io`.
  final String code;

  /// A description of the operation.
  final String description;

  /// The ID of the event associated with this operation.
  final String eventId;

  /// The event type associated with this operation.
  final String eventType;

  VolumeStatusAction({
    this.code,
    this.description,
    this.eventId,
    this.eventType,
  });
  static VolumeStatusAction fromJson(Map<String, dynamic> json) =>
      VolumeStatusAction(
        code: json.containsKey('Code') ? json['Code'] as String : null,
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        eventId: json.containsKey('EventId') ? json['EventId'] as String : null,
        eventType:
            json.containsKey('EventType') ? json['EventType'] as String : null,
      );
}

/// Describes a volume status.
class VolumeStatusDetails {
  /// The name of the volume status.
  final String name;

  /// The intended status of the volume status.
  final String status;

  VolumeStatusDetails({
    this.name,
    this.status,
  });
  static VolumeStatusDetails fromJson(Map<String, dynamic> json) =>
      VolumeStatusDetails(
        name: json.containsKey('Name') ? json['Name'] as String : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
      );
}

/// Describes a volume status event.
class VolumeStatusEvent {
  /// A description of the event.
  final String description;

  /// The ID of this event.
  final String eventId;

  /// The type of this event.
  final String eventType;

  /// The latest end time of the event.
  final DateTime notAfter;

  /// The earliest start time of the event.
  final DateTime notBefore;

  VolumeStatusEvent({
    this.description,
    this.eventId,
    this.eventType,
    this.notAfter,
    this.notBefore,
  });
  static VolumeStatusEvent fromJson(Map<String, dynamic> json) =>
      VolumeStatusEvent(
        description: json.containsKey('Description')
            ? json['Description'] as String
            : null,
        eventId: json.containsKey('EventId') ? json['EventId'] as String : null,
        eventType:
            json.containsKey('EventType') ? json['EventType'] as String : null,
        notAfter: json.containsKey('NotAfter')
            ? DateTime.parse(json['NotAfter'])
            : null,
        notBefore: json.containsKey('NotBefore')
            ? DateTime.parse(json['NotBefore'])
            : null,
      );
}

/// Describes the status of a volume.
class VolumeStatusInfo {
  /// The details of the volume status.
  final List<VolumeStatusDetails> details;

  /// The status of the volume.
  final String status;

  VolumeStatusInfo({
    this.details,
    this.status,
  });
  static VolumeStatusInfo fromJson(Map<String, dynamic> json) =>
      VolumeStatusInfo(
        details: json.containsKey('Details')
            ? (json['Details'] as List)
                .map((e) => VolumeStatusDetails.fromJson(e))
                .toList()
            : null,
        status: json.containsKey('Status') ? json['Status'] as String : null,
      );
}

/// Describes the volume status.
class VolumeStatusItem {
  /// The details of the operation.
  final List<VolumeStatusAction> actions;

  /// The Availability Zone of the volume.
  final String availabilityZone;

  /// A list of events associated with the volume.
  final List<VolumeStatusEvent> events;

  /// The volume ID.
  final String volumeId;

  /// The volume status.
  final VolumeStatusInfo volumeStatus;

  VolumeStatusItem({
    this.actions,
    this.availabilityZone,
    this.events,
    this.volumeId,
    this.volumeStatus,
  });
  static VolumeStatusItem fromJson(Map<String, dynamic> json) =>
      VolumeStatusItem(
        actions: json.containsKey('Actions')
            ? (json['Actions'] as List)
                .map((e) => VolumeStatusAction.fromJson(e))
                .toList()
            : null,
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        events: json.containsKey('Events')
            ? (json['Events'] as List)
                .map((e) => VolumeStatusEvent.fromJson(e))
                .toList()
            : null,
        volumeId:
            json.containsKey('VolumeId') ? json['VolumeId'] as String : null,
        volumeStatus: json.containsKey('VolumeStatus')
            ? VolumeStatusInfo.fromJson(json['VolumeStatus'])
            : null,
      );
}

/// Describes a VPC.
class Vpc {
  /// The primary IPv4 CIDR block for the VPC.
  final String cidrBlock;

  /// The ID of the set of DHCP options you've associated with the VPC (or
  /// `default` if the default options are associated with the VPC).
  final String dhcpOptionsId;

  /// The current state of the VPC.
  final String state;

  /// The ID of the VPC.
  final String vpcId;

  /// The ID of the AWS account that owns the VPC.
  final String ownerId;

  /// The allowed tenancy of instances launched into the VPC.
  final String instanceTenancy;

  /// Information about the IPv6 CIDR blocks associated with the VPC.
  final List<VpcIpv6CidrBlockAssociation> ipv6CidrBlockAssociationSet;

  /// Information about the IPv4 CIDR blocks associated with the VPC.
  final List<VpcCidrBlockAssociation> cidrBlockAssociationSet;

  /// Indicates whether the VPC is the default VPC.
  final bool isDefault;

  /// Any tags assigned to the VPC.
  final List<Tag> tags;

  Vpc({
    this.cidrBlock,
    this.dhcpOptionsId,
    this.state,
    this.vpcId,
    this.ownerId,
    this.instanceTenancy,
    this.ipv6CidrBlockAssociationSet,
    this.cidrBlockAssociationSet,
    this.isDefault,
    this.tags,
  });
  static Vpc fromJson(Map<String, dynamic> json) => Vpc(
        cidrBlock:
            json.containsKey('CidrBlock') ? json['CidrBlock'] as String : null,
        dhcpOptionsId: json.containsKey('DhcpOptionsId')
            ? json['DhcpOptionsId'] as String
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        instanceTenancy: json.containsKey('InstanceTenancy')
            ? json['InstanceTenancy'] as String
            : null,
        ipv6CidrBlockAssociationSet:
            json.containsKey('Ipv6CidrBlockAssociationSet')
                ? (json['Ipv6CidrBlockAssociationSet'] as List)
                    .map((e) => VpcIpv6CidrBlockAssociation.fromJson(e))
                    .toList()
                : null,
        cidrBlockAssociationSet: json.containsKey('CidrBlockAssociationSet')
            ? (json['CidrBlockAssociationSet'] as List)
                .map((e) => VpcCidrBlockAssociation.fromJson(e))
                .toList()
            : null,
        isDefault:
            json.containsKey('IsDefault') ? json['IsDefault'] as bool : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes an attachment between a virtual private gateway and a VPC.
class VpcAttachment {
  /// The current state of the attachment.
  final String state;

  /// The ID of the VPC.
  final String vpcId;

  VpcAttachment({
    this.state,
    this.vpcId,
  });
  static VpcAttachment fromJson(Map<String, dynamic> json) => VpcAttachment(
        state: json.containsKey('State') ? json['State'] as String : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
      );
}

/// Describes an IPv4 CIDR block associated with a VPC.
class VpcCidrBlockAssociation {
  /// The association ID for the IPv4 CIDR block.
  final String associationId;

  /// The IPv4 CIDR block.
  final String cidrBlock;

  /// Information about the state of the CIDR block.
  final VpcCidrBlockState cidrBlockState;

  VpcCidrBlockAssociation({
    this.associationId,
    this.cidrBlock,
    this.cidrBlockState,
  });
  static VpcCidrBlockAssociation fromJson(Map<String, dynamic> json) =>
      VpcCidrBlockAssociation(
        associationId: json.containsKey('AssociationId')
            ? json['AssociationId'] as String
            : null,
        cidrBlock:
            json.containsKey('CidrBlock') ? json['CidrBlock'] as String : null,
        cidrBlockState: json.containsKey('CidrBlockState')
            ? VpcCidrBlockState.fromJson(json['CidrBlockState'])
            : null,
      );
}

/// Describes the state of a CIDR block.
class VpcCidrBlockState {
  /// The state of the CIDR block.
  final String state;

  /// A message about the status of the CIDR block, if applicable.
  final String statusMessage;

  VpcCidrBlockState({
    this.state,
    this.statusMessage,
  });
  static VpcCidrBlockState fromJson(Map<String, dynamic> json) =>
      VpcCidrBlockState(
        state: json.containsKey('State') ? json['State'] as String : null,
        statusMessage: json.containsKey('StatusMessage')
            ? json['StatusMessage'] as String
            : null,
      );
}

/// Describes whether a VPC is enabled for ClassicLink.
class VpcClassicLink {
  /// Indicates whether the VPC is enabled for ClassicLink.
  final bool classicLinkEnabled;

  /// Any tags assigned to the VPC.
  final List<Tag> tags;

  /// The ID of the VPC.
  final String vpcId;

  VpcClassicLink({
    this.classicLinkEnabled,
    this.tags,
    this.vpcId,
  });
  static VpcClassicLink fromJson(Map<String, dynamic> json) => VpcClassicLink(
        classicLinkEnabled: json.containsKey('ClassicLinkEnabled')
            ? json['ClassicLinkEnabled'] as bool
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
      );
}

/// Describes a VPC endpoint.
class VpcEndpoint {
  /// The ID of the VPC endpoint.
  final String vpcEndpointId;

  /// The type of endpoint.
  final String vpcEndpointType;

  /// The ID of the VPC to which the endpoint is associated.
  final String vpcId;

  /// The name of the service to which the endpoint is associated.
  final String serviceName;

  /// The state of the VPC endpoint.
  final String state;

  /// The policy document associated with the endpoint, if applicable.
  final String policyDocument;

  /// (Gateway endpoint) One or more route tables associated with the endpoint.
  final List<String> routeTableIds;

  /// (Interface endpoint) One or more subnets in which the endpoint is located.
  final List<String> subnetIds;

  /// (Interface endpoint) Information about the security groups associated with
  /// the network interface.
  final List<SecurityGroupIdentifier> groups;

  /// (Interface endpoint) Indicates whether the VPC is associated with a
  /// private hosted zone.
  final bool privateDnsEnabled;

  /// Indicates whether the VPC endpoint is being managed by its service.
  final bool requesterManaged;

  /// (Interface endpoint) One or more network interfaces for the endpoint.
  final List<String> networkInterfaceIds;

  /// (Interface endpoint) The DNS entries for the endpoint.
  final List<DnsEntry> dnsEntries;

  /// The date and time the VPC endpoint was created.
  final DateTime creationTimestamp;

  /// Any tags assigned to the VPC endpoint.
  final List<Tag> tags;

  /// The ID of the AWS account that owns the VPC endpoint.
  final String ownerId;

  VpcEndpoint({
    this.vpcEndpointId,
    this.vpcEndpointType,
    this.vpcId,
    this.serviceName,
    this.state,
    this.policyDocument,
    this.routeTableIds,
    this.subnetIds,
    this.groups,
    this.privateDnsEnabled,
    this.requesterManaged,
    this.networkInterfaceIds,
    this.dnsEntries,
    this.creationTimestamp,
    this.tags,
    this.ownerId,
  });
  static VpcEndpoint fromJson(Map<String, dynamic> json) => VpcEndpoint(
        vpcEndpointId: json.containsKey('VpcEndpointId')
            ? json['VpcEndpointId'] as String
            : null,
        vpcEndpointType: json.containsKey('VpcEndpointType')
            ? json['VpcEndpointType'] as String
            : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
        serviceName: json.containsKey('ServiceName')
            ? json['ServiceName'] as String
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        policyDocument: json.containsKey('PolicyDocument')
            ? json['PolicyDocument'] as String
            : null,
        routeTableIds: json.containsKey('RouteTableIds')
            ? (json['RouteTableIds'] as List).map((e) => e as String).toList()
            : null,
        subnetIds: json.containsKey('SubnetIds')
            ? (json['SubnetIds'] as List).map((e) => e as String).toList()
            : null,
        groups: json.containsKey('Groups')
            ? (json['Groups'] as List)
                .map((e) => SecurityGroupIdentifier.fromJson(e))
                .toList()
            : null,
        privateDnsEnabled: json.containsKey('PrivateDnsEnabled')
            ? json['PrivateDnsEnabled'] as bool
            : null,
        requesterManaged: json.containsKey('RequesterManaged')
            ? json['RequesterManaged'] as bool
            : null,
        networkInterfaceIds: json.containsKey('NetworkInterfaceIds')
            ? (json['NetworkInterfaceIds'] as List)
                .map((e) => e as String)
                .toList()
            : null,
        dnsEntries: json.containsKey('DnsEntries')
            ? (json['DnsEntries'] as List)
                .map((e) => DnsEntry.fromJson(e))
                .toList()
            : null,
        creationTimestamp: json.containsKey('CreationTimestamp')
            ? DateTime.parse(json['CreationTimestamp'])
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
      );
}

/// Describes a VPC endpoint connection to a service.
class VpcEndpointConnection {
  /// The ID of the service to which the endpoint is connected.
  final String serviceId;

  /// The ID of the VPC endpoint.
  final String vpcEndpointId;

  /// The AWS account ID of the owner of the VPC endpoint.
  final String vpcEndpointOwner;

  /// The state of the VPC endpoint.
  final String vpcEndpointState;

  /// The date and time the VPC endpoint was created.
  final DateTime creationTimestamp;

  /// The DNS entries for the VPC endpoint.
  final List<DnsEntry> dnsEntries;

  /// The Amazon Resource Names (ARNs) of the network load balancers for the
  /// service.
  final List<String> networkLoadBalancerArns;

  VpcEndpointConnection({
    this.serviceId,
    this.vpcEndpointId,
    this.vpcEndpointOwner,
    this.vpcEndpointState,
    this.creationTimestamp,
    this.dnsEntries,
    this.networkLoadBalancerArns,
  });
  static VpcEndpointConnection fromJson(Map<String, dynamic> json) =>
      VpcEndpointConnection(
        serviceId:
            json.containsKey('ServiceId') ? json['ServiceId'] as String : null,
        vpcEndpointId: json.containsKey('VpcEndpointId')
            ? json['VpcEndpointId'] as String
            : null,
        vpcEndpointOwner: json.containsKey('VpcEndpointOwner')
            ? json['VpcEndpointOwner'] as String
            : null,
        vpcEndpointState: json.containsKey('VpcEndpointState')
            ? json['VpcEndpointState'] as String
            : null,
        creationTimestamp: json.containsKey('CreationTimestamp')
            ? DateTime.parse(json['CreationTimestamp'])
            : null,
        dnsEntries: json.containsKey('DnsEntries')
            ? (json['DnsEntries'] as List)
                .map((e) => DnsEntry.fromJson(e))
                .toList()
            : null,
        networkLoadBalancerArns: json.containsKey('NetworkLoadBalancerArns')
            ? (json['NetworkLoadBalancerArns'] as List)
                .map((e) => e as String)
                .toList()
            : null,
      );
}

/// Describes an IPv6 CIDR block associated with a VPC.
class VpcIpv6CidrBlockAssociation {
  /// The association ID for the IPv6 CIDR block.
  final String associationId;

  /// The IPv6 CIDR block.
  final String ipv6CidrBlock;

  /// Information about the state of the CIDR block.
  final VpcCidrBlockState ipv6CidrBlockState;

  VpcIpv6CidrBlockAssociation({
    this.associationId,
    this.ipv6CidrBlock,
    this.ipv6CidrBlockState,
  });
  static VpcIpv6CidrBlockAssociation fromJson(Map<String, dynamic> json) =>
      VpcIpv6CidrBlockAssociation(
        associationId: json.containsKey('AssociationId')
            ? json['AssociationId'] as String
            : null,
        ipv6CidrBlock: json.containsKey('Ipv6CidrBlock')
            ? json['Ipv6CidrBlock'] as String
            : null,
        ipv6CidrBlockState: json.containsKey('Ipv6CidrBlockState')
            ? VpcCidrBlockState.fromJson(json['Ipv6CidrBlockState'])
            : null,
      );
}

/// Describes a VPC peering connection.
class VpcPeeringConnection {
  /// Information about the accepter VPC. CIDR block information is only
  /// returned when describing an active VPC peering connection.
  final VpcPeeringConnectionVpcInfo accepterVpcInfo;

  /// The time that an unaccepted VPC peering connection will expire.
  final DateTime expirationTime;

  /// Information about the requester VPC. CIDR block information is only
  /// returned when describing an active VPC peering connection.
  final VpcPeeringConnectionVpcInfo requesterVpcInfo;

  /// The status of the VPC peering connection.
  final VpcPeeringConnectionStateReason status;

  /// Any tags assigned to the resource.
  final List<Tag> tags;

  /// The ID of the VPC peering connection.
  final String vpcPeeringConnectionId;

  VpcPeeringConnection({
    this.accepterVpcInfo,
    this.expirationTime,
    this.requesterVpcInfo,
    this.status,
    this.tags,
    this.vpcPeeringConnectionId,
  });
  static VpcPeeringConnection fromJson(Map<String, dynamic> json) =>
      VpcPeeringConnection(
        accepterVpcInfo: json.containsKey('AccepterVpcInfo')
            ? VpcPeeringConnectionVpcInfo.fromJson(json['AccepterVpcInfo'])
            : null,
        expirationTime: json.containsKey('ExpirationTime')
            ? DateTime.parse(json['ExpirationTime'])
            : null,
        requesterVpcInfo: json.containsKey('RequesterVpcInfo')
            ? VpcPeeringConnectionVpcInfo.fromJson(json['RequesterVpcInfo'])
            : null,
        status: json.containsKey('Status')
            ? VpcPeeringConnectionStateReason.fromJson(json['Status'])
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        vpcPeeringConnectionId: json.containsKey('VpcPeeringConnectionId')
            ? json['VpcPeeringConnectionId'] as String
            : null,
      );
}

/// Describes the VPC peering connection options.
class VpcPeeringConnectionOptionsDescription {
  /// Indicates whether a local VPC can resolve public DNS hostnames to private
  /// IP addresses when queried from instances in a peer VPC.
  final bool allowDnsResolutionFromRemoteVpc;

  /// Indicates whether a local ClassicLink connection can communicate with the
  /// peer VPC over the VPC peering connection.
  final bool allowEgressFromLocalClassicLinkToRemoteVpc;

  /// Indicates whether a local VPC can communicate with a ClassicLink
  /// connection in the peer VPC over the VPC peering connection.
  final bool allowEgressFromLocalVpcToRemoteClassicLink;

  VpcPeeringConnectionOptionsDescription({
    this.allowDnsResolutionFromRemoteVpc,
    this.allowEgressFromLocalClassicLinkToRemoteVpc,
    this.allowEgressFromLocalVpcToRemoteClassicLink,
  });
  static VpcPeeringConnectionOptionsDescription fromJson(
          Map<String, dynamic> json) =>
      VpcPeeringConnectionOptionsDescription(
        allowDnsResolutionFromRemoteVpc:
            json.containsKey('AllowDnsResolutionFromRemoteVpc')
                ? json['AllowDnsResolutionFromRemoteVpc'] as bool
                : null,
        allowEgressFromLocalClassicLinkToRemoteVpc:
            json.containsKey('AllowEgressFromLocalClassicLinkToRemoteVpc')
                ? json['AllowEgressFromLocalClassicLinkToRemoteVpc'] as bool
                : null,
        allowEgressFromLocalVpcToRemoteClassicLink:
            json.containsKey('AllowEgressFromLocalVpcToRemoteClassicLink')
                ? json['AllowEgressFromLocalVpcToRemoteClassicLink'] as bool
                : null,
      );
}

/// Describes the status of a VPC peering connection.
class VpcPeeringConnectionStateReason {
  /// The status of the VPC peering connection.
  final String code;

  /// A message that provides more information about the status, if applicable.
  final String message;

  VpcPeeringConnectionStateReason({
    this.code,
    this.message,
  });
  static VpcPeeringConnectionStateReason fromJson(Map<String, dynamic> json) =>
      VpcPeeringConnectionStateReason(
        code: json.containsKey('Code') ? json['Code'] as String : null,
        message: json.containsKey('Message') ? json['Message'] as String : null,
      );
}

/// Describes a VPC in a VPC peering connection.
class VpcPeeringConnectionVpcInfo {
  /// The IPv4 CIDR block for the VPC.
  final String cidrBlock;

  /// The IPv6 CIDR block for the VPC.
  final List<Ipv6CidrBlock> ipv6CidrBlockSet;

  /// Information about the IPv4 CIDR blocks for the VPC.
  final List<CidrBlock> cidrBlockSet;

  /// The AWS account ID of the VPC owner.
  final String ownerId;

  /// Information about the VPC peering connection options for the accepter or
  /// requester VPC.
  final VpcPeeringConnectionOptionsDescription peeringOptions;

  /// The ID of the VPC.
  final String vpcId;

  /// The Region in which the VPC is located.
  final String region;

  VpcPeeringConnectionVpcInfo({
    this.cidrBlock,
    this.ipv6CidrBlockSet,
    this.cidrBlockSet,
    this.ownerId,
    this.peeringOptions,
    this.vpcId,
    this.region,
  });
  static VpcPeeringConnectionVpcInfo fromJson(Map<String, dynamic> json) =>
      VpcPeeringConnectionVpcInfo(
        cidrBlock:
            json.containsKey('CidrBlock') ? json['CidrBlock'] as String : null,
        ipv6CidrBlockSet: json.containsKey('Ipv6CidrBlockSet')
            ? (json['Ipv6CidrBlockSet'] as List)
                .map((e) => Ipv6CidrBlock.fromJson(e))
                .toList()
            : null,
        cidrBlockSet: json.containsKey('CidrBlockSet')
            ? (json['CidrBlockSet'] as List)
                .map((e) => CidrBlock.fromJson(e))
                .toList()
            : null,
        ownerId: json.containsKey('OwnerId') ? json['OwnerId'] as String : null,
        peeringOptions: json.containsKey('PeeringOptions')
            ? VpcPeeringConnectionOptionsDescription.fromJson(
                json['PeeringOptions'])
            : null,
        vpcId: json.containsKey('VpcId') ? json['VpcId'] as String : null,
        region: json.containsKey('Region') ? json['Region'] as String : null,
      );
}

/// Describes a VPN connection.
class VpnConnection {
  /// The configuration information for the VPN connection's customer gateway
  /// (in the native XML format). This element is always present in the
  /// CreateVpnConnection response; however, it's present in the
  /// DescribeVpnConnections response only if the VPN connection is in the
  /// `pending` or `available` state.
  final String customerGatewayConfiguration;

  /// The ID of the customer gateway at your end of the VPN connection.
  final String customerGatewayId;

  /// The category of the VPN connection. A value of `VPN` indicates an AWS VPN
  /// connection. A value of `VPN-Classic` indicates an AWS Classic VPN
  /// connection.
  final String category;

  /// The current state of the VPN connection.
  final String state;

  /// The type of VPN connection.
  final String type;

  /// The ID of the VPN connection.
  final String vpnConnectionId;

  /// The ID of the virtual private gateway at the AWS side of the VPN
  /// connection.
  final String vpnGatewayId;

  /// The ID of the transit gateway associated with the VPN connection.
  final String transitGatewayId;

  /// The VPN connection options.
  final VpnConnectionOptions options;

  /// The static routes associated with the VPN connection.
  final List<VpnStaticRoute> routes;

  /// Any tags assigned to the VPN connection.
  final List<Tag> tags;

  /// Information about the VPN tunnel.
  final List<VgwTelemetry> vgwTelemetry;

  VpnConnection({
    this.customerGatewayConfiguration,
    this.customerGatewayId,
    this.category,
    this.state,
    this.type,
    this.vpnConnectionId,
    this.vpnGatewayId,
    this.transitGatewayId,
    this.options,
    this.routes,
    this.tags,
    this.vgwTelemetry,
  });
  static VpnConnection fromJson(Map<String, dynamic> json) => VpnConnection(
        customerGatewayConfiguration:
            json.containsKey('CustomerGatewayConfiguration')
                ? json['CustomerGatewayConfiguration'] as String
                : null,
        customerGatewayId: json.containsKey('CustomerGatewayId')
            ? json['CustomerGatewayId'] as String
            : null,
        category:
            json.containsKey('Category') ? json['Category'] as String : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        type: json.containsKey('Type') ? json['Type'] as String : null,
        vpnConnectionId: json.containsKey('VpnConnectionId')
            ? json['VpnConnectionId'] as String
            : null,
        vpnGatewayId: json.containsKey('VpnGatewayId')
            ? json['VpnGatewayId'] as String
            : null,
        transitGatewayId: json.containsKey('TransitGatewayId')
            ? json['TransitGatewayId'] as String
            : null,
        options: json.containsKey('Options')
            ? VpnConnectionOptions.fromJson(json['Options'])
            : null,
        routes: json.containsKey('Routes')
            ? (json['Routes'] as List)
                .map((e) => VpnStaticRoute.fromJson(e))
                .toList()
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
        vgwTelemetry: json.containsKey('VgwTelemetry')
            ? (json['VgwTelemetry'] as List)
                .map((e) => VgwTelemetry.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes VPN connection options.
class VpnConnectionOptions {
  /// Indicates whether the VPN connection uses static routes only. Static
  /// routes must be used for devices that don't support BGP.
  final bool staticRoutesOnly;

  /// Indicates the VPN tunnel options.
  final List<TunnelOption> tunnelOptions;

  VpnConnectionOptions({
    this.staticRoutesOnly,
    this.tunnelOptions,
  });
  static VpnConnectionOptions fromJson(Map<String, dynamic> json) =>
      VpnConnectionOptions(
        staticRoutesOnly: json.containsKey('StaticRoutesOnly')
            ? json['StaticRoutesOnly'] as bool
            : null,
        tunnelOptions: json.containsKey('TunnelOptions')
            ? (json['TunnelOptions'] as List)
                .map((e) => TunnelOption.fromJson(e))
                .toList()
            : null,
      );
}

/// Describes VPN connection options.
class VpnConnectionOptionsSpecification {
  /// Indicate whether the VPN connection uses static routes only. If you are
  /// creating a VPN connection for a device that does not support BGP, you must
  /// specify `true`. Use CreateVpnConnectionRoute to create a static route.
  ///
  /// Default: `false`
  final bool staticRoutesOnly;

  /// The tunnel options for the VPN connection.
  final List<VpnTunnelOptionsSpecification> tunnelOptions;

  VpnConnectionOptionsSpecification({
    this.staticRoutesOnly,
    this.tunnelOptions,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

/// Describes a virtual private gateway.
class VpnGateway {
  /// The Availability Zone where the virtual private gateway was created, if
  /// applicable. This field may be empty or not returned.
  final String availabilityZone;

  /// The current state of the virtual private gateway.
  final String state;

  /// The type of VPN connection the virtual private gateway supports.
  final String type;

  /// Any VPCs attached to the virtual private gateway.
  final List<VpcAttachment> vpcAttachments;

  /// The ID of the virtual private gateway.
  final String vpnGatewayId;

  /// The private Autonomous System Number (ASN) for the Amazon side of a BGP
  /// session.
  final BigInt amazonSideAsn;

  /// Any tags assigned to the virtual private gateway.
  final List<Tag> tags;

  VpnGateway({
    this.availabilityZone,
    this.state,
    this.type,
    this.vpcAttachments,
    this.vpnGatewayId,
    this.amazonSideAsn,
    this.tags,
  });
  static VpnGateway fromJson(Map<String, dynamic> json) => VpnGateway(
        availabilityZone: json.containsKey('AvailabilityZone')
            ? json['AvailabilityZone'] as String
            : null,
        state: json.containsKey('State') ? json['State'] as String : null,
        type: json.containsKey('Type') ? json['Type'] as String : null,
        vpcAttachments: json.containsKey('VpcAttachments')
            ? (json['VpcAttachments'] as List)
                .map((e) => VpcAttachment.fromJson(e))
                .toList()
            : null,
        vpnGatewayId: json.containsKey('VpnGatewayId')
            ? json['VpnGatewayId'] as String
            : null,
        amazonSideAsn: json.containsKey('AmazonSideAsn')
            ? BigInt.from(json['AmazonSideAsn'])
            : null,
        tags: json.containsKey('Tags')
            ? (json['Tags'] as List).map((e) => Tag.fromJson(e)).toList()
            : null,
      );
}

/// Describes a static route for a VPN connection.
class VpnStaticRoute {
  /// The CIDR block associated with the local subnet of the customer data
  /// center.
  final String destinationCidrBlock;

  /// Indicates how the routes were provided.
  final String source;

  /// The current state of the static route.
  final String state;

  VpnStaticRoute({
    this.destinationCidrBlock,
    this.source,
    this.state,
  });
  static VpnStaticRoute fromJson(Map<String, dynamic> json) => VpnStaticRoute(
        destinationCidrBlock: json.containsKey('DestinationCidrBlock')
            ? json['DestinationCidrBlock'] as String
            : null,
        source: json.containsKey('Source') ? json['Source'] as String : null,
        state: json.containsKey('State') ? json['State'] as String : null,
      );
}

/// The tunnel options for a VPN connection.
class VpnTunnelOptionsSpecification {
  /// The range of inside IP addresses for the tunnel. Any specified CIDR blocks
  /// must be unique across all VPN connections that use the same virtual
  /// private gateway.
  ///
  /// Constraints: A size /30 CIDR block from the `169.254.0.0/16` range. The
  /// following CIDR blocks are reserved and cannot be used:
  ///
  /// *    `169.254.0.0/30`
  ///
  /// *    `169.254.1.0/30`
  ///
  /// *    `169.254.2.0/30`
  ///
  /// *    `169.254.3.0/30`
  ///
  /// *    `169.254.4.0/30`
  ///
  /// *    `169.254.5.0/30`
  ///
  /// *    `169.254.169.252/30`
  final String tunnelInsideCidr;

  /// The pre-shared key (PSK) to establish initial authentication between the
  /// virtual private gateway and customer gateway.
  ///
  /// Constraints: Allowed characters are alphanumeric characters, periods (.),
  /// and underscores (_). Must be between 8 and 64 characters in length and
  /// cannot start with zero (0).
  final String preSharedKey;

  /// The lifetime for phase 1 of the IKE negotiation, in seconds.
  ///
  /// Constraints: A value between 900 and 28,800.
  ///
  /// Default: `28800`
  final int phase1LifetimeSeconds;

  /// The lifetime for phase 2 of the IKE negotiation, in seconds.
  ///
  /// Constraints: A value between 900 and 3,600. The value must be less than
  /// the value for `Phase1LifetimeSeconds`.
  ///
  /// Default: `3600`
  final int phase2LifetimeSeconds;

  /// The margin time, in seconds, before the phase 2 lifetime expires, during
  /// which the AWS side of the VPN connection performs an IKE rekey. The exact
  /// time of the rekey is randomly selected based on the value for
  /// `RekeyFuzzPercentage`.
  ///
  /// Constraints: A value between 60 and half of `Phase2LifetimeSeconds`.
  ///
  /// Default: `540`
  final int rekeyMarginTimeSeconds;

  /// The percentage of the rekey window (determined by
  /// `RekeyMarginTimeSeconds`) during which the rekey time is randomly
  /// selected.
  ///
  /// Constraints: A value between 0 and 100.
  ///
  /// Default: `100`
  final int rekeyFuzzPercentage;

  /// The number of packets in an IKE replay window.
  ///
  /// Constraints: A value between 64 and 2048.
  ///
  /// Default: `1024`
  final int replayWindowSize;

  /// The number of seconds after which a DPD timeout occurs.
  ///
  /// Constraints: A value between 0 and 30.
  ///
  /// Default: `30`
  final int dpdTimeoutSeconds;

  /// One or more encryption algorithms that are permitted for the VPN tunnel
  /// for phase 1 IKE negotiations.
  ///
  /// Valid values: `AES128` | `AES256`
  final List<Phase1EncryptionAlgorithmsRequestListValue>
      phase1EncryptionAlgorithms;

  /// One or more encryption algorithms that are permitted for the VPN tunnel
  /// for phase 2 IKE negotiations.
  ///
  /// Valid values: `AES128` | `AES256`
  final List<Phase2EncryptionAlgorithmsRequestListValue>
      phase2EncryptionAlgorithms;

  /// One or more integrity algorithms that are permitted for the VPN tunnel for
  /// phase 1 IKE negotiations.
  ///
  /// Valid values: `SHA1` | `SHA2-256`
  final List<Phase1IntegrityAlgorithmsRequestListValue>
      phase1IntegrityAlgorithms;

  /// One or more integrity algorithms that are permitted for the VPN tunnel for
  /// phase 2 IKE negotiations.
  ///
  /// Valid values: `SHA1` | `SHA2-256`
  final List<Phase2IntegrityAlgorithmsRequestListValue>
      phase2IntegrityAlgorithms;

  /// One or more Diffie-Hellman group numbers that are permitted for the VPN
  /// tunnel for phase 1 IKE negotiations.
  ///
  /// Valid values: `2` | `14` | `15` | `16` | `17` | `18` | `22` | `23` | `24`
  final List<Phase1dhGroupNumbersRequestListValue> phase1dhGroupNumbers;

  /// One or more Diffie-Hellman group numbers that are permitted for the VPN
  /// tunnel for phase 2 IKE negotiations.
  ///
  /// Valid values: `2` | `5` | `14` | `15` | `16` | `17` | `18` | `22` | `23` |
  /// `24`
  final List<Phase2dhGroupNumbersRequestListValue> phase2dhGroupNumbers;

  /// The IKE versions that are permitted for the VPN tunnel.
  ///
  /// Valid values: `ikev1` | `ikev2`
  final List<IkeVersionsRequestListValue> ikeVersions;

  VpnTunnelOptionsSpecification({
    this.tunnelInsideCidr,
    this.preSharedKey,
    this.phase1LifetimeSeconds,
    this.phase2LifetimeSeconds,
    this.rekeyMarginTimeSeconds,
    this.rekeyFuzzPercentage,
    this.replayWindowSize,
    this.dpdTimeoutSeconds,
    this.phase1EncryptionAlgorithms,
    this.phase2EncryptionAlgorithms,
    this.phase1IntegrityAlgorithms,
    this.phase2IntegrityAlgorithms,
    this.phase1dhGroupNumbers,
    this.phase2dhGroupNumbers,
    this.ikeVersions,
  });
  Map<String, dynamic> toJson() => <String, dynamic>{};
}

class WithdrawByoipCidrResult {
  /// Information about the address pool.
  final ByoipCidr byoipCidr;

  WithdrawByoipCidrResult({
    this.byoipCidr,
  });
  static WithdrawByoipCidrResult fromJson(Map<String, dynamic> json) =>
      WithdrawByoipCidrResult(
        byoipCidr: json.containsKey('ByoipCidr')
            ? ByoipCidr.fromJson(json['ByoipCidr'])
            : null,
      );
}
